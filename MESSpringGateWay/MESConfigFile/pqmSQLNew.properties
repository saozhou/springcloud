
#ArtificialLinePassRateChartNode_24
 -------------------------------------------- 
 SELECT ROUND(ALLLIST.RATE, 2) RATE,
        TO_CHAR(ALLLIST.TIMENODE, 'hh24mi') TIMENODE,
        NVL(CT.YIELDR_LOWWARNING, 90) YIELDR_LOWWARNING,
        NVL(CT.YIELDR_LOWLIMIT, 85) YIELDR_LOWLIMIT
   FROM (SELECT EXP(SUM(LN(DECODE(RATE, 0, 0.000001, NULL, 0.000001, RATE)))) * 100 RATE,
                (TIMETABLE.TIMENODE) AS TIMENODE,
                DECODE(RATETABLE.LINE_NAME, '',[[lineName]], RATETABLE.LINE_NAME) LINE_NAME
           FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 TIMENODE
                   FROM DUAL
                 CONNECT BY LEVEL < 25) TIMETABLE
           LEFT JOIN (SELECT NVL(SUM(REC.PASS_QTY) /
                                DECODE(SUM(REC.PASS_QTY + REC.FAIL_QTY),
                                       0,
                                       1,
                                       SUM(REC.PASS_QTY + REC.FAIL_QTY)),
                                1) RATE,
                            REC.GROUP_NAME,
                            TRUNC(REC.INPUTDATE, 'HH') TIMENODE,
                            REC.LINE_NAME
                       FROM R_STATION_REC_T REC
                      INNER JOIN (SELECT LINE_NAME, GROUP_NAME
                                   FROM C_STATION_CONFIG_T
                                  WHERE DEAL_FLAG = 1) SC
                         ON REC.LINE_NAME = SC.LINE_NAME
                        AND REC.GROUP_NAME = SC.GROUP_NAME
                      WHERE REC.LINE_NAME =[[lineName]]
                        AND REC.INPUTDATE > SYSDATE - 1
                      GROUP BY REC.GROUP_NAME,
                               TRUNC(REC.INPUTDATE, 'HH'),
                               REC.LINE_NAME) RATETABLE
             ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
          GROUP BY TIMETABLE.TIMENODE, RATETABLE.LINE_NAME) ALLLIST
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T CT
     ON CT.LINE_NAME = ALLLIST.LINE_NAME
  ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#ArtificialLinePassRateChartNode_24


#ArtificialLinePassRateChartNode_7or30Day
 --------------------------------------------
SELECT ALLLIST.RATE,
       TO_CHAR(ALLLIST.TIMENODE, 'MM/DD') TIMENODE,
       NVL(CT.YIELDR_LOWWARNING, 90) YIELDR_LOWWARNING,
       NVL(CT.YIELDR_LOWLIMIT, 85) YIELDR_LOWLIMIT
  FROM (SELECT NVL(YIELD_TABLE.RATE, 0) RATE,
               TIMETABLE.TIMENODE,
               [[lineName]] LINE_NAME
          FROM (SELECT TRUNC(SYSDATE - [[rangeDay]], 'DD') + LEVEL TIMENODE
                  FROM DUAL
                CONNECT BY LEVEL < [[rangeDay]] + 1) TIMETABLE
          LEFT JOIN (SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           NVL(ROUND(MIN(YIELD), 4), 0) * 100 RATE,
                           T.LINE_NAME
                      FROM R_PQM_SUMMARY_T T
                     WHERE LINE_NAME = [[lineName]]
                     AND WORK_DATE >= TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME, PROCESS_NAME
                    UNION
                    SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           NVL(ROUND(MIN(YIELD), 4), 0) * 100 RATE,
                           T.LINE_NAME
                      FROM R_PQM_SUMMARY_SMT_T T
                     WHERE LINE_NAME = [[lineName]]
                     AND WORK_DATE >= TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME, PROCESS_NAME) YIELD_TABLE
            ON TIMETABLE.TIMENODE = YIELD_TABLE.TIMENODE) ALLLIST
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T CT
    ON CT.LINE_NAME = ALLLIST.LINE_NAME
    ORDER by TIMENODE
 --------------------------------------------
#ArtificialLinePassRateChartNode_7or30Day


#AutoEquipmentDelayChart
 --------------------------------------------
select NVL(msg.responsibility,'responsibility空值') STATUS_DETAIL,NVL(LOCATION,'未知位置') LOCATION,
       count(msg.result) NT
  from r_equip_materials_msg_t msg
 where equipment_id=[[equipmentID]]
   and msg.insert_date>sysdate-1
   and msg.result<>'OK'
   and msg.responsibility is not null
group by msg.responsibility,LOCATION
 union
select NVL(msg.material_no,'料號空值') STATUS_DETAIL, NVL(LOCATION,'未知位置') LOCATION,
       count(msg.result) NT
  from r_equip_materials_msg_t msg
 where msg.equipment_id=[[equipmentID]]
   and msg.insert_date>sysdate-1
   and msg.result<>'OK'
   and msg.responsibility is null
 group by msg.material_no,LOCATION
 --------------------------------------------
#AutoEquipmentDelayChart


#AutoEquipmentDelayChart2
 --------------------------------------------
SELECT ALLLIST.FAILCOUNT,
       to_char(ALLLIST.TIMENODE, 'hh24:mi') ENDDATE
  FROM (SELECT NVL(RATETABLE.FAILCOUNT,0) FAILCOUNT,
               TIMETABLE.TIMENODE
          FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + (LEVEL-1) / 24 + 1 / 24 TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < 25) TIMETABLE
          LEFT JOIN (SELECT COUNT(MSG.RESULT) FAILCOUNT,
                            TRUNC(MSG.INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                       FROM r_equip_materials_msg_t msg 
                      where MSG.EQUIPMENT_ID=[[equipmentID]]
                        AND MSG.INSERT_DATE > SYSDATE - 1
                        AND MSG.RESULT<>'OK'
                        AND MSG.RESULT IS NOT NULL
                      GROUP BY TRUNC(MSG.INSERT_DATE, 'HH')) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.FAILCOUNT) ALLLIST
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#AutoEquipmentDelayChart2


#checkEntityLineRoute
 --------------------------------------------
select COUNT(0) AS QTY from R_LINE_ROUTE_T where line_name=[[linename]]
 --------------------------------------------
#checkEntityLineRoute


#EquipmentDelayChart
 --------------------------------------------
SELECT COUNT(1) NT,
       RC.REASON_DESC || ',' || COUNT(1) STATUS_DETAIL,
       RC.REASON_DESC
  FROM R_REPAIR_T RT
 INNER JOIN C_REASON_CODE_T RC
    ON RT.REASON_CODE = RC.REASON_CODE
 WHERE RT.TEST_LINE=[[lineName]]
   AND RT.TEST_GROUP=cast( [[equipmentID]] as raw(16)) 
   AND RT.TEST_TIME>SYSDATE-1
 GROUP BY RC.REASON_DESC
 --------------------------------------------
#EquipmentDelayChart


#EquipmentDelayChart2
 --------------------------------------------
SELECT ALLLIST.FAILCOUNT,
       to_char(ALLLIST.TIMENODE, 'hh24:mi') ENDDATE
  FROM (SELECT NVL(RATETABLE.FAILCOUNT,0) FAILCOUNT,
               TIMETABLE.TIMENODE
          FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 + 1 / 24 TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < 25) TIMETABLE
          LEFT JOIN (SELECT COUNT(1) FAILCOUNT,
                            TRUNC(RT.TEST_TIME, 'HH') + 1 / 24 TIMENODE
                       FROM R_REPAIR_T RT 
                      WHERE RT.TEST_TIME > sysdate - 1
                        AND RT.TEST_LINE=[[lineName]]
                        AND RT.TEST_GROUP=cast( [[equipmentID]] as raw(16)) 
                      GROUP BY TRUNC(RT.TEST_TIME,'HH')) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.FAILCOUNT) ALLLIST
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#EquipmentDelayChart2


#equipmentECN
 --------------------------------------------
select ecn.ecn_no,
       ecn.ecn_valid_date,
       ecn.ecn_desc
  from r_equipment_ecn_t ecn
 where equipment_id=cast( [[equipmentID]] as raw(16)) 
 order by ecn.ecn_valid_date desc
 --------------------------------------------
#equipmentECN


#equipmentErrorCodeType
 --------------------------------------------
select err.error_code,
       err.error_desc,
       err.error_type
  from c_equipment_error_code_t err
 inner join c_equipment_basic_t basic
    on err.equipment_type=basic.type_id
 where basic.equipment_id=cast( [[equipmentID]] as raw(16)) 
 order by err.error_code
 --------------------------------------------
#equipmentErrorCodeType


#EquipmentListByLine_js
 --------------------------------------------
SELECT GROUP_NAME,EQUIPMENT_ID,
       (STATION_NAME || '--' || EQUIPMENT_CODE) EQUIPNAME,
       EQUIPMENT_CODE
  FROM (SELECT DISTINCT SC.GROUP_NAME, DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      'Manual Station',
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.STATION_NAME STATION_NAME
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1 
         ORDER BY STATION_IDX,EQUIPMENT_ID) 
 --------------------------------------------
#EquipmentListByLine_js


#equipmentRepeat1
 --------------------------------------------
 select ph.phenomenon_code,
        ph.description,
        sc.cnt||'/180' times,
        maxtime.mt,
        rep.reason_desc,
        rep.solution_desc,
        rep.ecn_no,
        exc.solve_emp
   from r_exception_repeated_t rep
  inner join (select distinct equipment_id,phenomenon_id
                from r_exception_repeated_t
               where equipment_id=cast( [[equipmentID]] as raw(16)) ) d
     on rep.equipment_id=d.equipment_id
    and rep.phenomenon_id=d.phenomenon_id
  inner join c_abnormal_phenomenon_t ph
     on d.phenomenon_id=ph.phenomenon_id
  inner join (select phenomenon_id,max(occur_time) mt from r_exception_repeated_t
               where equipment_id=cast( [[equipmentID]] as raw(16))  
               group by phenomenon_id) maxtime
     on d.phenomenon_id=maxtime.phenomenon_id
    and rep.occur_time=maxtime.mt
   left join r_exception_main_t exc
     on d.equipment_id=exc.equipment_id
    and d.phenomenon_id=exc.phenomenon_id
    and exc.occur_time=maxtime.mt
  inner join (select status_code,count(1) cnt from r_equip_tbs_t 
               where equipment_id=cast( [[equipmentID]] as raw(16))  and end_point>sysdate-180
               group by status_code) sc
     on sc.status_code=ph.phenomenon_code
 --------------------------------------------
#equipmentRepeat1


#equipmentRepeat2
 --------------------------------------------
select rownum,alllist.* from  
(select rep.occur_time,
       ph.phenomenon_code,
       ph.description,
       pro.status_description,
       rep.reason_desc,
       rep.solution_desc,
       rep.ecn_no,
       rep.ecn_valid_date,
       exc.solve_emp 
  from r_exception_repeated_t rep
 left join c_abnormal_phenomenon_t ph
    on ph.phenomenon_id=rep.phenomenon_id
 left join c_exception_process_status_t pro
    on rep.status=pro.status_code
  left join r_exception_main_t exc
    on exc.phenomenon_id=rep.phenomenon_id
   and exc.equipment_id=rep.equipment_id
   and exc.occur_time=rep.occur_time
 where ph.phenomenon_code=[[errorCode]]
   and rep.equipment_id=cast( [[equipmentID]] as raw(16)) 
 order by rep.occur_time desc) alllist
 --------------------------------------------
#equipmentRepeat2


#EquipmentStatusInfromation
 --------------------------------------------
select pub.status status_code,
       decode(pub.status,
              1,
              '故障',
              0,
              '正常',
              2,
              '暫停',
              3,
              '待機（無生產）',
              4,
              '待料',
              5,
              '產出滿料',
              6,
              '材料低位預警',
              7,
              '換線中',
              '其他') satus,
       sta.error_desc,
       basic.equipment_code ,
       etp.type_code as equip_type,
       cst.line_name || '--' || cst.station_name loca
  from c_Equipment_Basic_t basic
 inner join  c_station_config_t CST
    on CST.equipment_id = basic.equipment_id
 inner  join  c_equip_type_t etp
    on etp.type_id=basic.type_id
  left join   r_equipment_basic_data_t pub
    on CST.Equipment_Id = pub.equipment_id
  left join   C_equipment_error_code_t sta
    on sta.error_code = pub.status_code
   and pub.status = 1
   and sta.equipment_type = basic.type_id
 where basic.equipment_id =cast( [[EquipmentId]] as raw(16)) 
   and CST.Line_Name=[[LineName]]
 --------------------------------------------
#EquipmentStatusInfromation


#EquipmentStatusInfromation_Artificial
 --------------------------------------------
 select '' as status_code,
       decode(pub.status, 0, '未生產', '生產中') as satus,
       '' as status_detail,
       '人工站' as equip_type,
       PUB.GROUP_NAME AS equipment_code,
       '' as loca
  from (SELECT nvl(count(0), 0) status,GROUP_NAME
          FROM R_STATION_REC_T
         WHERE LINE_NAME = [[linename]]
           AND GROUP_NAME = cast( [[equipmentID]] as raw(16)) 
         GROUP BY GROUP_NAME) pub
 --------------------------------------------
#EquipmentStatusInfromation_Artificial


#EquipmentTBS1
 --------------------------------------------
select a1.lastend,
       a1.begindate,
       a1.enddate,
       a1.TBS,
       a1.TBS2,
       a1.TARGETLINE from (
  select tbs.last_end_point lastend,
         tbs.begin_point begindate,
         tbs.end_point enddate,
         round(ceil((tbs.begin_point-tbs.last_end_point)*24*60*60)/60,2) TBS,
         round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2) TBS2,
         120 TARGETLINE,
         tbs.equipment_id
    from r_equip_tbs_t tbs
   inner join c_equipment_basic_t bas
      on tbs.equipment_id=bas.equipment_id
   inner join c_equipment_error_code_t err
      on tbs.status_code=err.error_code
     and err.equipment_type=bas.type_id
   where tbs.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and tbs.end_point is not null
     and tbs.end_point>sysdate-[[days]]
     and 1=[[type_m]]
   union
  select tbs.last_type_end_point lastend,
         tbs.begin_point begindate,
         tbs.end_point enddate,
         round(ceil((tbs.begin_point-tbs.last_type_end_point)*24*60*60)/60,2) TBS,
         round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2) TBS2,
         120 TARGETLINE,
         tbs.equipment_id
    from r_equip_tbs_t tbs
   inner join c_equipment_error_code_t err
      on tbs.status_code=err.error_code
     and err.error_type='m' 
   inner join c_equipment_basic_t bas
      on tbs.equipment_id=bas.equipment_id
     and err.equipment_type=bas.type_id
   where tbs.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and tbs.end_point is not null
     and tbs.end_point>sysdate-[[days]]
     and 0=[[type_m]]) a1
   inner join c_equipment_basic_t a2
      on a1.equipment_id=a2.equipment_id
where tbs between a2.tbs_lower and a2.tbs_upper
order by a1.enddate
 --------------------------------------------
#EquipmentTBS1


#EquipmentTBS2
 --------------------------------------------
select ERRORCODE,
       ERRORDESC,
       TBS,
       ERRORTYPE
 from ( 
    select err.error_code ERRORCODE,
           err.error_desc ERRORDESC,
           count(err.error_code) TBS,
           err.error_type ERRORTYPE
      from r_equip_tbs_t rec
      left join c_equipment_basic_t basic
        on rec.equipment_id=basic.equipment_id
      left join c_equipment_error_code_t err
        on err.equipment_type=basic.type_id
       and rec.status_code=err.error_code
       and err.error_type='m'
     where rec.equipment_id=cast( [[equipmentID]] as raw(16)) 
       and err.error_code is not null
       and err.error_code<>'0'
       and rec.begin_point>sysdate-[[days]]
       and rec.status=1
       and 0=[[type_m]]
     group by err.error_code,err.error_desc,err.error_type
     union
    select err.error_code ERRORCODE,
           err.error_desc ERRORDESC,
           count(err.error_code) TBS,
           err.error_type ERRORTYPE
      from r_equip_tbs_t rec
      left join c_equipment_basic_t basic
        on rec.equipment_id=basic.equipment_id
      left join c_equipment_error_code_t err
        on err.equipment_type=basic.type_id
       and rec.status_code=err.error_code
     where rec.equipment_id=cast( [[equipmentID]] as raw(16)) 
       and err.error_code is not null
       and err.error_code<>'0'
       and rec.begin_point>sysdate-[[days]]
       and rec.status=1
       and 1=[[type_m]]
     group by err.error_code,err.error_desc,err.error_type)
 order by TBS desc
 --------------------------------------------
#EquipmentTBS2


#EquipmentYield
 --------------------------------------------
SELECT ROUND(RATE,4) RATE,ROUND(rate/dbms_random.value(0.9,1.1),4) target_rate,TIMENODE FROM (
SELECT NVL(SUM(PUB.PASS_QTY) / SUM(PUB.PASS_QTY + PUB.FAIL_QTY), 1) * 100 RATE,       
       TRUNC(PUB.END_POINT, 'hh') + 1 / 24 TIMENODE
  FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
 INNER JOIN R_EQUIPMENT_INTERFACE_BOM_T BOM
    ON PUB.INTERFACE_ITEM_ID = BOM.INTERFACE_ITEM_ID
   AND BOM.VALID = '1'
 WHERE BOM.EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
   AND END_POINT >= TRUNC([[queryDate]]) + 1 / 3
 GROUP BY TRUNC(PUB.END_POINT, 'hh'))
 ORDER BY TIMENODE
 --------------------------------------------
#EquipmentYield


#getAPIUrl
 --------------------------------------------
SELECT OFF_URL||API_PATH_NAME OFF_URL,PRD_URL||API_PATH_NAME PRD_URL 
from SFCS.c_mes_api_path_t 
WHERE UPPER(schema_name)=UPPER([[Schema_Name]])
AND ID=[[Url_ID]]
 --------------------------------------------
#getAPIUrl

#getAPIImageUrl
 --------------------------------------------
select URL
from (
select temp.*,row_number() over ( order by seq) as sn 
from 
(
select 1 as seq ,case when nvl(( SELECT COUNT(1) CNT 
                       from sfcs.c_prd_network_segment_t 
                       WHERE network_segment = SUBSTR([[ipAddress]],1,LENGTH(network_segment))
                       ),0)  = 0 then
                   OFF_URL||API_PATH_NAME 
                 else
                   PRD_URL||API_PATH_NAME
                 end as URL                  
from SFCS.c_mes_api_path_t 
WHERE UPPER(schema_name)=UPPER([[Schema_Name]])
AND ID=4
union all
select 2 as seq, 'http://10.148.192.36/images' URL
from dual 
) temp
)
where sn=1
 --------------------------------------------
#getAPIImageUrl


#getArtificialQualityPassFailQty
 --------------------------------------------
SELECT TRIM(TO_CHAR(FAILQTY, '999G999G999G999')) || '/' ||
       TRIM(TO_CHAR(PASSQTY, '999G999G999G999')) QTY,
       trim(to_char((PASSQTY / DECODE((FAILQTY + PASSQTY),0,1,(FAILQTY + PASSQTY))) * 100,999.99))||'%' RATE
  FROM (SELECT NVL(SUM(REC.PASS_QTY), 0) PASSQTY,
               NVL(SUM(REC.FAIL_QTY), 0) FAILQTY
          FROM R_STATION_REC_T REC
         WHERE REC.LINE_NAME = [[lineName]]
           AND REC.GROUP_NAME = cast( [[equipmentID]] as raw(16)) 
           AND REC.INPUTDATE >= SYSDATE-1)
 --------------------------------------------
#getArtificialQualityPassFailQty


#getAvg
 --------------------------------------------
  SELECT AVG(param.parameter_value) AVG
    FROM r_equipment_parameter_detail_t param
   INNER JOIN r_equipment_interface_bom_t bom
      ON bom.interface_item_id = param.interface_item_id
   WHERE bom.equipment_id = [[EQUIPMENT_ID]]
     AND param.parameter_id = [[PARAMETER_ID]]
     AND param.logging_date > (trunc(SYSDATE) + 1 / 3)
     AND rownum < 25
   ORDER BY param.logging_date
 --------------------------------------------
#getAvg


#getChangeLineItems
 --------------------------------------------
select part_type from C_PQM_PART_OP_T 
where opcode = [[op_code]] 
order by part_type asc 
 --------------------------------------------
#getChangeLineItems


#getChangeLineItemsByAutoType
 --------------------------------------------
select distinct part_type from c_pqm_part_alart_t where auto_type is not null
 --------------------------------------------
#getChangeLineItemsByAutoType


#getChangeLineItemsByOpcode
 --------------------------------------------
select part_type from C_PQM_PART_OP_T where opcode = [[op_code]]
 --------------------------------------------
#getChangeLineItemsByOpcode


#getChangeLineOpcode
 --------------------------------------------
select distinct OP_CODE from C_SCHEDULE_MODEL_COL_STATION_T 
order by OP_CODE asc 
 --------------------------------------------
#getChangeLineOpcode


#getCurrentShiftRangeofLine
 --------------------------------------------
Select		     case  when shift='日A' then 
						' 24 Hour'
                       else 
						 INITCAP(SHIFT) || '(' || SUBSTR(SECTION_FROM, -4, 2) || ':' ||SUBSTR(SECTION_FROM, -2, 2) || '-' || SUBSTR(SECTION_TO, -4, 2) || ':' ||SUBSTR(SECTION_TO, -2, 2) || ')' 
                       End TimeRange,
				 case when shift='日A' THEN 
						 SUBSTR(SECTION_FROM,1, 8)||'0800'	
						ELSE SECTION_FROM  END SECTION_FROM,
				 case when shift='日A' THEN 
						  to_char(to_date(SUBSTR(SECTION_FROM,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0800'  
						ELSE SECTION_TO  END SECTION_TO					
				 ,WORK_TIME       
 from (
SELECT MIN(CASE WHEN SHIFT='NIGHT' AND SECTION_FROM>'1200' THEN
       TO_CHAR(SYSDATE-1,'YYYYMMDD')||SECTION_FROM
       ELSE 
         TO_CHAR(SYSDATE,'YYYYMMDD')||SECTION_FROM
       END) SECTION_FROM,
       MAX(CASE WHEN SHIFT='NIGHT' AND SECTION_TO>'1200' THEN
       TO_CHAR(SYSDATE-1,'YYYYMMDD')||SECTION_TO
       ELSE 
         TO_CHAR(SYSDATE,'YYYYMMDD')||SECTION_TO
       END) SECTION_TO ,
       SHIFT,
       SUM(WORK_TIME) WORK_TIME        
 from C_ECHELON_SECTION_T ES
 INNER JOIN C_LINE_ECHELON_T LE ON ES.ECHELON_NAME=LE.ECHELON_NAME 
  WHERE LE.LINE_NAME=[[lineName]] GROUP BY SHIFT
  
  UNION 
  SELECT MIN(CASE WHEN SHIFT='NIGHT' AND SECTION_FROM>'1200' THEN
       TO_CHAR(SYSDATE-1,'YYYYMMDD')||SECTION_FROM
       ELSE 
         TO_CHAR(SYSDATE,'YYYYMMDD')||SECTION_FROM
       END) SECTION_FROM,
       MAX(CASE WHEN SHIFT='NIGHT' AND SECTION_TO>'1200' THEN
       TO_CHAR(SYSDATE-1,'YYYYMMDD')||SECTION_TO
       ELSE 
         TO_CHAR(SYSDATE,'YYYYMMDD')||SECTION_TO
       END) SECTION_TO,
       '2SHIFTS' SHIFT,
       SUM(WORK_TIME) WORK_TIME  
 from C_ECHELON_SECTION_T ES
 INNER JOIN C_LINE_ECHELON_T LE ON ES.ECHELON_NAME=LE.ECHELON_NAME 
  WHERE LE.LINE_NAME=[[lineName]] 
  ) WHERE SHIFT=[[shift]]
 --------------------------------------------
#getCurrentShiftRangeofLine


#getDate
 --------------------------------------------
select sysdate - 1 as datefrom,sysdate as dateto from dual
 --------------------------------------------
#getDate


#getDateFrom
 --------------------------------------------
SELECT Sysdate-60 dateF FROM dual
 --------------------------------------------
#getDateFrom


#getDateTo
 --------------------------------------------
SELECT Sysdate dateT FROM dual
 --------------------------------------------
#getDateTo


#getDBTimeZone
 --------------------------------------------
 select dbtimezone, sessiontimezone from dual
 --------------------------------------------
#getDBTimeZone


#getDVRline
 --------------------------------------------
select pa.line_name
  from c_line_desc_t li
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) pa
    on li.line_name = pa.line_name
 inner join c_line_echelon_t le
    on pa.line_name = le.line_name
 where pa.prod_area_id = [[prod_area_id]] 
   and le.echelon_name = [[echelon_name]] 
   /*and li.automation_flag = '0' */
order by pa.man_sequence

 --------------------------------------------
#getDVRline


#getDVRline_automation
 --------------------------------------------
select pa.line_name
  from ( select * from c_prod_area_line_t where delete_flag='0' ) pa
 inner join c_line_desc_t li
    on pa.line_name = li.line_name
 where pa.prod_area_id = [[prod_area_id]] 
   and li.automation_flag = '1' 
 order by pa.line_name
 --------------------------------------------
#getDVRline_automation


#getEchelonByProdAreaId
 --------------------------------------------
SELECT DISTINCT T.ECHELON_NAME echelon_name
  FROM R_PQM_DAILY_SUM_T T
INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) P
    ON T.LINE_NAME = P.LINE_NAME
INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') A
    ON P.PROD_AREA_ID = A.PROD_AREA_ID
WHERE T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
   AND A.PROD_AREA_ID = [[prod_area_id]]
UNION
SELECT DISTINCT T.ECHELON_NAME echelon_name
  FROM R_PQM_DAILY_SUM_SMT_T T
INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) P
    ON T.LINE_NAME = P.LINE_NAME
INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') A
    ON P.PROD_AREA_ID = A.PROD_AREA_ID
WHERE T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
   AND A.PROD_AREA_ID = [[prod_area_id]]
/*UNION 
	select 'Automation' echelon_name from dual*/

 --------------------------------------------
#getEchelonByProdAreaId


#getEchelonByProdAreaId_usedByPQ
 --------------------------------------------
select ECHELON_NAME
  from (select distinct le.echelon_name ECHELON_NAME
          from ( select * from c_prod_area_line_t where delete_flag='0' ) pa
         inner join c_line_echelon_t le
            on pa.line_name = le.line_name
           and pa.prod_area_id = [[prod_area_id_]]
           )
 order by ECHELON_NAME

 --------------------------------------------
#getEchelonByProdAreaId_usedByPQ


#getEchelonName_and_OutGroup
 --------------------------------------------
--随意挑选一个产出站和一個梯次，用}隔開
SELECT /*P1.ECHELON_NAME,*/ P1.OUT_GROUP
  FROM R_PQM_DAILY_SUM_T P1
 INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) A1
    ON P1.LINE_NAME = A1.LINE_NAME
 INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') C1
    ON A1.PROD_AREA_ID = C1.PROD_AREA_ID
 WHERE C1.PROD_AREA_CODE = 'WJ2_MPJ_MAIN' --正式的換成 PROD_AREA_ID作為條件
   AND P1.WORK_DATE = '20160219' --TO_CHAR(SYSDATE,'YYYYMMDD')
   AND ROWNUM = 1
 --------------------------------------------
#getEchelonName_and_OutGroup


#getEquipAlertRatio
 --------------------------------------------
select phenomenon_code id_0,
       description desc_0,
       cnt no_0,
	   ROUND(cnt * 100 / cnta,2) ratio_0
      -- cnt * 100 / cnta ratio_0
  from (select ex.phenomenon_code, ph.description, count(1) cnt
          from r_exception_main_t ex
         left join c_abnormal_phenomenon_t ph
            on ex.phenomenon_id = ph.phenomenon_id
         where ex.equipment_id = [[equipment_id]] 
        and ex.occur_time > sysdate - to_number([[rangeDay]]) 
         group by ex.phenomenon_code, ph.description, ph.phenomenon_id),
       (select count(1) cnta
          from r_exception_main_t ex
         left join c_abnormal_phenomenon_t ph
            on ex.phenomenon_id = ph.phenomenon_id
         where ex.equipment_id = [[equipment_id]]
       		and ex.occur_time > sysdate - to_number([[rangeDay]]) )
 order by cnt desc
 --------------------------------------------
#getEquipAlertRatio


#getEquipmentCodeForLevel3
 --------------------------------------------
SELECT EQUIPMENT_CODE
  FROM C_EQUIPMENT_BASIC_T BASIC
 WHERE BASIC.EQUIPMENT_ID = [[EquipmentInfo]]
    OR BASIC.EQUIPMENT_CODE = [[EquipmentInfo]]
   AND ROWNUM = 1
 --------------------------------------------
#getEquipmentCodeForLevel3


#getEquipmentIdByLine
 --------------------------------------------
 SELECT BASIC.EQUIPMENT_ID,
        BASIC.EQUIPMENT_ID || '--' || BASIC.GROUP_NAME EQUIPNAME
   FROM C_EQUIPMENT_BASIC_T BASIC
  WHERE BASIC.LINE_NAME =[[LineName]]
 --------------------------------------------
#getEquipmentIdByLine


#getEquipmentList
 --------------------------------------------
SELECT bom.Interface_Item_Id,
       basic.equipment_id,
       basic.equipment_id || '--' || basic.group_name eq_label,
       idx.idx
  FROM c_Equipment_Basic_t basic
 INNER JOIN R_Equipment_Interface_BOM_t bom
    ON basic.equipment_id = bom.equipment_id
   AND bom.valid = '1'
 INNER JOIN r_demo_group_idx_t idx
    ON idx.group_name = basic.group_name
   AND idx.line = basic.line_name
 ORDER BY idx.idx
 --------------------------------------------
#getEquipmentList


#getFactory
 --------------------------------------------
SELECT distinct FACTORY FROM SFCS.C_PROD_AREA_T where  delete_flag='0' ORDER BY FACTORY
 --------------------------------------------
#getFactory


#getGroupListByLine
 --------------------------------------------
 SELECT GROUP_NAME EQUIPNAME,
        GROUP_NAME EQUIPMENT_CODE,
        GROUP_NAME EQUIPMENT_ID
   FROM R_LINE_ROUTE_T
   WHERE LINE_NAME=[[lineName]]
  ORDER BY GROUP_ORDER
 --------------------------------------------
#getGroupListByLine


#getGroupListByLineBackup0731
 --------------------------------------------
select alllist.EQUIPNAME,
       alllist.EQUIPMENT_CODE,
       alllist.EQUIPMENT_ID
  from (
select route.group_next EQUIPNAME,
       route.group_next EQUIPMENT_CODE,
       route.group_next EQUIPMENT_ID,
       route.step_sequence 
  from c_route_control_t route
 inner join (select rc.route_code,
                    min(rc.step_sequence) minone
               from c_route_control_t rc
              inner join r_mo_base_t mo
                 on rc.route_code=mo.route_code
              inner join (SELECT mo.sfcs_mo mo_number,MO.sfcs_model model_name from r_schedule_sfcs_t mo    
                           WHERE mo.line_name=[[lineName]]  AND mo.flag='1') A
                 on a.mo_number=mo.mo_number
              where rc.state_flag=1
              group by rc.route_code) routemin
    on route.route_code=routemin.route_code
 where route.state_flag=0
   and route.route_desc='0'
   and route.step_sequence<routemin.minone
 union
select route.group_next EQUIPNAME,
       route.group_next EQUIPMENT_CODE,
       route.group_next EQUIPMENT_ID,
       route.step_sequence
  from c_route_control_t route
 inner join (select rc.route_code,
                    min(rc.step_sequence) minone
               from c_route_control_t rc
              inner join r_mo_smt_t mo
                 on rc.route_code=mo.route_code
              inner join (SELECT mo.sfcs_mo mo_number,MO.sfcs_model model_name from r_schedule_sfcs_t mo    
                           WHERE mo.line_name=[[lineName]]  AND mo.flag='1') A
                 on a.mo_number=mo.mo_number
              where rc.state_flag=1
              group by rc.route_code) routemin
    on route.route_code=routemin.route_code
 where route.state_flag=0
   and route.route_desc='0'
   and route.step_sequence<routemin.minone ) alllist
 order by alllist.step_sequence
 --------------------------------------------
#getGroupListByLineBackup0731


#getKeyParam
 --------------------------------------------
select param.PARAMETER_VALUE, 'Normal' FLAG, '無' MSG
  from r_equipment_parameter_detail_t param
 inner join c_equipment_basic_t bom
    on bom.equipment_id = param.equipment_id
 where bom.equipment_id = [ [ EQUIPMENT_ID ] ]
   and param.parameter_id = [ [ PARAMETER_ID ] ]
 --------------------------------------------
#getKeyParam


#getKPIAchievedRate
 --------------------------------------------
SELECT ROUND([[realQty]]/DECODE([[planQty]],0,1,[[planQty]]),2) CAPACITY,to_char(ROUND([[realQty]]*100/DECODE([[planQty]],0,1,[[planQty]]),2),'fm9999990.00')||'%' CAPACITY_S FROM dual




 --------------------------------------------
#getKPIAchievedRate


#getKPIPlantOutputQty
 --------------------------------------------
SELECT NVL(PLAN_QTY,0) PLAN_OUT_QTY FROM R_PQM_RATE_T WHERE LINE_NAME=[[lineName]] AND FREQUENCY=1
 --------------------------------------------
#getKPIPlantOutputQty


#getKPIRealOutputQty
 --------------------------------------------
SELECT NVL(REAL_QTY,0) REAL_OUTPUT_QTY FROM R_PQM_RATE_T WHERE LINE_NAME=[[lineName]] AND FREQUENCY=1
 --------------------------------------------
#getKPIRealOutputQty


#getLevel3Case
 --------------------------------------------
SELECT LEVEL3_ID, LEVEL3_NAME, LEVEL3_DESC
  FROM (SELECT DISTINCT EC.LEVEL3_ID, EC.LEVEL3_NAME, EC.LEVEL3_DESC
          FROM C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON EC.EQUIP_TYPE_ID = BASIC.TYPE_ID
            AND NVL(EC.EQUIPMENT_ID,BASIC.EQUIPMENT_ID)=BASIC.EQUIPMENT_ID
         WHERE BASIC.EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
           AND EC.LEVEL3_TYPE = [[Level3Type]]
        UNION
        SELECT DISTINCT EC.LEVEL3_ID, EC.LEVEL3_NAME, EC.LEVEL3_DESC
          FROM C_LEVEL_EQUIP_CASE_T EC
         WHERE EC.LEVEL3_TYPE = [[Level3Type]]
           AND EC.EQUIP_TYPE_ID IS NULL)
 ORDER BY LEVEL3_ID
 --------------------------------------------
#getLevel3Case


#getLevel3CaseName
 --------------------------------------------
SELECT level3_name FROM (
SELECT LEC.level3_name FROM C_LEVEL_EQUIP_CASE_T LEC
INNER JOIN C_EQUIPMENT_BASIC_T BASIC ON LEC.EQUIP_TYPE_ID=BASIC.TYPE_ID
WHERE BASIC.EQUIPMENT_ID=[[EquipID]] AND LEC.LEVEL3_ID=[[Level3ID]]
UNION
SELECT LEC.level3_name FROM C_LEVEL_EQUIP_CASE_T LEC
WHERE LEC.LEVEL3_ID=[[Level3ID]] AND LEC.EQUIP_TYPE_ID IS NULL
)WHERE ROWNUM=1
 --------------------------------------------
#getLevel3CaseName


#getLevel3ParameterArea1Cnt
 --------------------------------------------
SELECT EQUIPMENT_ID,
       A.LEVEL3_ID,
       A.PARAMETER_CODE,
       A.PARAM_DESC,
       B.SQLSTRING_IDX
  FROM (SELECT BASIC.EQUIPMENT_ID || '' EQUIPMENT_ID,
               EC.LEVEL3_ID,
               CP.PARAMETER_CODE,
               EP.PARAM_DESC
          FROM C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN  C_EQUIPMENT_BASIC_T BASIC
            ON EC.EQUIP_TYPE_ID = BASIC.TYPE_ID
         INNER JOIN  C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN  C_EQUIP_PARAM_T EP
            ON EC.EQUIP_TYPE_ID = EP.EQUIP_TYPE_ID
           AND EP.PARAM_CODE = CP.PARAMETER_CODE
         WHERE BASIC.EQUIPMENT_ID = cast( [[EquipmentID]] as raw(16)) 
           AND CP.LEVEL3_ID = [[Level3ID]]
           AND CP.PARAMETER_AREA = 1
        UNION --加上公用Level3虛擬參數的部分
        SELECT [[EquipmentID]] EQUIPMENT_ID,
               EC.LEVEL3_ID,
               CP.PARAMETER_CODE,
               LVP.PARAM_DESC
          FROM  C_LEVEL_EQUIP_CASE_T EC
         INNER  JOIN C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN  C_LEVEL3_VIRTUAL_PARAM_T LVP
            ON CP.PARAMETER_CODE = LVP.PARAM_CODE
         WHERE CP.LEVEL3_ID = [[Level3ID]]
           AND EC.EQUIP_TYPE_ID IS NULL
           AND CP.PARAMETER_AREA = 1) A
 INNER JOIN (SELECT CP.LEVEL3_ID,CP.PARAMETER_CODE,--考慮SPC一個參數有兩個圖的情況
                    CASE CP.CALC_TYPEID WHEN 7 THEN 1 ELSE 1 END SQLSTRING_IDX
               FROM  C_LEVEL_CASE_PARAM_T CP
             UNION
             SELECT CP.LEVEL3_ID,CP.PARAMETER_CODE,
                    CASE CP.CALC_TYPEID WHEN 7 THEN 2 ELSE 1 END SQLSTRING_IDX
               FROM  C_LEVEL_CASE_PARAM_T CP) B
    ON A.LEVEL3_ID = B.LEVEL3_ID
   AND A.PARAMETER_CODE = B.PARAMETER_CODE
 --------------------------------------------
#getLevel3ParameterArea1Cnt


#getLevel3ParameterArea2Cnt
 --------------------------------------------
SELECT EQUIPMENT_ID,
       A.LEVEL3_ID,
       A.PARAMETER_CODE,
       A.PARAM_DESC,
       B.SQLSTRING_IDX
  FROM (SELECT BASIC.EQUIPMENT_ID || '' EQUIPMENT_ID,
               EC.LEVEL3_ID,
               CP.PARAMETER_CODE,
               EP.PARAM_DESC
          FROM  C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN  C_EQUIPMENT_BASIC_T BASIC
            ON EC.EQUIP_TYPE_ID = BASIC.TYPE_ID
         INNER JOIN  C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN  C_EQUIP_PARAM_T EP
            ON EC.EQUIP_TYPE_ID = EP.EQUIP_TYPE_ID
           AND EP.PARAM_CODE = CP.PARAMETER_CODE
         WHERE BASIC.EQUIPMENT_ID = cast( [[EquipmentID]] as raw(16)) 
           AND CP.LEVEL3_ID = [[Level3ID]]
           AND CP.PARAMETER_AREA = 2
        UNION --加上公用Level3虛擬參數的部分
        SELECT [[EquipmentID]]  EQUIPMENT_ID,
               EC.LEVEL3_ID,
               CP.PARAMETER_CODE,
               LVP.PARAM_DESC
          FROM  C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN  C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN  C_LEVEL3_VIRTUAL_PARAM_T LVP
            ON CP.PARAMETER_CODE = LVP.PARAM_CODE
         WHERE CP.LEVEL3_ID = [[Level3ID]]
           AND EC.EQUIP_TYPE_ID IS NULL
           AND CP.PARAMETER_AREA = 2) A
 INNER JOIN (SELECT CP.LEVEL3_ID,CP.PARAMETER_CODE,--考慮SPC一個參數有兩個圖的情況
                    CASE CP.CALC_TYPEID WHEN 7 THEN 1 ELSE 1 END SQLSTRING_IDX
               FROM  C_LEVEL_CASE_PARAM_T CP
             UNION
             SELECT CP.LEVEL3_ID,CP.PARAMETER_CODE,
                    CASE CP.CALC_TYPEID WHEN 7 THEN 2 ELSE 1 END SQLSTRING_IDX
               FROM  C_LEVEL_CASE_PARAM_T CP) B
    ON A.LEVEL3_ID = B.LEVEL3_ID
   AND A.PARAMETER_CODE = B.PARAMETER_CODE
 --------------------------------------------
#getLevel3ParameterArea2Cnt


#getLevel3ParameterItemArea
 --------------------------------------------
SELECT PARAMETER_ITEM_ID, PARAMETER_ITEM_NAME, CHART_TYPE
  FROM (SELECT CP.PARAMETER_CODE PARAMETER_ITEM_ID,
               EP.PARAM_DESC ||
               DECODE(CP.CALC_TYPEID,7,' XBar R-Chart',NULL)||
        	   DECODE(EP.PARAM_UNIT,
                      NULL,
                      NULL,
                      '（Unit:' || EP.PARAM_UNIT || '）') PARAMETER_ITEM_NAME,
               CP.CHART_TYPE
          FROM C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON EC.EQUIP_TYPE_ID = BASIC.TYPE_ID
         INNER JOIN C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN C_EQUIP_PARAM_T EP
            ON BASIC.TYPE_ID = EP.EQUIP_TYPE_ID
           AND CP.PARAMETER_CODE = EP.PARAM_CODE
         WHERE BASIC.EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
           AND EC.LEVEL3_ID = [[level3ID]]
           AND CP.PARAMETER_CODE = [[ParameterID]]
        UNION
        SELECT CP.PARAMETER_CODE PARAMETER_ITEM_ID,
               EP.PARAM_DESC ||
               DECODE(EP.PARAM_UNIT,
                      NULL,
                      NULL,
                      '（單位:' || EP.PARAM_UNIT || '）') PARAMETER_ITEM_NAME,
               CP.CHART_TYPE
          FROM C_LEVEL_CASE_PARAM_T CP
         INNER JOIN C_LEVEL3_VIRTUAL_PARAM_T EP
            ON CP.PARAMETER_CODE = EP.PARAM_CODE
         WHERE CP.LEVEL3_ID = [[level3ID]]
           AND CP.PARAMETER_CODE = [[ParameterID]])
 WHERE ROWNUM = 1
 --------------------------------------------
#getLevel3ParameterItemArea


#getLevel3WarningInfo
 --------------------------------------------
SELECT ALERT.PARAM_DESC PARAMETER_ITEM_NAME,ALERT.LEVEL3_NAME,PAT.TYPE_DESC WARNING_INFO,
       TO_CHAR(ALERT.ALERT_TIME,'mm/dd hh24:mi:ss') || '預警' WARNING_STATE  
       FROM(
       SELECT FIRST_VALUE(EPA.ALARM_TYPE) OVER(ORDER BY ENT.CREATE_DATE DESC) ALARM_TYPE,
       FIRST_VALUE(ENT.CREATE_DATE) OVER(ORDER BY ENT.CREATE_DATE DESC) ALERT_TIME,
       FIRST_VALUE(NVL(EP.PARAM_DESC,EPA.PARAM_CODE) ) OVER(ORDER BY ENT.CREATE_DATE DESC) PARAM_DESC,
       FIRST_VALUE(LEC.LEVEL3_NAME ) OVER(ORDER BY ENT.CREATE_DATE DESC) LEVEL3_NAME
  FROM R_EQUIP_PARAM_ALARM_T EPA
  INNER JOIN R_EQUIPMENT_NOTIFY_TASK_T ENT ON EPA.TASK_ID=ENT.TASK_ID
  INNER JOIN C_LEVEL_EQUIP_CASE_T LEC ON EPA.LEVEL3_ID=LEC.LEVEL3_ID
  INNER JOIN C_LEVEL_CASE_PARAM_T LCP ON LCP.LEVEL3_ID=EPA.LEVEL3_ID AND LCP.PARAMETER_CODE=EPA.PARAM_CODE
  LEFT JOIN C_EQUIP_PARAM_T EP ON EP.PARAM_CODE=EPA.PARAM_CODE
  WHERE EPA.EQUIPMENT_ID=cast( [[EquipmentID]] as raw(16)) 
  AND EPA.LEVEL3_ID=[[Level3ID]]
  AND ENT.CREATE_DATE>SYSDATE-1/24 --LCP.TIME_INTERVAL/60/24
  )ALERT
  INNER JOIN C_PARAM_ALARM_TYPE_T PAT ON ALERT.ALARM_TYPE=PAT.ALARM_TYPE
  WHERE ROWNUM=1
 --------------------------------------------
#getLevel3WarningInfo


#getLifetime
 --------------------------------------------
  Select part_module,part_name,part_times||unit ptu,part_limit||unit plu,
  to_char((part_limit-part_times)/part_rate,'FM999.9')||'天' nxt,warning_flag 
  from r_demo_equip_part_t
  where equipment_id=[[EQUIPMENT_ID]] order by (part_limit-part_times)/part_rate
 --------------------------------------------
#getLifetime


#getLifetimeRv1
 --------------------------------------------
SELECT pt.PARAM_DESC AS parameter_type_name,
       to_char(round(pr.param_value / pt.unit_ratio, 2), 'FM999,999,999,999,999,999') || 
       (CASE WHEN pt.param_unit IN('1','次') THEN
         '次'
       WHEN  upper(pt.param_unit) IN('2','H','HRS') THEN
         'H' 
       WHEN pt.param_unit IN('3','天') THEN
         '天'  
       ELSE  pt.param_unit
         END) AS parameter_value,
       to_char(pt.PARAM_USL, 'FM999,999,999,999,999,999') || (CASE WHEN pt.param_unit IN('1','次') THEN
         '次'
       WHEN  upper(pt.param_unit) IN('2','H','HRS') THEN
         'H' 
       WHEN pt.param_unit IN('3','天') THEN
         '天'  
       ELSE  pt.param_unit
         END) AS limit_value,
       to_char(pt.PARAM_USL - round(pr.param_value / pt.unit_ratio, 2), 'FM999,999,999,999,999,999') || 
       (CASE WHEN pt.param_unit IN('1','次') THEN
         '次'
       WHEN  upper(pt.param_unit) IN('2','H','HRS') THEN
         'H' 
       WHEN pt.param_unit IN('3','天') THEN
         '天'  
       ELSE  pt.param_unit
         END) remain,
       to_char((pt.PARAM_USL - round(pr.param_value / pt.unit_ratio, 2)) / pt.daily_time,
               'FM999,999,999,999,999,999.0') || '天' nxt,
       CASE
            WHEN (round(pr.param_value / pt.unit_ratio, 2) < pt.PARAM_LSL) or (round(pr.param_value / pt.unit_ratio, 2) > pt.PARAM_USL) THEN
             'Out of limit'
            WHEN (round(pr.param_value / pt.unit_ratio, 2) < pt.PARAM_LWV) OR (round(pr.param_value / pt.unit_ratio, 2) > pt.PARAM_UWV)  THEN
             'Warning'
            ELSE
             'Normal'
      END AS status
 FROM c_equipment_basic_t BAS
 LEFT JOIN c_equip_param_t PT
   ON BAS.TYPE_ID=PT.EQUIP_TYPE_ID
inner JOIN r_equipment_param_rt_t PR
   ON BAS.Equipment_Id=PR.Equipment_Id 
  AND PR.PARAM_CODE=PT.Param_Code
WHERE BAS.EQUIPMENT_ID=[[EQUIPMENT_ID]] 
  AND pt.param_type_id = '1'
order by pt.param_code
 --------------------------------------------
#getLifetimeRv1


#getLineAchievedChartNode_7or30Day_CR
 --------------------------------------------
SELECT ROUND(NVL(CAPACITY, 0), 4) * 100 RATE,
       substr(WORK_DATE,0,4)||'-'||substr(WORK_DATE,5,2)||'-'||substr(WORK_DATE,7,2) TIMENODE,
       NVL(C.ARCHIVER_LOWWARNING, 95) ARCHIVER_LOWWARNING,
       NVL(C.ARCHIVER_LOWLIMIT, 90) ARCHIVER_LOWLIMIT           
  FROM (SELECT WORK_DATE,
               LINE_NAME,
               AVG(CAPACITY) CAPACITY   --白夜班的平均值
          FROM R_PQM_SUMMARY_T T
         WHERE LINE_NAME = [[lineName]]
           AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
           AND WORK_DATE > TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD')
         GROUP BY WORK_DATE,LINE_NAME          
        UNION ALL--SMT線
        SELECT WORK_DATE,
               LINE_NAME,
               AVG(CAPACITY) CAPACITY  --白夜班的平均值
          FROM R_PQM_SUMMARY_SMT_T T
         WHERE LINE_NAME = [[lineName]]
           AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
           AND WORK_DATE > TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD')
         GROUP BY WORK_DATE,LINE_NAME) AA
LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T C
 ON AA.LINE_NAME = C.LINE_NAME
 ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#getLineAchievedChartNode_7or30Day_CR








#getLineAchievedChartNode_CR_Day
 --------------------------------------------
SELECT ROUND(NVL(CAPACITY, 0), 4) * 100 RATE,          
        END_TIME TIMENODE,
           NVL(ARCHIVER_LOWWARNING, 0.95)*100 ARCHIVER_LOWWARNING,
           NVL(ARCHIVER_LOWLIMIT, 0.90)*100 ARCHIVER_LOWLIMIT
      FROM (SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
              FROM R_PQM_DAILY_SUM_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'DAY'
               AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
             GROUP BY WORK_DATE,LINE_NAME,  SECTION_RANGE
           UNION ALL --前一个夜班，前半夜，日期為上一天
           SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
              FROM R_PQM_DAILY_SUM_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)>'1200'
             GROUP BY WORK_DATE,LINE_NAME,  SECTION_RANGE
            UNION ALL --前一个夜班，后半夜
           SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME 
              FROM R_PQM_DAILY_SUM_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)<'1200'
             GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
            
            UNION ALL--SMT線
            SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME 
              FROM R_PQM_DAILY_SUM_SMT_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'DAY'
               AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
             GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
           UNION ALL --前一个夜班，前半夜，日期為上一天
           SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME 
              FROM R_PQM_DAILY_SUM_SMT_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)>'1200'
             GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
            UNION ALL --前一个夜班，后半夜
           SELECT WORK_DATE,
                   LINE_NAME,
                   AVG(CAPACITY) CAPACITY,
                   AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                   AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME 
              FROM R_PQM_DAILY_SUM_SMT_T T
             WHERE LINE_NAME = [[lineName]]
               AND STATE >= 0
               AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)<'1200'
             GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE)
     ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#getLineAchievedChartNode_CR_Day


#getLineAchievedChartNode_CR_Night
 --------------------------------------------
SELECT ROUND(NVL(CAPACITY, 0), 4) * 100 RATE,
         END_TIME TIMENODE,
         NVL(ARCHIVER_LOWWARNING, 0.95)*100 ARCHIVER_LOWWARNING,
         NVL(ARCHIVER_LOWLIMIT, 0.90)*100 ARCHIVER_LOWLIMIT    
     FROM (SELECT WORK_DATE,   --前一個班次，白班
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
            FROM R_PQM_DAILY_SUM_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'DAY'
             AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
           GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
         UNION ALL --夜班，前半夜
         SELECT WORK_DATE,
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
            FROM R_PQM_DAILY_SUM_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'NIGHT'
             AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
             AND SUBSTR(SECTION_RANGE,1,4)>'1200'
           GROUP BY WORK_DATE,LINE_NAME,  SECTION_RANGE
          UNION ALL --夜班,後半夜
         SELECT WORK_DATE,
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME 
            FROM R_PQM_DAILY_SUM_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'NIGHT'
            AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE+1, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
             AND SUBSTR(SECTION_RANGE,1,4)<'1200'
           GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
          
          UNION ALL--SMT線
          SELECT WORK_DATE,   --前一個班次，白班
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
            FROM R_PQM_DAILY_SUM_SMT_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'DAY'
             AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
           GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE
         UNION ALL --夜班，前半夜
         SELECT WORK_DATE,
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
            FROM R_PQM_DAILY_SUM_SMT_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'NIGHT'
             AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
             AND SUBSTR(SECTION_RANGE,1,4)>'1200'
           GROUP BY WORK_DATE,LINE_NAME,  SECTION_RANGE
          UNION ALL --夜班,後半夜
         SELECT WORK_DATE,
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME 
            FROM R_PQM_DAILY_SUM_SMT_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND T.SHIFT = 'NIGHT'
             AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') 
                                   ELSE TO_CHAR(SYSDATE+1, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
             AND SUBSTR(SECTION_RANGE,1,4)<'1200'
           GROUP BY WORK_DATE,LINE_NAME, SECTION_RANGE)
   ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#getLineAchievedChartNode_CR_Night


#getLineAchievedChartNode_Manual
 --------------------------------------------
SELECT linearchive.PROCESS_NAME,
       ROUND(NVL(capacity,0),4)*100 rate,
       to_char(BEGIN,'hh24mi') timeNode,
       NVL(ct.archiver_lowwarning,90) archiver_lowwarning,
       NVL(ct.archiver_lowlimit,85) archiver_lowlimit
FROM (SELECT LINE_NAME,
             PROCESS_NAME,
             capacity,
             TO_DATE(WORK_DATE || SUBSTR(SECTION_RANGE, 1, 4),'yyyymmddhh24mi') BEGIN,
             TO_DATE(WORK_DATE || CASE
                                   WHEN SUBSTR(SECTION_RANGE, -4, 4) >= 2400 THEN
                                    '2359'
                                   ELSE
                                    SUBSTR(SECTION_RANGE, -4, 4)
                                 END,
                     'yyyymmddhh24mi') END
        FROM R_PQM_DAILY_SUM_T
       WHERE LINE_NAME = [[lineName]]
         AND STATE >= 0 
       UNION --MAIN LINE ALL
         SELECT LINE_NAME,
               'ALL' PROCESS_NAME,
               AVG(capacity) capacity,
               TO_DATE(WORK_DATE || SUBSTR(SECTION_RANGE, 1, 4),'yyyymmddhh24mi') BEGIN,
               TO_DATE(WORK_DATE || CASE
                         WHEN SUBSTR(SECTION_RANGE, -4, 4) >= 2400 THEN
                          '2359'
                         ELSE
                          SUBSTR(SECTION_RANGE, -4, 4)
                       END,
                       'yyyymmddhh24mi') END
          FROM R_PQM_DAILY_SUM_T
         WHERE LINE_NAME =[[lineName]]
           AND STATE >= 0 
           GROUP BY LINE_NAME,WORK_DATE,SECTION_RANGE                   
      UNION
        SELECT LINE_NAME,
               PROCESS_NAME,
               capacity,
               TO_DATE(WORK_DATE || SUBSTR(SECTION_RANGE, 1, 4),
                       'yyyymmddhh24mi') BEGIN,
               TO_DATE(WORK_DATE || CASE
                         WHEN SUBSTR(SECTION_RANGE, -4, 4) >= 2400 THEN
                          '2359'
                         ELSE
                          SUBSTR(SECTION_RANGE, -4, 4)
                       END,
                       'yyyymmddhh24mi') END
          FROM R_PQM_DAILY_SUM_SMT_T T
         WHERE LINE_NAME =[[lineName]]
               AND STATE >= 0 
      UNION --SMT ALL
       SELECT LINE_NAME,
             'ALL' PROCESS_NAME,
             AVG(capacity) capacity,
             TO_DATE(WORK_DATE || SUBSTR(SECTION_RANGE, 1, 4),
                     'yyyymmddhh24mi') BEGIN,
             TO_DATE(WORK_DATE || CASE
                       WHEN SUBSTR(SECTION_RANGE, -4, 4) >= 2400 THEN
                        '2359'
                       ELSE
                        SUBSTR(SECTION_RANGE, -4, 4)
                     END,
                       'yyyymmddhh24mi') END
        FROM R_PQM_DAILY_SUM_SMT_T
       WHERE LINE_NAME = [[lineName]]
         AND STATE >= 0 
         GROUP BY LINE_NAME,WORK_DATE,SECTION_RANGE)linearchive     
     LEFT join c_line_ct_runr_passr_alert_t ct
     on ct.line_name=linearchive.line_name
  WHERE linearchive.begin>SYSDATE-1 AND linearchive.PROCESS_NAME =[[opCode]]
  ORDER by BEGIN
 --------------------------------------------
#getLineAchievedChartNode_Manual


#getLineAchievedChartNode_Manual7or30
 --------------------------------------------
SELECT NVL(LINEARCHIVE.RATE,0) RATE,
       TO_CHAR(LINEARCHIVE.TIMENODE, 'MM/DD') TIMENODE,
       NVL(CT.ARCHIVER_LOWWARNING, 90) ARCHIVER_LOWWARNING,
       NVL(CT.ARCHIVER_LOWLIMIT, 85) ARCHIVER_LOWLIMIT
  FROM (SELECT NVL(RATETABLE.RATE, 0) RATE,
               TIMETABLE.TIMENODE,
               [[lineName]] LINE_NAME
          FROM (SELECT TRUNC(SYSDATE - [[rangeDay]], 'DD') + LEVEL TIMENODE
                  FROM DUAL
                CONNECT BY LEVEL < [[rangeDay]] + 1) TIMETABLE
          LEFT JOIN (SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           ROUND(AVG(CAPACITY), 4) * 100 RATE,
                           LINE_NAME,
                           PROCESS_NAME
                      FROM R_PQM_SUMMARY_T T
                     WHERE LINE_NAME = [[lineName]]
                       AND WORK_DATE >=TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME, PROCESS_NAME
                    UNION
                    SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           ROUND(AVG(CAPACITY), 4) * 100 RATE,
                           LINE_NAME,
                           'ALL' PROCESS_NAME
                      FROM R_PQM_SUMMARY_T T
                     WHERE LINE_NAME = [[lineName]]
                       AND WORK_DATE >=TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME
                    UNION
                    SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           ROUND(AVG(CAPACITY), 4) * 100 RATE,
                           LINE_NAME,
                           PROCESS_NAME
                      FROM R_PQM_SUMMARY_SMT_T T
                     WHERE LINE_NAME = [[lineName]]
                       AND WORK_DATE >=TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME, PROCESS_NAME
                    UNION
                    SELECT TO_DATE(WORK_DATE, 'yyyymmdd') TIMENODE,
                           ROUND(AVG(CAPACITY), 4) * 100 RATE,
                           LINE_NAME,
                           'ALL' PROCESS_NAME
                      FROM R_PQM_SUMMARY_SMT_T T
                     WHERE LINE_NAME = [[lineName]]
                       AND WORK_DATE >=TO_CHAR(TRUNC(SYSDATE - [[rangeDay]]), 'YYYYMMDD')
                     GROUP BY WORK_DATE, LINE_NAME) RATETABLE
            ON RATETABLE.TIMENODE = TIMETABLE.TIMENODE AND RATETABLE.PROCESS_NAME=[[opCode]]
         ) LINEARCHIVE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T CT
    ON CT.LINE_NAME = LINEARCHIVE.LINE_NAME
  ORDER by TIMENODE
 --------------------------------------------
#getLineAchievedChartNode_Manual7or30


#getLineAchievedChartNodeDsm
 --------------------------------------------
select linearchive.rate,to_char(linearchive.timeNode,'MM/DD hh24:mi') timeNode,
NVL(ct.archiver_lowwarning,90) archiver_lowwarning,NVL(ct.archiver_lowlimit,85) archiver_lowlimit
 FROM(select nvl(rateTable.rate,0) rate, 
  timeTable.timeNode,'APPLE-N5' line_name from 
  (SELECT TRUNC(SYSDATE - [[RangeDay]], 'DD') + LEVEL TIMENODE
          FROM DUAL
        CONNECT BY LEVEL < [[RangeDay]]+1) timeTable
   left join
  (SELECT timeNode,ROUND(AVG(CAPACITY),4)*100 rate,LINE_NAME FROM (  
    SELECT TO_DATE(WORK_DATE,'yyyymmdd') timeNode,
           T.CAPACITY,LINE_NAME
      FROM R_PQM_DAILY_SUM_T T
     WHERE LINE_NAME = [[LineName]]
       AND WORK_DATE >= TO_CHAR(trunc(sysdate-[[RangeDay]]),'YYYYMMDD') )
       GROUP BY timeNode,LINE_NAME
    UNION 
    SELECT timeNode,ROUND(AVG(CAPACITY),4)*100 rate,LINE_NAME FROM (  
    SELECT TO_DATE(WORK_DATE,'yyyymmdd') timeNode,
           T.CAPACITY,LINE_NAME
      FROM R_PQM_DAILY_SUM_SMT_T T
     WHERE LINE_NAME = [[LineName]]
       AND WORK_DATE >= TO_CHAR(trunc(sysdate-[[RangeDay]],'YYYYMMDD')) )
       GROUP BY timeNode,LINE_NAME) rateTable
  on rateTable.timeNode=timeTable.timeNode
  order by timeTable.timeNode,rateTable.line_name) linearchive
  LEFT join c_line_ct_runr_passr_alert_t ct
  on ct.line_name=linearchive.line_name
 --------------------------------------------
#getLineAchievedChartNodeDsm


#getLineAchievedChartNodeSP
 --------------------------------------------
select linearchive.rate,to_char(linearchive.timeNode,'MM/DD hh24:mi') timeNode,
NVL(ct.archiver_lowwarning,90) archiver_lowwarning,NVL(ct.archiver_lowlimit,85) archiver_lowlimit
 FROM(select nvl(rateTable.rate,0) rate, 
  timeTable.timeNode,'APPLE-N5' line_name from 
  (select trunc(sysdate-1,'hh')+level/24+1/24 timeNode
     from dual
   connect by level < 25) timeTable
   left join
  (SELECT timeNode,ROUND(AVG(CAPACITY),4)*100 rate,LINE_NAME FROM (  
    SELECT TO_DATE(WORK_DATE||SUBSTR(SECTION_RANGE, 1, 4), 'yyyymmddhh24mi')+1/24 timeNode,
           T.CAPACITY,LINE_NAME
      FROM R_PQM_DAILY_SUM_T T
     WHERE LINE_NAME = [[LineName]]
       AND WORK_DATE >= TO_CHAR(SYSDATE-1,'YYYYMMDD'))
       GROUP BY timeNode,LINE_NAME
    UNION 
    SELECT timeNode,ROUND(AVG(CAPACITY),4)*100 rate,LINE_NAME FROM (  
    SELECT TO_DATE(WORK_DATE||SUBSTR(SECTION_RANGE, 1, 4), 'yyyymmddhh24mi')+1/24 timeNode,
           T.CAPACITY,LINE_NAME
      FROM R_PQM_DAILY_SUM_SMT_T T
     WHERE LINE_NAME = [[LineName]]
       AND WORK_DATE >= TO_CHAR(SYSDATE-1,'YYYYMMDD'))
       GROUP BY timeNode,LINE_NAME) rateTable
  on rateTable.timeNode=timeTable.timeNode
  order by timeTable.timeNode,rateTable.line_name) linearchive
  LEFT join c_line_ct_runr_passr_alert_t ct
  on ct.line_name=linearchive.line_name
 --------------------------------------------
#getLineAchievedChartNodeSP


#getLineAchievedMsg
 --------------------------------------------
select output, planQty, to_char(outPut * 100 / planQty, 'FM990.09') || '%' rate,
       outPut * 100 / planQty rateValue
  from (select nvl(sum(pub.pass_qty * pcs.pcs_qty), 0) output,
               24 * 60 * 60 / line.line_rate planQty,
               line.line_rate
          from r_equipment_pub_param_record_t pub
         inner join R_Equipment_Interface_BOM_t bom
            on pub.interface_item_id = bom.interface_item_id
           and bom.valid = '1'
           and pub.end_point > sysdate - 1
         right join c_Equipment_Basic_t basic
            on bom.equipment_id = basic.equipment_id
         inner join R_DEMO_PROD_LINE_T line
            on line.line_name = basic.line_name
           and line.out_group = basic.group_name
         inner join R_DEMO_EQUIPMENT_PCS_QTY_T pcs
            on pcs.equipment_id = basic.equipment_id
         where basic.line_name =[[lineName]]
         group by line.line_rate)


 --------------------------------------------
#getLineAchievedMsg


#getLineAlertAnalysis
 --------------------------------------------
select group_name as STATUS_DETAIL, cnt as NT
  from (select sta.equipment_id, sta.group_name, count(1) cnt 
          from c_station_config_t sta
         inner join r_exception_main_t ex
            on sta.equipment_id = ex.equipment_id
         where sta.line_name = [[line_name]]
         group by sta.equipment_id, sta.group_name, sta.station_idx
         order by sta.station_idx),
       (select count(1)
          from c_station_config_t sta
         inner join r_exception_main_t ex
            on sta.equipment_id = ex.equipment_id
         where sta.line_name = [[line_name]])

 --------------------------------------------
#getLineAlertAnalysis


#getLineAlertRatio
 --------------------------------------------
select cast (equipment_id as varchar(200)) id_0,
       line_name || '--' || group_name desc_0,
       cnt no_0,
	   ROUND(cnt * 100 / cnta,2) ratio_0
      -- cnt * 100 / cnta ratio_0
  from (select sta.line_name, sta.equipment_id, sta.group_name, count(1) cnt
          from c_station_config_t sta
         inner join r_exception_main_t ex
            on sta.equipment_id = ex.equipment_id
         where sta.line_name = [[line_name]]
        	and ex.occur_time > sysdate - to_number([[rangeDay]]) 
         group by sta.line_name, sta.equipment_id, sta.group_name, sta.station_idx
         order by sta.station_idx),
       (select count(1) cnta
          from c_station_config_t sta
         inner join r_exception_main_t ex
            on sta.equipment_id = ex.equipment_id
         where sta.line_name = [[line_name]]
       		and ex.occur_time > sysdate - to_number([[rangeDay]]) )
		order by no_0 desc
 --------------------------------------------
#getLineAlertRatio


#getLineAllStation
 --------------------------------------------
 select sum(pub.pass_qty) passQty,sum(pub.fail_qty+pub.pass_qty) outQty,rt.status,basic.station_name,idx.idx,
  bom.equipment_id
  from r_equipment_pub_param_record_t pub 
  inner join R_Equipment_Interface_BOM_t bom 
  on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
  inner join r_equip_pub_param_realtime_t rt
  on rt.interface_item_id=pub.interface_item_id
  inner join c_Equipment_Basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join R_DEMO_GROUP_IDX_T idx 
  on idx.group_name=basic.group_name
  where basic.line_name=[[lineName]] and end_point >= trunc(sysdate)+1/3
  group by rt.status,basic.station_name,idx.idx,bom.equipment_id
  order by idx.idx
 --------------------------------------------
#getLineAllStation


#getLineBalanceRate
 --------------------------------------------
SELECT NVL(DECODE(COUNT(0) * MAX(LINEPR.USERTIME),
                  0,
                  0,
                  SUM(LINEPR.USERTIME) * 100 /
                  (COUNT(0) * MAX(LINEPR.USERTIME))),
           0) RATEVALUE,
       TO_CHAR(NVL(DECODE(COUNT(0) * MAX(LINEPR.USERTIME),
                          0,
                          0,
                          SUM(LINEPR.USERTIME) * 100 /
                          (COUNT(0) * MAX(LINEPR.USERTIME))),
                   0),
               'FM990.00') || '%' RATE
  FROM (SELECT LINERATE.EQUIPMENT_ID,
       SUM(LINERATE.PASS_QTY + LINERATE.FAIL_QTY) QTY,
       (MAX(LINERATE.END_POINT) - MIN(LINERATE.END_POINT)) * 24 * 60 * 60 USERTIME
  FROM (SELECT SCHE.SFCS_MO,
               PUB.EQUIPMENT_ID,
               PUB.PASS_QTY,
               PUB.FAIL_QTY,
               PUB.BEGIN_POINT,
               PUB.END_POINT
          FROM C_EQUIPMENT_BASIC_T BASIC
         INNER JOIN C_STATION_CONFIG_T SC
            ON BASIC.EQUIPMENT_ID = SC.EQUIPMENT_ID
         INNER JOIN R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
            ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID
         INNER JOIN (SELECT *
                      FROM (SELECT SCH.*
                              FROM R_SCHEDULE_SFCS_T SCH
                             INNER JOIN R_SCHEDULE_SAP_T SAP
                                ON SCH.SCHL_NO = SAP.SCHL_NO
                             WHERE SCH.LINE_NAME = [[lineName]]
                               AND SCH.FLAG <> 2
                             ORDER BY TO_CHAR(SAP.PLN_STAT_DATE, 'yyyy/mm/dd') ||
                                      SAP.PLN_STAT_TIME)
                     WHERE ROWNUM < 2) SCHE
            ON SC.LINE_NAME = SCHE.LINE_NAME
           AND NVL(PUB.BEGIN_POINT, SYSDATE) >=
               NVL(SCHE.START_DATE, SYSDATE)) LINERATE
 GROUP BY LINERATE.EQUIPMENT_ID) LINEPR
 --------------------------------------------
#getLineBalanceRate


#getLineConfigInformation
 --------------------------------------------
SELECT CT_LOWWARNING||'%' CT_LOWWARNING,
       CT_LOWLIMIT||'%' CT_LOWLIMIT,
       RUNR_LOWWARNING||'%' RUNR_LOWWARNING,
       RUNR_LOWLIMIT||'%' RUNR_LOWLIMIT,
       YIELDR_LOWWARNING||'%' YIELDR_LOWWARNING,
       YIELDR_LOWLIMIT||'%' YIELDR_LOWLIMIT,
       ARCHIVER_LOWWARNING||'%' ARCHIVER_LOWWARNING,
       ARCHIVER_LOWLIMIT||'%' ARCHIVER_LOWLIMIT
  FROM C_LINE_CT_RUNR_PASSR_ALERT_T 
 WHERE PROD_AREA_ID = [[prodAreaID]] AND LINE_NAME=[[lineName]]
 --------------------------------------------
#getLineConfigInformation


#getLineCT
 --------------------------------------------
SELECT RUN.RUNR_LOWWARNING CT_LOWWARNING, RUN.RUNR_LOWLIMIT CT_LOWLIMIT, STC.STATION_NAME
  FROM C_LINE_CT_RUNR_PASSR_ALERT_T RUN
 INNER JOIN C_STATION_CONFIG_T STC
    ON RUN.LINE_NAME = STC.LINE_NAME
 WHERE RUN.LINE_NAME =[[Line_name]]
 ORDER BY STC.STATION_IDX
 --------------------------------------------
#getLineCT


#getLineEquipmentCycleTime
 --------------------------------------------
select BA.Equipment_Id INTERFACE_ITEM_ID,ba.line_balance CYCLETIME,
    CON.Group_Name STATION_NAME from R_Line_balance_T BA
      LEFT JOIN C_STATION_CONFIG_T CON
      ON BA.LINE_NAME=CON.LINE_NAME
      AND BA.EQUIPMENT_ID=CON.EQUIPMENT_ID
    WHERE BA.LINE_NAME=[[lineName]]
      and ba.line_balance>0
      ORDER BY CON.STATION_IDX ASC
 --------------------------------------------
#getLineEquipmentCycleTime

--PQM3.2 已拿掉此功能
#getLineEquipmentCycleTime_7or30Day
 --------------------------------------------
SELECT CYCLETIME, STATION_NAME
  FROM (SELECT DISTINCT ROUND(SUM(SCYT) / SUM(SQT), 2) CYCLETIME,
                        GI.GROUP_NAME STATION_NAME,
                        GI.Station_Idx
          FROM (SELECT SUM(PUB.CYCLE_TIME * (PUB.PASS_QTY + PUB.FAIL_QTY)) SCYT,
                       SUM(PUB.PASS_QTY + PUB.FAIL_QTY) SQT,
                       BOM.GROUP_NAME,
                       BASIC.EQUIPMENT_ID,
                       BOM.LINE_NAME
                  FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
                 INNER JOIN c_station_config_t BOM
                    ON PUB.Equipment_Id = BOM.Equipment_Id
                 INNER JOIN C_EQUIPMENT_BASIC_T BASIC
                    ON BASIC.EQUIPMENT_ID = BOM.EQUIPMENT_ID
                 WHERE bom.line_name =[[lineName]]
                   AND PUB.End_Point > TRUNC(SYSDATE) -[[rangeDay]]
                 GROUP BY BOM.GROUP_NAME,
                          BASIC.EQUIPMENT_ID,
                          BOM.LINE_NAME) BA
         INNER JOIN c_station_config_t GI
            ON BA.GROUP_NAME = GI.GROUP_NAME
           AND GI.Line_Name = BA.LINE_NAME
         GROUP BY GI.GROUP_NAME, GI.Station_Idx
         ORDER BY GI.Station_Idx)
 --------------------------------------------
#getLineEquipmentCycleTime_7or30Day


#getLineEquipRunningRate
 --------------------------------------------
SELECT CASE
         WHEN WORKTIME * 100 > NVL(ACTIVATION_MAX, 100) THEN
          (NVL(ACTIVATION_MAX, 100) - 1) + DBMS_RANDOM.VALUE
         ELSE
          WORKTIME * 100
       END RATE,
       DESCRIPTION STATION_NAME
  FROM (SELECT NVL(SUM(NVL(PUB.END_POINT, SYSDATE) - CASE
                         WHEN PUB.BEGIN_POINT <
                              TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') THEN
                          TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')
                         ELSE
                          PUB.BEGIN_POINT
                       END),
                   0) / (SYSDATE - TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')) WORKTIME,
               BASIC.DESCRIPTION,
               BASIC.EQUIPMENT_ID,
               STC.LINE_NAME,
               STC.STATION_IDX
          FROM R_EQUIPMENT_STATUS_RECORD_T PUB
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
           AND PUB.STATUS = 0
           AND (PUB.BEGIN_POINT >= TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') OR
               PUB.END_POINT IS NULL)
         INNER JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE STC.LINE_NAME =[[lineName]]
         GROUP BY BASIC.EQUIPMENT_ID,
                  STC.STATION_IDX,
                  BASIC.DESCRIPTION,
                  STC.LINE_NAME) EUQIP
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON EUQIP.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
        where PAL.DELETE_FLAG = '0'
 ORDER BY EUQIP.STATION_IDX
 --------------------------------------------
#getLineEquipRunningRate


#getLineEquipRunningRate_7or30Day
 --------------------------------------------
SELECT CASE
         WHEN WORKTIME * 100 > NVL(ACTIVATION_MAX, 100) THEN
          (NVL(ACTIVATION_MAX, 100) - 1) + DBMS_RANDOM.VALUE
         ELSE
          WORKTIME * 100
       END RATE,
       DESCRIPTION STATION_NAME
  FROM (SELECT NVL(SUM(NVL(PUB.END_POINT, SYSDATE) - CASE
                         WHEN PUB.BEGIN_POINT < SYSDATE - [[rangeDay]] THEN
                          SYSDATE - [[rangeDay]]
                         ELSE
                          PUB.BEGIN_POINT
                       END),
                   0) / [[rangeDay]] WORKTIME,
               BASIC.DESCRIPTION,
               BASIC.EQUIPMENT_ID,
               STC.LINE_NAME,
               STC.STATION_IDX
          FROM R_EQUIPMENT_STATUS_RECORD_T PUB
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
           AND PUB.STATUS = 0
           AND (PUB.BEGIN_POINT >= SYSDATE - [[rangeDay]] OR PUB.END_POINT IS NULL)
         INNER JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE STC.LINE_NAME = [[lineName]]
         GROUP BY BASIC.EQUIPMENT_ID,
                  STC.STATION_IDX,
                  BASIC.DESCRIPTION,
                  STC.LINE_NAME) EUQIP
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON EUQIP.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
        where PAL.DELETE_FLAG = '0'
 ORDER BY EUQIP.STATION_IDX
 --------------------------------------------
#getLineEquipRunningRate_7or30Day


#getLineEquipRunningRate_7or30DayBackup170920
 --------------------------------------------
select CASE 
         WHEN WORKTIME * 100 > 50 THEN 
          45+round(dbms_random.value,2) 
         ELSE 
          round(WORKTIME * 100,2) 
       END RATE, DESCRIPTION station_name
  from (select nvl(sum(nvl(pub.end_point, sysdate) - case
                         when pub.begin_point < sysdate - [[rangeDay]] then
                          sysdate -[[rangeDay]]
                         else
                          pub.begin_point
                       end),
                   0)/[[rangeDay]] workTime,
               basic.DESCRIPTION,
               basic.equipment_id
          from R_Equipment_Status_Record_t pub
          INNER JOIN C_EQUIPMENT_BASIC_T BASIC
          ON PUB.EQUIPMENT_ID=BASIC.EQUIPMENT_ID
          AND PUB.STATUS = 0
           AND (pub.begin_point >= sysdate - [[rangeDay]] or pub.end_point is null)
           INNER JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID            
         where STC.line_name = [[lineName]]
        GROUP BY BASIC.EQUIPMENT_ID, STC.STATION_IDX, BASIC.DESCRIPTION
         ORDER BY STC.STATION_IDX)
 --------------------------------------------
#getLineEquipRunningRate_7or30DayBackup170920


#getLineEquipRunningRateBackup170920
 --------------------------------------------
SELECT CASE
         WHEN WORKTIME * 100 > 50 THEN
          45+dbms_random.value
         ELSE
          WORKTIME * 100
       END RATE,
       DESCRIPTION STATION_NAME
  FROM (SELECT NVL(SUM(NVL(PUB.END_POINT, SYSDATE) - CASE
                         WHEN PUB.BEGIN_POINT < SYSDATE - 1 THEN
                          SYSDATE - 1
                         ELSE
                          PUB.BEGIN_POINT
                       END),
                   0) * 24 / 20 WORKTIME,
               BASIC.DESCRIPTION,
               BASIC.EQUIPMENT_ID
          FROM R_EQUIPMENT_STATUS_RECORD_T PUB
          INNER JOIN C_EQUIPMENT_BASIC_T BASIC
          ON PUB.EQUIPMENT_ID=BASIC.EQUIPMENT_ID
          AND PUB.STATUS = 0
           AND (PUB.BEGIN_POINT >= SYSDATE - 1 OR PUB.END_POINT IS NULL)
           INNER JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID            
         WHERE STC.LINE_NAME = [[lineName]]
         GROUP BY BASIC.EQUIPMENT_ID, STC.STATION_IDX, BASIC.DESCRIPTION
         ORDER BY STC.STATION_IDX)
 --------------------------------------------
#getLineEquipRunningRateBackup170920


#getLineKPIAchieveInfo
 --------------------------------------------
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME, --各製程段匯總的
                TRUNC(MIN(SUMM.SUM_REAL)) || '/' ||
                TRUNC(MIN(SUMM.SUM_REAL)/DECODE(AVG(CAPACITY),0,1,AVG(CAPACITY))) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前是否為後半夜，後半夜取前一天數據，其他取當天
            AND SUMM.LINE_NAME = [[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION --分製程段的
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前是否為後半夜，後半夜取前一天數據，其他取當天
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT =[[shift]])
  WHERE CAPACITY IS NOT NULL  AND PROCESS_NAME =[[opCode]]
  UNION
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME, --各製程段匯總的
                TRUNC(SUM(SUMM.SUM_REAL)) || '/' ||
                TRUNC(SUM(SUMM.SUM_REAL)/DECODE(AVG(CAPACITY),0,1,AVG(CAPACITY))) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前是否為後半夜，後半夜取前一天數據，其他取當天
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
)
  WHERE CAPACITY IS NOT NULL
 --------------------------------------------
#getLineKPIAchieveInfo


#getLineKPIAchieveInfo_Auto
 --------------------------------------------
SELECT RATE.QTY,
       RATE.CAPACITY,
       RATE.CAPACITY_S, /*LINE.ARCHIVER_LOWWARNING,*/
       CASE
         WHEN RATE.CAPACITY >= NVL(LINE.ARCHIVER_LOWWARNING, 90) THEN
          0
         WHEN RATE.CAPACITY >= NVL(LINE.ARCHIVER_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT LINE_NAME,
               NVL(REAL_QTY, 0) || '/' || NVL(PLAN_QTY, 0) QTY,
               ROUND(REAL_QTY / DECODE(PLAN_QTY, 0, 1, PLAN_QTY) * 100, 2) CAPACITY,
               TO_CHAR(ROUND(REAL_QTY / DECODE(PLAN_QTY, 0, 1, PLAN_QTY) * 100,
                             2),
                       'fm9999990.00') || '%' CAPACITY_S
          FROM R_PQM_RATE_T
         WHERE LINE_NAME = [[lineName]]
           AND FREQUENCY = 1) RATE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON RATE.LINE_NAME = LINE.LINE_NAME
 --------------------------------------------
#getLineKPIAchieveInfo_Auto


#getLineKPIAchieveInfo_Manual
 --------------------------------------------
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME,
                TRUNC(AVG(SUMM.SUM_REAL)) || '/' ||
                TRUNC(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME = [[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT =[[shift]]
         UNION
         SELECT 'ALL' PROCESS_NAME,
                ROUND(AVG(SUMM.SUM_REAL)) || '/' ||
                ROUND(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]])
  WHERE PROCESS_NAME =[[opCode]]
    AND CAPACITY IS NOT NULL
 --------------------------------------------
#getLineKPIAchieveInfo_Manual


#getLineKPIAchieveInfo_ManualByDayShift
 --------------------------------------------
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME,
                TRUNC(AVG(SUMM.SUM_REAL)) || '/' ||
                TRUNC(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME = [[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT =[[shift]]
         UNION
         SELECT 'ALL' PROCESS_NAME,
                ROUND(AVG(SUMM.SUM_REAL)) || '/' ||
                ROUND(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]])
  WHERE PROCESS_NAME =[[opCode]]
    AND CAPACITY IS NOT NULL
 --------------------------------------------
#getLineKPIAchieveInfo_ManualByDayShift


#getLineKPIAchieveInfo_ManualByNightShift
 --------------------------------------------
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME,
                TRUNC(AVG(SUMM.SUM_REAL)) || '/' ||
                TRUNC(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
            AND SUMM.LINE_NAME = [[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT =[[shift]]
         UNION
         SELECT 'ALL' PROCESS_NAME,
                ROUND(AVG(SUMM.SUM_REAL)) || '/' ||
                ROUND(AVG(SUMM.SUM_PLAN)) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
         UNION
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]])
  WHERE PROCESS_NAME =[[opCode]]
    AND CAPACITY IS NOT NULL
 --------------------------------------------
#getLineKPIAchieveInfo_ManualByNightShift


#getLineKPIYield_Manual
 --------------------------------------------
SELECT YIELDTABLE.YIELD,
       YIELDTABLE.YIELD_S,
       CASE
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 90) THEN
          0
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_T SUMM
         INNER JOIN (SELECT SHIFT
                      FROM C_LINE_ECHELON_T L
                     INNER JOIN C_ECHELON_SECTION_T E
                        ON E.ECHELON_NAME = L.ECHELON_NAME
                     WHERE E.VALID = 0
                       AND (E.SECTION_FROM <= (TO_CHAR(SYSDATE, 'hh24mi')) AND
                           (TO_CHAR(SYSDATE, 'hh24mi')) <= E.SECTION_TO)
                       AND L.LINE_NAME =[[lineName]]
                       AND ROWNUM = 1) SHIFT
            ON SUMM.SHIFT = SHIFT.SHIFT
         WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
           AND SUMM.LINE_NAME = [[lineName]]
        UNION
        SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_SMT_T SUMM
         INNER JOIN (SELECT SHIFT
                       FROM C_LINE_ECHELON_T L
                      INNER JOIN C_ECHELON_SECTION_T E
                         ON E.ECHELON_NAME = L.ECHELON_NAME
                      WHERE E.VALID = 0
                        AND (E.SECTION_FROM <= (TO_CHAR(SYSDATE, 'hh24mi')) AND
                            (TO_CHAR(SYSDATE, 'hh24mi')) <= E.SECTION_TO)
                        AND L.LINE_NAME = [[lineName]]
                        AND ROWNUM = 1) SHIFT
            ON SUMM.SHIFT = SHIFT.SHIFT
         WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
           AND SUMM.LINE_NAME =[[lineName]]
           ) YIELDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME= [[lineName]] 
    WHERE YIELDTABLE.YIELD IS NOT NULL
 --------------------------------------------
#getLineKPIYield_Manual


#getLineKPIYield_ManualByDay
 --------------------------------------------
SELECT YIELDTABLE.YIELD,
       YIELDTABLE.YIELD_S,
       CASE
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 90) THEN
          0
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_T SUMM         
         WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
           AND SUMM.LINE_NAME = [[lineName]]
           AND SUMM.SHIFT= [[shift]]	
        UNION
        SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_SMT_T SUMM        
         WHERE WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
           AND SUMM.LINE_NAME =[[lineName]]
           AND SUMM.SHIFT= [[shift]]
           ) YIELDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME= [[lineName]] 
    WHERE YIELDTABLE.YIELD IS NOT NULL
 --------------------------------------------
#getLineKPIYield_ManualByDay


#getLineKPIYield_ManualByNight
 --------------------------------------------
SELECT YIELDTABLE.YIELD,
       YIELDTABLE.YIELD_S,
       CASE
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 90) THEN
          0
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_T SUMM         
         WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
           AND SUMM.LINE_NAME = [[lineName]]
           AND SUMM.SHIFT= [[shift]]	
        UNION
        SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_SMT_T SUMM        
         WHERE WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
           AND SUMM.LINE_NAME =[[lineName]]
           AND SUMM.SHIFT= [[shift]]
           ) YIELDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME= [[lineName]] 
    WHERE YIELDTABLE.YIELD IS NOT NULL
 --------------------------------------------
#getLineKPIYield_ManualByNight


#getLineList
 --------------------------------------------
select to_date('2016/09/23 16:20:25','yyyy/mm/dd hh24:mi:ss') dt from dual
 --------------------------------------------
#getLineList


#getLineListByProdAreaId
 --------------------------------------------
select line_name from C_PROD_AREA_LINE_T 
where prod_area_id=[[prod_area_id]]  and DELETE_FLAG = 0 order by man_sequence,line_name
 --------------------------------------------
#getLineListByProdAreaId


#getLineListByProdPlant
 --------------------------------------------
select prod.line_name 
  from C_PROD_AREA_LINE_T prod
 inner join c_line_desc_t line
    on prod.line_name=line.line_name
 where prod.prod_area_id=[[prod_plant]] 
   and (line.automation_flag='0' or line.automation_flag='1') and prod.delete_flag=0
 order by prod.line_name
 --------------------------------------------
#getLineListByProdPlant


#getLineMachineListIntegration
 --------------------------------------------
SELECT EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
        [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME,
		case when STATUS  >= 8 then 'equipmentNoDataPage' ELSE 'DashBoardDetail-PQM2.0' END IDD,
		([[ImgURL]]||IMAGE_NAME)	IMAGEURL,
		DifferNum IDD2
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                  -- NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                    'PEOPLE.jpg'
                 ELSE 
                  -- ET.IMAGE_NAME
                    ET.TYPE_CODE || '.jpg'
                 END IMAGE_NAME,
        round(to_number(NVL((sysdate-collect_date),0))* 24 )  DifferNum
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1 
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#getLineMachineListIntegration


#getLineMachineList_js
 --------------------------------------------
SELECT EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
       [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                   NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                 ELSE 
                   ET.IMAGE_NAME
                 END IMAGE_NAME    
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#getLineMachineList_js





#getLineMachineListByIndex
 --------------------------------------------
select equipment_id from(
select equipment_id,rownum rn from 
(select basic.equipment_id,idx.idx
from c_Equipment_Basic_t basic
left join R_Equipment_Interface_BOM_t bom 
on basic.equipment_id=bom.equipment_id and  bom.valid='1' 
inner join r_demo_group_idx_t idx
on idx.group_name=basic.group_name and idx.line=basic.line_name
where basic.line_name=[[lineName]]
order by idx.idx))where rn between [[startIDX]] and [[endIDX]]
 --------------------------------------------
#getLineMachineListByIndex


#getLineMachineListManual
 --------------------------------------------
SELECT DECODE(st.equipment_id,NULL,group_name,st.equipment_id) EQUIPMENT_ID,
       DECODE(st.equipment_id,NULL,group_name,st.equipment_id) EQUIPMENT_CODE, 
       99 STATUS,
       group_name STATION_NAME,
       GROUP_ORDER "ROWNUM",
       [[AREA]] AREA,
       [[lineName]]  LINE,
       [[ModelName]] ModelName,
       [[SchemaName]] SchemaName
       FROM R_LINE_ROUTE_T B LEFT join r_station_equipment_t st
 on st.station_name = B.group_name
 where LINE_NAME=[[lineName]]
 ORDER BY B.GROUP_ORDER
 --------------------------------------------
#getLineMachineListManual


#getLineMachineListManualBackup
 --------------------------------------------
SELECT DECODE(st.equipment_id,NULL,group_name,st.equipment_id) EQUIPMENT_ID,
       DECODE(st.equipment_id,NULL,group_name,st.equipment_id) EQUIPMENT_CODE, 
       99 STATUS,
       group_name STATION_NAME,
       step_sequence "ROWNUM",
       [[AREA]] AREA,
       [[lineName]]  LINE,
       [[ModelName]] ModelName,
       [[SchemaName]] SchemaName
       FROM(
SELECT rc.group_name,rc.step_sequence,rank() OVER(PARTITION BY group_name ORDER BY step_sequence) rnc FROM (
SELECT DISTINCT c1.route_code,
                c1.group_next group_name,
                c1.step_sequence,
                NVL(c2.route_desc, 0) route_desc
  FROM c_route_control_t c1
 left JOIN (SELECT distinct c3.route_code,
                    FIRST_VALUE(c3.step_sequence) over(PARTITION BY c3.route_code ORDER BY c3.step_sequence) AS first_seq
               FROM c_route_control_t c3
              WHERE c3.state_flag = 1) t ON t.route_code = c1.route_code
  LEFT JOIN c_route_control_t c2 ON c1.route_code = c2.route_code
                                AND c1.group_next = c2.group_name
                                and c2.step_sequence  < t.first_seq
 WHERE c1.route_desc = '0'
   AND c1.step_sequence < nvl(first_seq,c1.step_sequence+1)
 ORDER BY c1.step_sequence
) RC
 INNER JOIN (
              SELECT MO.ROUTE_CODE
               FROM R_MO_OVERALL_V MO
              INNER JOIN ( SELECT mo.mo_number,MO.model_name from r_mo_base_info_t mo    
                           WHERE mo.line=[[lineName]]  AND mo_flag=1
                            UNION
                            SELECT mo.mo_number,MO.model_name from R_MO_SMT_INFO_T mo    
                            WHERE mo.line=[[lineName]] AND mo_flag=1 ) A
                 ON MO.MO_NUMBER = A.MO_NUMBER
                AND MO.MODEL_NAME = A.MODEL_NAME
                AND ROWNUM = 1
                AND MO.ROUTE_CODE <> 0
                ) MO
    ON RC.ROUTE_CODE = MO.ROUTE_CODE
 ORDER BY RC.STEP_SEQUENCE
 ) B LEFT join r_station_equipment_t st
 on st.station_name = B.group_name
 WHERE rnc=1 ORDER BY step_sequence
 --------------------------------------------
#getLineMachineListManualBackup


#getLineMachineListv3
 --------------------------------------------
 SELECT GROUP_NAME, 
       EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
        [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME,
		case when STATUS  >= 8 then 'equipmentNoDataPage' ELSE 'DashBoardDetail-PQM2.0' END IDD,
		([[ImgURL]]||IMAGE_NAME)	IMAGEURL,
		DifferNum IDD2
  FROM (SELECT DISTINCT nvl(SC.GROUP_NAME,'') as GROUP_NAME,DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
 					DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                       'Manual Station',
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE, 
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                  -- NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                    'PEOPLE.jpg'
                 ELSE 
                  -- ET.IMAGE_NAME
                    ET.TYPE_CODE || '.jpg'
                 END IMAGE_NAME,
              -- round(to_number(NVL((sysdate-collect_date),0))* 24 )  DifferNum
                 FLOOR(to_number(NVL((sysdate-collect_date),0))* 24 )  DifferNum
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1 
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#getLineMachineListv3


#getLineMachineListv4
 --------------------------------------------
SELECT EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
        [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME,
		case when STATUS  >= 8 then 'equipmentNoDataPage' ELSE 'DashBoardDetail-PQM2.0' END IDD,
		([[ImgURL]]||IMAGE_NAME)	IMAGEURL,
	   DifferNum IDD2
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                    NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                 ELSE 
                   ET.IMAGE_NAME
                  --  ET.TYPE_CODE || '.jpg'
                 END IMAGE_NAME,
         round(to_number(NVL((sysdate-collect_date),0))* 24 )  DifferNum
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1 
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#getLineMachineListv4


#getLineOIRate
 --------------------------------------------
SELECT line_rate FROM r_demo_prod_line_t WHERE line_name=[[lineName]]
 --------------------------------------------
#getLineOIRate


#getLinePassRate
 --------------------------------------------
SELECT YIELDTABLE.YIELD,
       YIELDTABLE.YIELD_S,
       CASE
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 95) THEN 0
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 90) THEN
          1 ELSE  2
       END MAX_STATE
  FROM (SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_T SUMM         
         WHERE WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前是否為後半夜，後半夜取前一天數據，其他取當天
           AND SUMM.LINE_NAME =[[lineName]]
           AND SUMM.SHIFT= [[shift]]  
        UNION
        SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_SMT_T SUMM        
         WHERE WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前是否為後半夜，後半夜取前一天數據，其他取當天
           AND SUMM.LINE_NAME =[[lineName]]
           AND SUMM.SHIFT= [[shift]]
           ) YIELDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME=[[lineName]] 
    WHERE YIELDTABLE.YIELD IS NOT NULL
 --------------------------------------------
#getLinePassRate


#getLinePassRateBackup170915
 --------------------------------------------
SELECT YEILDTABLE.YIELD,
       YEILDTABLE.YIELD_S,       
       CASE
         WHEN YEILDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 90) THEN
          0
         WHEN YEILDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT YIELD, TO_CHAR(YIELD, 'FM990.00') || '%' YIELD_S
          FROM (SELECT NVL(EXP(SUM(LN(DECODE(RATE,
                                             0,
                                             0.00000001,
                                             NULL,
                                             1,
                                             RATE)))) * 100,
                           0) YIELD
                  FROM (SELECT STC.RATE, STC.GROUP_NAME
                          FROM R_PQM_YIELD_T STC
                         WHERE STC.LINE_NAME =[[lineName]]
                           AND STC.FLAG = 3))) YEILDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME = [[lineName]]
 --------------------------------------------
#getLinePassRateBackup170915


#getLinePassRateChartNode_7or30Day_CR
 --------------------------------------------
SELECT ALLLIST.RATE,TO_CHAR(ALLLIST.TIMENODE,'MM/DD') TIMENODE,
NVL(ct.YIELDR_LOWWARNING,90) YIELDR_LOWWARNING,NVL(ct.YIELDR_LOWLIMIT,85) YIELDR_LOWLIMIT
FROM (
SELECT EXP(SUM(LN(DECODE(RATE, 0, 0.0001,NULL,0.0001, RATE)))) * 100 RATE,
       (TIMETABLE.TIMENODE) AS TIMENODE,DECODE(RATETABLE.LINE_NAME,'',[[lineName]],RATETABLE.LINE_NAME) LINE_NAME
  FROM  (SELECT TRUNC(SYSDATE - [[rangeDay]], 'DD') + LEVEL TIMENODE
          FROM DUAL
        CONNECT BY LEVEL < [[rangeDay]]+1) TIMETABLE
  LEFT JOIN (SELECT NVL(SUM(PUB.PASS_QTY) /
                        DECODE(SUM(PUB.PASS_QTY + PUB.FAIL_QTY),
                               0,
                               1,
                               SUM(PUB.PASS_QTY + PUB.FAIL_QTY)),
                        1) RATE,
                    STC.GROUP_NAME,STC.LINE_NAME,
                    TRUNC(PUB.END_POINT, 'DD') TIMENODE
               FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
              INNER JOIN C_EQUIPMENT_BASIC_T BASIC
                 ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
              LEFT JOIN C_STATION_CONFIG_T STC 
                 ON STC.EQUIPMENT_ID= BASIC.EQUIPMENT_ID  
                AND STC.DEAL_FLAG=1  
              WHERE STC.LINE_NAME = [[lineName]] 
                AND PUB.END_POINT>SYSDATE-[[rangeDay]]
              GROUP BY STC.GROUP_NAME,STC.LINE_NAME, TRUNC(PUB.END_POINT, 'DD')) RATETABLE
    ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
 GROUP BY TIMETABLE.TIMENODE,RATETABLE.LINE_NAME) ALLLIST
 LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T CT
                 ON CT.LINE_NAME=ALLLIST.LINE_NAME
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#getLinePassRateChartNode_7or30Day_CR


#getLinePassRateChartNode_CR
 --------------------------------------------
SELECT ALLLIST.RATE,to_char(ALLLIST.TIMENODE,'hh24mi') TIMENODE,
NVL(ct.YIELDR_LOWWARNING,90) YIELDR_LOWWARNING,NVL(ct.YIELDR_LOWLIMIT,85) YIELDR_LOWLIMIT
      FROM( 
 SELECT EXP(SUM(LN(DECODE(RATE, 0, 0.0001,NULL,0.0001, RATE)))) * 100 RATE,
       (TIMETABLE.TIMENODE) AS TIMENODE,DECODE(RATETABLE.LINE_NAME,'',[[lineName]],RATETABLE.LINE_NAME) LINE_NAME
  FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 + 1 / 24 TIMENODE
          FROM DUAL
        CONNECT BY LEVEL < 25) TIMETABLE
  LEFT JOIN (SELECT PUB.RATE,
                    PUB.GROUP_NAME,
                    PUB.TIMENODE,
                    PUB.LINE_NAME
               FROM R_PQM_YIELD_T PUB
               where pub.line_name=[[lineName]]
                 and pub.flag=1) RATETABLE
    ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
 GROUP BY TIMETABLE.TIMENODE,RATETABLE.LINE_NAME) ALLLIST
 LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T CT
                 ON CT.LINE_NAME=ALLLIST.LINE_NAME
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#getLinePassRateChartNode_CR


#getLineRepeaterNum
 --------------------------------------------
select (level-1)*5+1 startIDX,level*5 endIDX,[[lineName]] lineName from dual connect by level<=
(select ceil(count(0)/5)
from c_Equipment_Basic_t basic
left join R_Equipment_Interface_BOM_t bom 
on basic.equipment_id=bom.equipment_id and  bom.valid='1' 
where basic.line_name=[[lineName]])
 --------------------------------------------
#getLineRepeaterNum


#getLineRunningRate_Shift
 --------------------------------------------
with EqpUti as (
select EQUIPMENT_ID,
case when TRUNC(round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2))=100 then 100 else round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2) end as uti from (
 select BASIC.EQUIPMENT_ID,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
                round(( case when  nvl(end_point,SYSDATE) >=  SYSDATE  then SYSDATE   else end_point end  - 
                           CASE WHEN PUB.BEGIN_POINT < TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') 
                                THEN   TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by BASIC.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by BASIC.EQUIPMENT_ID ) as cnt_by_eqp 
         FROM (select * from r_equip_status_t 
                 where EQUIPMENT_ID in (select EQUIPMENT_ID from C_STATION_CONFIG_T where LINE_NAME =[[lineName]])
                 AND (
					( 
					END_POINT >  TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') AND BEGIN_POINT <= SYSDATE
					) 
					OR
					END_POINT IS NULL
			        )  
                AND STATUS = 0 
                ) PUB RIGHT JOIN C_EQUIPMENT_BASIC_T BASIC        
		    ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID		
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by EQUIPMENT_ID
),
AvgLineEqpUti as (
 select B.LINE_NAME,ACTIVATION_MAX,TO_CHAR(avg(a.uti), 'fm990.09') || '%' as RATE,ROUND(avg(a.uti),4) as RATEVALUE
 from EqpUti a
 INNER JOIN (select * from C_STATION_CONFIG_T WHERE LINE_NAME = [[lineName]]) b
 on a.EQUIPMENT_ID=b.EQUIPMENT_ID
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON b.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
          where PAL.DELETE_FLAG = '0'
    group by B.LINE_NAME,ACTIVATION_MAX
)
Select a.*,CASE
         WHEN a.RATEVALUE >=
              NVL(LINE.RUNR_LOWWARNING, ACTIVATION_MAX - 5) THEN
          0
         WHEN a.RATEVALUE >=
              NVL(LINE.RUNR_LOWLIMIT, ACTIVATION_MAX - 10) THEN
          1
         ELSE
          2
       END MAX_STATE
from AvgLineEqpUti a left join (select * from C_LINE_CT_RUNR_PASSR_ALERT_T where LINE_NAME = [[lineName]]) line
on a.line_name=line.line_name
 --------------------------------------------
#getLineRunningRate_Shift


#getLineRunningRateByShift
 --------------------------------------------
 with EqpUti as (
select EQUIPMENT_ID,
case when TRUNC(round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2))=100 then 100 else round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2) end as uti from (
 select BASIC.EQUIPMENT_ID,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
                round(( case when  nvl(end_point,SYSDATE) >=  SYSDATE  then SYSDATE   else end_point end  - 
                           CASE WHEN PUB.BEGIN_POINT < TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') 
                                THEN   TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by BASIC.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by BASIC.EQUIPMENT_ID ) as cnt_by_eqp 
          FROM r_equip_status_t  PUB
         RIGHT JOIN  C_EQUIPMENT_BASIC_T   BASIC
            ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID
           AND PUB.STATUS = 0 
			AND (
				( 
				PUB.END_POINT >  TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') AND PUB.BEGIN_POINT <= SYSDATE
				) 
				OR
				PUB.END_POINT IS NULL
			)     
          -- AND (PUB.BEGIN_POINT >= to_date([[sectionFrom]],'YYYYMMDDHH24MISS') OR PUB.END_POINT IS NULL)
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by EQUIPMENT_ID
),
AvgLineEqpUti as (
 select B.LINE_NAME,ACTIVATION_MAX,TO_CHAR(avg(a.uti), 'fm990.09') || '%' as RATE,ROUND(avg(a.uti),4) as RATEVALUE
 from EqpUti a
 INNER JOIN (select * from C_STATION_CONFIG_T WHERE LINE_NAME = [[lineName]]) b
 on a.EQUIPMENT_ID=b.EQUIPMENT_ID
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON b.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
          where PAL.DELETE_FLAG = '0'
    group by B.LINE_NAME,ACTIVATION_MAX
)
Select a.*,CASE
         WHEN a.RATEVALUE >=
              NVL(LINE.RUNR_LOWWARNING, ACTIVATION_MAX - 5) THEN
          0
         WHEN a.RATEVALUE >=
              NVL(LINE.RUNR_LOWLIMIT, ACTIVATION_MAX - 10) THEN
          1
         ELSE
          2
       END MAX_STATE
from AvgLineEqpUti a left join (select * from C_LINE_CT_RUNR_PASSR_ALERT_T where LINE_NAME = [[lineName]]) line
on a.line_name=line.line_name
 --------------------------------------------
#getLineRunningRateByShift

#getLineRunningRate_Shift-old
 --------------------------------------------
SELECT ROUND(RUNNING.RATEVALUE,4) as RATEVALUE,
       RUNNING.RATE as RATE,
       CASE
         WHEN RUNNING.RATEVALUE >=
              NVL(LINE.RUNR_LOWWARNING, ACTIVATION_MAX - 5) THEN
          0
         WHEN RUNNING.RATEVALUE >=
              NVL(LINE.RUNR_LOWLIMIT, ACTIVATION_MAX - 10) THEN
          1
         ELSE
          2
       END MAX_STATE
  FROM (SELECT NVL(RATEVALUE, 0) RATEVALUE,
               TO_CHAR(NVL(RATEVALUE, 0), 'FM990.00') || '%' RATE,
               ACTIVATION_MAX
          FROM (SELECT AVG(CASE
                             WHEN WORKTIME > (NVL(ACTIVATION_MAX,100) / 100) THEN
                              ((NVL(ACTIVATION_MAX,100) - 1) / 100) + DBMS_RANDOM.VALUE / 100
                             ELSE
                              WORKTIME
                           END) * 100 RATEVALUE,
                       NVL(ACTIVATION_MAX,100) ACTIVATION_MAX
                  FROM (SELECT SUM(NVL(PUB.END_POINT, SYSDATE) - CASE
                                     WHEN PUB.BEGIN_POINT < to_date([[sectionFrom]],'YYYYMMDDHH24MISS') THEN
                                      to_date([[sectionFrom]],'YYYYMMDDHH24MISS')
                                     ELSE
                                      PUB.BEGIN_POINT
                                   END)/(SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS')) WORKTIME,
                               BASIC.DESCRIPTION,
                               BASIC.EQUIPMENT_ID,
                               STC.LINE_NAME
                          FROM C_EQUIPMENT_BASIC_T BASIC
                         INNER JOIN C_STATION_CONFIG_T STC
                            ON BASIC.EQUIPMENT_ID = STC.EQUIPMENT_ID
                         INNER JOIN R_EQUIPMENT_STATUS_RECORD_T PUB
                            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
                           AND PUB.STATUS = 0
                           AND (PUB.BEGIN_POINT >= to_date([[sectionFrom]],'YYYYMMDDHH24MISS') OR
                               PUB.END_POINT IS NULL)
                         WHERE STC.LINE_NAME = [[lineName]]
                         GROUP BY BASIC.EQUIPMENT_ID,
                                  STC.STATION_IDX,
                                  BASIC.DESCRIPTION,
                                  STC.LINE_NAME) EUQIP
                 INNER JOIN C_PROD_AREA_LINE_T PAL
                    ON EUQIP.LINE_NAME = PAL.LINE_NAME
                 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
                    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID 
                    
                    GROUP BY ACTIVATION_MAX)) RUNNING
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME = [[lineName]]
 --------------------------------------------
#getLineRunningRate_Shift-old

#getLineRunningRateBackup170920
 --------------------------------------------
SELECT RUNNING.rateValue,
       RUNNING.rate,
       CASE
         WHEN RUNNING.rateValue >= NVL(LINE.RUNR_LOWWARNING, 90) THEN
          0
         WHEN RUNNING.rateValue >= NVL(LINE.RUNR_LOWLIMIT, 85) THEN
          1
         ELSE
          2
       END MAX_STATE FROM(
select NVL(rateValue,0) rateValue, to_char(NVL(rateValue,0), 'FM990.00') || '%' rate
  from (select avg(CASE WHEN workTime>0.5 THEN 0.45+dbms_random.value/100 ELSE workTime END) * 100 rateValue
          from (select sum(nvl(pub.end_point, sysdate) - case
                             when pub.begin_point < sysdate - 1 then
                              sysdate - 1
                             else
                              pub.begin_point
                           end)*24/20 workTime,
                       basic.Description,
                       basic.equipment_id
                  FROM c_equipment_basic_t basic 
                  INNER JOIN R_EQUIPMENT_STATUS_RECORD_T PUB 
                  ON PUB.EQUIPMENT_ID=BASIC.EQUIPMENT_ID AND PUB.STATUS=0
                  AND (pub.begin_point >= sysdate - 1 OR pub.end_point is null)
                  INNER JOIN C_STATION_CONFIG_T STC ON BASIC.EQUIPMENT_ID=STC.EQUIPMENT_ID                  
                 where STC.line_name =[[lineName]]
                 group by basic.equipment_id, STC.STATION_IDX, basic.Description)))RUNNING
LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME= [[lineName]]
 --------------------------------------------
#getLineRunningRateBackup170920


#getLineSchedule
 --------------------------------------------
SELECT *
  FROM (SELECT B.SFCS_MO 工單,
               B.SFCS_MODEL 機種,
               A.VORNR OPCO,
               TO_CHAR(B.SCHL_QTY, 'FM999,999,999') 目標數,
               TO_CHAR(B.COLL_QTY, 'FM999,999,999') 投入數,
               TO_CHAR(B.OUTPUT_QTY, 'FM999,999,999') 產出數,
               ROUND(B.COLL_QTY / NULLIF(B.SCHL_QTY,0), 4) * 100 || '%' 進度,
               TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_STAT_TIME 計劃開始時間,
               TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_FINS_TIME 計劃結束時間,
               TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
               TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
               DECODE(B.FLAG,
                      '1',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '2',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際開始時間,
               DECODE(B.FLAG,
                      '2',
                      TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際結束時間,
               
               ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 60, 0) || 'm/' ||
               TO_CHAR(ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 3600, 1),
                       'FM999990.0') || 'h' "剩餘時間",
               A.OI_RATE,
               -- A.EXCH_TIME "換線時間(分鐘)",
               DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
          FROM R_SCHEDULE_SAP_T A
         INNER JOIN R_SCHEDULE_SFCS_T B
            ON A.SCHL_NO = B.SCHL_NO
         WHERE NVL(B.START_DATE,
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS')) BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
           AND B.FLAG = '1' -- 1，2要麼在生產，要麼生產完畢
           AND B.LINE_NAME = [[LineName]])

UNION ALL

SELECT *
  FROM (SELECT B.SFCS_MO 工單,
               B.SFCS_MODEL 機種,
               A.VORNR OPCO,
               TO_CHAR(B.SCHL_QTY, 'FM999,999,999') 目標數,
               TO_CHAR(B.COLL_QTY, 'FM999,999,999') 投入數,
               TO_CHAR(B.OUTPUT_QTY, 'FM999,999,999') 產出數,
               ROUND(B.COLL_QTY / NULLIF(B.SCHL_QTY,0), 4) * 100 || '%' 進度,
               TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_STAT_TIME 計劃開始時間,
               TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_FINS_TIME 計劃結束時間,
               TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
               TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
               DECODE(B.FLAG,
                      '1',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '2',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際開始時間,
               DECODE(B.FLAG,
                      '2',
                      TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際結束時間,
               
               ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 60, 0) || 'm/' ||
               TO_CHAR(ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 3600, 1),
                       'FM999990.0') || 'h' "剩餘時間",
               A.OI_RATE,
               -- A.EXCH_TIME "換線時間(分鐘)",
               DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
          FROM R_SCHEDULE_SAP_T A
         INNER JOIN R_SCHEDULE_SFCS_T B
            ON A.SCHL_NO = B.SCHL_NO
         WHERE NVL(B.START_DATE,
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS')) BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
           AND B.FLAG = '0' --未生产 要麼生產完畢
           AND B.LINE_NAME =[[LineName]])
 WHERE ROWNUM = 1

UNION ALL

SELECT *
  FROM (SELECT B.SFCS_MO 工單,
               B.SFCS_MODEL 機種,
               A.VORNR OPCO,
               TO_CHAR(B.SCHL_QTY, 'FM999,999,999') 目標數,
               TO_CHAR(B.COLL_QTY, 'FM999,999,999') 投入數,
               TO_CHAR(B.OUTPUT_QTY, 'FM999,999,999') 產出數,
               ROUND(B.COLL_QTY / NULLIF(B.SCHL_QTY,0), 4) * 100 || '%' 進度,
               TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_STAT_TIME 計劃開始時間,
               TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' ||
               A.PLN_FINS_TIME 計劃結束時間,
               TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
               TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
               DECODE(B.FLAG,
                      '1',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '2',
                      TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際開始時間,
               DECODE(B.FLAG,
                      '2',
                      TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
                      '') 實際結束時間,
               ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 60, 0) || 'm/' ||
               TO_CHAR(ROUND((B.SCHL_QTY - B.COLL_QTY) * A.OI_RATE / 3600, 1),
                       'FM999990.0') || 'h' "剩餘時間",
               A.OI_RATE,
               --  A.EXCH_TIME "換線時間(分鐘)",
               DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
          FROM R_SCHEDULE_SAP_T A
         INNER JOIN R_SCHEDULE_SFCS_T B
            ON A.SCHL_NO = B.SCHL_NO
         WHERE NVL(B.START_DATE,
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS')) BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
           AND B.FLAG IN ('3') --已生产
           AND B.LINE_NAME = [[LineName]]
         ORDER BY A.PLN_STAT_TIME)
 --------------------------------------------
#getLineSchedule


#getLineStatus
 --------------------------------------------
 select sum(pub.pass_qty) passQty,sum(pub.fail_qty+pub.pass_qty) outQty,rt.status,basic.station_name,idx.idx,
  bom.equipment_id
  from r_equipment_pub_param_record_t pub 
  inner join R_Equipment_Interface_BOM_t bom 
  on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
  inner join r_equip_pub_param_realtime_t rt
  on rt.interface_item_id=pub.interface_item_id
  inner join c_Equipment_Basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join R_DEMO_GROUP_IDX_T idx 
  on idx.group_name=basic.group_name
  where basic.line_name='S26' and end_point >= trunc(sysdate)+1/3
  group by rt.status,basic.station_name,idx.idx,bom.equipment_id
  order by idx.idx
 --------------------------------------------
#getLineStatus


#getLocaltimestamp
 --------------------------------------------
select localtimestamp,systimestamp ,sysdate from dual
 --------------------------------------------
#getLocaltimestamp


#getMachineListByLine
 --------------------------------------------
select basic.equipment_id,
       stc.group_name || '--' || basic.equipment_code equipName,
       basic.equipment_code,
       stc.station_idx
  from c_Equipment_Basic_t basic
  left join c_station_config_t stc
    on stc.equipment_id=basic.equipment_id
 where stc.line_name = [[lineName]]
 order by stc.station_idx
 --------------------------------------------
#getMachineListByLine


#getMachineProd
 --------------------------------------------
select output,planQty,to_char(outPut*100/planQty,'FM999.99') rate from (
	select sum(pub.pass_qty*pcs.pcs_qty) output,
	ceil((sysdate-trunc(sysdate)-1/3)*24*60*60/line.line_rate) planQty from r_equipment_pub_param_record_t pub
	inner join R_Equipment_Interface_BOM_t bom 
	on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
  inner join c_Equipment_Basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join R_DEMO_PROD_LINE_T line 
  on line.line_name=basic.line_name
  inner join  R_DEMO_EQUIPMENT_PCS_QTY_T pcs 
  on pcs.equipment_id=bom.equipment_id
  where basic.equipment_id=[[EquipID]] and end_point >= trunc(sysdate)+1/3
  group by line.line_rate)
 --------------------------------------------
#getMachineProd


#getMachineStatus
 --------------------------------------------
select nvl(rt.status,-1) status,basic.station_name,basic.equipment_id
from  c_Equipment_Basic_t basic 
left join R_Equipment_Interface_BOM_t bom 
on bom.equipment_id=basic.equipment_id and bom.valid='1' 
left join r_equip_pub_param_realtime_t rt
on rt.interface_item_id=bom.interface_item_id
where basic.equipment_id=[[equipID]]
 --------------------------------------------
#getMachineStatus


#getMaintainTime
 --------------------------------------------
 select part_module,inspect_time from R_DEMO_EQUIP_PART_INSPECT_T
  where equipment_id='CNDG2MPA14009' order by inspect_time
 --------------------------------------------
#getMaintainTime


#getManualLineKPIinfo
 --------------------------------------------
SELECT REAL_OUTPUT_QTY||'/'||PLAN_OUT_QTY qty FROM (
  SELECT NVL(ROUND(AVG(summ.sum_plan)),0) PLAN_OUT_QTY,
         NVL(ROUND(AVG(summ.sum_real)),0) REAL_OUTPUT_QTY
         FROM R_PQM_SUMMARY_T SUMM 
   INNER JOIN (
         SELECT SHIFT FROM C_LINE_ECHELON_T L
          INNER JOIN C_ECHELON_SECTION_T E ON E.ECHELON_NAME = L.ECHELON_NAME
          WHERE E.VALID = 0 AND (E.SECTION_FROM <= (TO_CHAR(SYSDATE, 'hh24mi')) AND
                 (TO_CHAR(SYSDATE, 'hh24mi')) <= E.SECTION_TO) AND ROWNUM = 1
                 AND L.LINE_NAME = [[lineName]] 
         )S ON SUMM.SHIFT=S.SHIFT
         WHERE SUMM.LINE_NAME=[[lineName]]  AND WORK_DATE= TO_CHAR(SYSDATE,'YYYYMMDD') 
  UNION   
  SELECT NVL(ROUND(AVG(summ.sum_plan)),0) PLAN_OUT_QTY,
         NVL(ROUND(AVG(summ.sum_real)),0) REAL_OUTPUT_QTY
    FROM R_PQM_SUMMARY_SMT_T SUMM
   INNER JOIN (
         SELECT SHIFT FROM C_LINE_ECHELON_T L
           INNER JOIN C_ECHELON_SECTION_T E ON E.ECHELON_NAME = L.ECHELON_NAME
           WHERE E.VALID = 0 AND (E.SECTION_FROM <= (TO_CHAR(SYSDATE, 'hh24mi')) AND
                 (TO_CHAR(SYSDATE, 'hh24mi')) <= E.SECTION_TO) AND ROWNUM = 1
                 AND L.LINE_NAME = [[lineName]] 
         )S ON SUMM.SHIFT=S.SHIFT
   WHERE SUMM.LINE_NAME = [[lineName]] 
     AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD'))
 --------------------------------------------
#getManualLineKPIinfo


#getModelTakeTime
 --------------------------------------------
SELECT line_rate FROM c_model_desc_t WHERE model_name=[[modelName]]
 --------------------------------------------
#getModelTakeTime


#getModuleLife
 --------------------------------------------
  Select part_module,part_name,part_times||unit,part_limit||unit,
  to_char((part_limit-part_times)/part_rate,'FM999.9')||'ぱ' nxt,warning_flag 
  from r_demo_equip_part_t
  where equipment_id='CNDG2MPA14033' order by (part_limit-part_times)/part_rate
 --------------------------------------------
#getModuleLife


#getMoMsgBySchedual
 --------------------------------------------
SELECT * FROM (
SELECT NVL(SAP.OI_RATE, 20) RATE,
       0 HRS_OUTPUT_QTY,
       0 MO_PASS_QTY
  FROM R_SCHEDULE_SFCS_T SFCS
 INNER JOIN r_schedule_sap_t SAP
    ON SFCS.SCHL_NO=SAP.SCHL_NO
 WHERE LINE_NAME = [[lineName]]
   AND SFCS.FLAG='1') WHERE ROWNUM=1
 --------------------------------------------
#getMoMsgBySchedual


#getMoStatus
 --------------------------------------------
SELECT FLAG,STATE FROM C_MO_STATUS_TYPE_T
 --------------------------------------------
#getMoStatus


#getMTBF
 --------------------------------------------
SELECT decode(MTBF.CNT, 0, 0, round(uptime.upTime / MTBF.cnt, 2))  MTBF
  FROM (SELECT nvl(SUM(status.end_point - status.begin_point) * 24 * 60, 0) upTime
          FROM c_Equipment_Basic_t basic
         INNER JOIN C_STATION_CONFIG_T bom
            ON bom.equipment_id = basic.equipment_id
         INNER JOIN r_equipment_status_record_t status
            ON status.equipment_id = basic.equipment_id
           AND status.end_point >= SYSDATE - 1
         WHERE basic.equipment_id =[[EQUIPMENT_ID]]
           AND status.status = 0) uptime,
       (SELECT COUNT(*) cnt
          FROM (SELECT MIN(begin_point) dstart, MAX(end_point) dend, status
                  FROM (SELECT status.begin_point,
                               status.end_point,
                               status.status,
                               status.end_point -
                               SUM(status.end_point - status.begin_point) over(PARTITION BY status.status ORDER BY status.begin_point) grp
                          FROM c_Equipment_Basic_t basic
                         INNER JOIN C_STATION_CONFIG_T bom
                            ON bom.equipment_id = basic.equipment_id                         
                         INNER JOIN r_equipment_status_record_t status
                            ON status.equipment_id =
                               bom.equipment_id
                           AND status.end_point >= SYSDATE - 1
                         WHERE basic.equipment_id =[[EQUIPMENT_ID]]
                           AND status.status = 0)
                 GROUP BY grp, status)) MTBF
 --------------------------------------------
#getMTBF


#getMTBSandMTBF
 --------------------------------------------
select nvl(sum(a1.tbs)/count(1),0) mtbs,
       nvl(sum(a1.tbs2)/count(1),0) mtbf
 from (
  select round(ceil((tbs.begin_point-tbs.last_end_point)*24*60*60)/60,2) TBS,
         round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2) TBS2
    from r_equip_tbs_t tbs
   inner join  c_equipment_error_code_t err
      on tbs.status_code=err.error_code
   inner join  c_equipment_basic_t bas
      on tbs.equipment_id=bas.equipment_id
     and err.equipment_type=bas.type_id
   where tbs.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and tbs.end_point is not null
     and tbs.end_point>sysdate-[[rangeDay]]
     and round(ceil((tbs.begin_point-tbs.last_end_point)*24*60*60)/60,2) between bas.tbs_lower and bas.tbs_upper
     and 0=[[type_m]]
   union
  select round(ceil((tbs.begin_point-tbs.last_type_end_point)*24*60*60)/60,2) TBS,
         round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2) TBS2
    from  r_equip_tbs_t tbs
   inner join  c_equipment_error_code_t err
      on tbs.status_code=err.error_code
     and err.error_type='m' 
   inner join  c_equipment_basic_t bas
      on tbs.equipment_id=bas.equipment_id
     and err.equipment_type=bas.type_id
   where tbs.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and tbs.end_point is not null
     and tbs.end_point>sysdate-[[rangeDay]]
     and round(ceil((tbs.begin_point-tbs.last_end_point)*24*60*60)/60,2) between bas.tbs_lower and bas.tbs_upper
     and 1=[[type_m]] )a1
 --------------------------------------------
#getMTBSandMTBF


#getOpcode
 --------------------------------------------
select distinct OPCODE as OP_CODE 
from C_PQM_PART_OP_T 
order by OP_CODE asc 
/*C_SCHEDULE_MODEL_COL_STATION_T*/
 --------------------------------------------
#getOpcode

 
 
#getopCodeByLineSchedule2
 --------------------------------------------
SELECT OPCODE, OPCODE_DESC
  FROM (SELECT NVL(PROCESS_NAME, 'ALL') OPCODE, PROCESS_NAME OPCODE_DESC
          FROM R_PQM_SUMMARY_T
         WHERE WORK_DATE > TO_CHAR(SYSDATE - 30, 'YYYYMMDD')
           AND LINE_NAME =[[lineName]]
        UNION
        SELECT 'ALL' OPCODE, '' OPCODE_DESC FROM DUAL)
 ORDER BY case when instr(OPCODE_DESC,'後段產出')>0  then -1 
               WHEN OPCODE='ALL' THEN 2 
               else 1 end,OPCODE ASC
 --------------------------------------------
#getopCodeByLineSchedule2


#getopCodeByLineScheduleBackup170913
 --------------------------------------------
SELECT DISTINCT OPCODE,OPCODE_DESC
  FROM (SELECT CASE
                 WHEN LINE.AUTOMATION_FLAG = '1' THEN
                  'Automation'
                 ELSE
                  S.OPCODE
               END OPCODE,
               CASE
                 WHEN LINE.AUTOMATION_FLAG = '1' THEN
                  ''
                 ELSE
                  S.OPCODE_DESC
               END OPCODE_DESC
          FROM (SELECT SAP.LINE, SAP.VORNR OPCODE,SAP.VORNR OPCODE_DESC
                  FROM R_SCHEDULE_SAP_T SAP
                UNION
                SELECT [[lineName]] LINE, 'ALL' OPCODE,'' OPCODE_DESC FROM DUAL) S
         INNER JOIN C_LINE_DESC_T LINE
            ON S.LINE = LINE.LINE_NAME
         WHERE LINE.LINE_NAME =[[lineName]])
 ORDER BY OPCODE DESC
 --------------------------------------------
#getopCodeByLineScheduleBackup170913


#getOriginalChangeLineInfo
 --------------------------------------------
SELECT LINE,
       M.SFCS_MO,
       M.SFCS_MODEL,
       TO_CHAR(S_DATE, 'YYYY/MM/DD hh24:mi:ss') S_DATE,
       /*TO_CHAR(START_DATE, 'mm-dd hh24:mi') START_DATE,*/
       AA.VORNR CPCODE,
       TO_CHAR(M.SCHL_QTY, 'FM999,999,999') SCHL_QTY,
       to_char((CASE
                 WHEN ROUND((S_DATE - SYSDATE) * 24 * 60) < 0 THEN
                  0
                 ELSE
                  ROUND((S_DATE - SYSDATE) * 24 * 60)
               END),
               'FM999,999,999') || 'm/' ||
           (CASE
                 WHEN ROUND((S_DATE - SYSDATE) * 24 * 60) < 0 THEN
                  0
                 ELSE
                  ROUND((S_DATE - SYSDATE) * 24, 1)
               END) || 'h' LEFT_TIME,
       PA.PART
  FROM R_SCHEDULE_SAP_T AA
 INNER JOIN R_SCHEDULE_SFCS_T M
    ON AA.SCHL_NO = M.SCHL_NO
 INNER JOIN (SELECT NVL(B.START_DATE, TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYYMMDD') || ' ' ||
                               A.PLN_STAT_TIME,
                               'yyyymmdd hh24:mi:ss')) S_DATE,
                    PR.LINE_NAME,
                    PR.MO_NUMBER,
                    PR.MODEL_NAME,
                    A.VORNR OPCODE,
                    (LISTAGG(PR.PART_TYPE || ']' || PR.ALART_FLAG ||
                             DECODE(ALART_FLAG,
                                    1,
                                    TO_CHAR(CONFIRM_TIME, 'hh24:mi'),
                                    TO_CHAR(NVL(B.START_DATE, TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYYMMDD') || ' ' ||
                               A.PLN_STAT_TIME,
                               'yyyymmdd hh24:mi:ss')) - P.ALART_TIME / 1440, 'hh24:mi') 
                               ),
                             '}') WITHIN
                     GROUP(ORDER BY PR.MO_NUMBER, PR.PART_TYPE, A.VORNR)) PART
               FROM R_PQM_LINE_PREPARE_OP_T PR
              INNER JOIN C_PQM_PART_OP_T P
                 ON PR.PART_TYPE = P.PART_TYPE
                AND PR.OPCODE = P.OPCODE
              INNER JOIN R_SCHEDULE_SAP_T A
                 ON PR.LINE_NAME = A.LINE
                AND PR.OPCODE = A.VORNR
              INNER JOIN R_SCHEDULE_SFCS_T B
                 ON A.SCHL_NO = B.SCHL_NO
                AND PR.MO_NUMBER = B.SFCS_MO
                AND PR.MODEL_NAME = B.SFCS_MODEL
              INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) T
                 ON T.LINE_NAME = PR.LINE_NAME
              INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') D
                 ON T.PROD_AREA_ID = D.PROD_AREA_ID
              WHERE B.FLAG = 0
                AND d.factory = [[factory]]
               	AND D.PROD_AREA_ID=[[prod_area_id]] 
                AND A.LINE IN (<<lineStr>>) 
                AND PR.OPCODE = [[opcode]]
              GROUP BY PR.LINE_NAME,
                       PR.MO_NUMBER,
                       PR.MODEL_NAME,
                       A.VORNR,
                       NVL(B.START_DATE, TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYYMMDD') || ' ' ||
                               A.PLN_STAT_TIME,
                               'yyyymmdd hh24:mi:ss'))) PA
    ON AA.LINE = PA.LINE_NAME
   AND M.SFCS_MO = PA.MO_NUMBER
   AND M.SFCS_MODEL = PA.MODEL_NAME
   AND AA.VORNR = PA.OPCODE
 ORDER BY S_DATE, LINE, CPCODE, MO_NUMBER DESC
 --------------------------------------------
#getOriginalChangeLineInfo


#getOriginalDVRdata_automation_line
 --------------------------------------------
select A.TimeNode TIME_NODE,
       case sign(sign(A.plan_qty * 0.1 - A.qty))
         when 1 then
          0
         else
          A.Rate
       end as Rate,
       round(case sign(sign(A.plan_qty * 0.1 - A.qty))
         when 1 then
          0
         else
          A.Plan_Qty
       end) as Plan_Qty,
       A.Archiver_lowwarning,
       A.Archiver_lowlimit,
       case sign(sign(A.plan_qty * 0.1 - A.qty))
         when 1 then
          0 - A.QTY
         else
          0
       end + nvl(A.qty + (case sign(flag)
                   when 1 then
                    b.qty
                   when -1 then
                    0
                 end),
                 A.qty) REAL_QTY
  from (select rownum as rn,
               linearchive.rate,
               to_char(linearchive.timeNode, 'hh24mi') timeNode,
               qty,
               nvl(plan_qty, 0) plan_qty,
               NVL(ct.archiver_lowwarning, 90) archiver_lowwarning,
               NVL(ct.archiver_lowlimit, 85) archiver_lowlimit
          from (select nvl(qty / ((case
                             when timeTable.timeNode > sysdate then
                              (sysdate - trunc(sysdate, 'hh')) * 24 * 60 * 60
                             else
                              60 * 60
                           end) / rateTable.line_rate),
                           0) rate,
                       timeTable.timeNode,
                       [[line_name]] line_name,
                       nvl(qty / 100, 0) qty,
                       ((case
                         when timeTable.timeNode > sysdate then
                          (sysdate - trunc(sysdate, 'hh')) * 24 * 60 * 60
                         else
                          60 * 60
                       end) / rateTable.line_rate) plan_qty
                  from (select trunc(sysdate - 1, 'hh') + level / 24 + 1 / 24 timeNode
                          from dual
                        connect by level < 25) timeTable
                  left join (select trunc(end_point, 'hh') + 1 / 24 timeNode,
                                   sum(pub.pass_qty * nvl(pcs.pcb_qty, 1)) * 100 qty,
                                   linerate.line_rate,
                                   line.line_name
                              from r_equipment_pub_param_record_t pub
                             inner join c_Equipment_Basic_t basic
                                on pub.equipment_id = basic.equipment_id
                             inner join c_station_config_t conf
                                on conf.equipment_id = basic.equipment_id
                             inner join C_LINE_DESC_T line
                                on line.line_name = conf.line_name
                               and line.auto_out_group = conf.group_name
                              left join R_EQUIP_PCB_QTY_T pcs
                                on pcs.group_name = conf.group_name
                              left join (SELECT T.LINE_NAME,
                                               T.SFCS_MODEL,
                                               T.SFCS_MO,
                                               NVL(M.OI_RATE, 0) LINE_RATE
                                          FROM R_SCHEDULE_SFCS_T T
                                          LEFT JOIN R_SCHEDULE_SAP_T M
                                            ON T.SCHL_NO = M.SCHL_NO
                                         WHERE T.LINE_NAME = [[line_name]] 
                                           AND T.FLAG = '1'
                                         ORDER BY TO_CHAR(M.PLN_STAT_DATE,
                                                          'yyyy/mm/dd') ||
                                                  M.PLN_STAT_TIME) linerate
                                on linerate.LINE_NAME = line.line_name
                             where line.line_name = [[line_name]] 
                               and end_point >= trunc(sysdate - 1)
                             group by trunc(end_point, 'hh') + 1 / 24,
                                      linerate.line_rate,
                                      line.line_name) rateTable
                    on rateTable.timeNode = timeTable.timeNode
                 order by timeTable.timeNode, rateTable.line_name) linearchive
          left join c_line_ct_runr_passr_alert_t ct
            on ct.line_name = linearchive.line_name
         ORDER BY linearchive.TIMENODE) A
  left join (select rownum - 1 as rn,
                    linearchive.rate,
                    to_char(linearchive.timeNode, 'MM/DD hh24:mi') timeNode,
                    qty,
                    nvl(plan_qty, 0) * 0.1 - qty as flag,
                    NVL(ct.archiver_lowwarning, 90) archiver_lowwarning,
                    NVL(ct.archiver_lowlimit, 85) archiver_lowlimit
               from (select nvl(qty / ((case
                                  when timeTable.timeNode > sysdate then
                                   (sysdate - trunc(sysdate, 'hh')) * 24 * 60 * 60
                                  else
                                   60 * 60
                                end) / rateTable.line_rate),
                                0) rate,
                            timeTable.timeNode,
                            [[line_name]] line_name,
                            nvl(qty / 100, 0) qty,
                            ((case
                              when timeTable.timeNode > sysdate then
                               (sysdate - trunc(sysdate, 'hh')) * 24 * 60 * 60
                              else
                               60 * 60
                            end) / rateTable.line_rate) plan_qty
                       from (select trunc(sysdate - 1, 'hh') + level / 24 +
                                    1 / 24 timeNode
                               from dual
                             connect by level < 25) timeTable
                       left join (select trunc(end_point, 'hh') + 1 / 24 timeNode,
                                        sum(pub.pass_qty *
                                            nvl(pcs.pcb_qty, 1)) * 100 qty,
                                        linerate.line_rate,
                                        line.line_name
                                   from r_equipment_pub_param_record_t pub
                                  inner join c_Equipment_Basic_t basic
                                     on pub.equipment_id = basic.equipment_id
                                  inner join c_station_config_t conf
                                     on conf.equipment_id =
                                        basic.equipment_id
                                  inner join C_LINE_DESC_T line
                                     on line.line_name = conf.line_name
                                    and line.auto_out_group = conf.group_name
                                   left join R_EQUIP_PCB_QTY_T pcs
                                     on pcs.group_name = conf.group_name
                                   left join (SELECT T.LINE_NAME,
                                                    T.SFCS_MODEL,
                                                    T.SFCS_MO,
                                                    NVL(M.OI_RATE, 0) LINE_RATE
                                               FROM R_SCHEDULE_SFCS_T T
                                               LEFT JOIN R_SCHEDULE_SAP_T M
                                                 ON T.SCHL_NO = M.SCHL_NO
                                              WHERE T.LINE_NAME = [[line_name]] 
                                                AND T.FLAG = '1'
                                              ORDER BY TO_CHAR(M.PLN_STAT_DATE,
                                                               'yyyy/mm/dd') ||
                                                       M.PLN_STAT_TIME) linerate
                                     on linerate.LINE_NAME = line.line_name
                                  where line.line_name = [[line_name]]
                                    and end_point >= trunc(sysdate - 1)
                                  group by trunc(end_point, 'hh') + 1 / 24,
                                           linerate.line_rate,
                                           line.line_name) rateTable
                         on rateTable.timeNode = timeTable.timeNode
                      order by timeTable.timeNode, rateTable.line_name) linearchive
               left join c_line_ct_runr_passr_alert_t ct
                 on ct.line_name = linearchive.line_name
              ORDER BY linearchive.TIMENODE) B
    on A.rn = b.rn

 --------------------------------------------
#getOriginalDVRdata_automation_line


#getOriginalDVRdataByDayShift
 --------------------------------------------
select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 '1' odr
                 from R_PQM_DAILY_SUM_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
				 
				line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] and echelon_name=[[echelon_name]] and state>=0
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'2' odr 
                 from R_PQM_SUMMARY_T 
				where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/ 
				and shift=[[shift]] 
				and process_name in (<<processNameStr>>) 

union all 

select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 '3' odr
                 from R_PQM_DAILY_SUM_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
				
				line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] and echelon_name=[[echelon_name]] and state>=0 
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'4' odr 
                 from R_PQM_SUMMARY_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and 
				
				line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/ and shift=[[shift]] 
				and process_name in (<<processNameStr>>) 

                order by line_name,process_name,odr,section_range 
 --------------------------------------------
#getOriginalDVRdataByDayShift


#getOriginalDVRdataByNightShift1
 --------------------------------------------
select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				'1' odr
                 from r_pqm_daily_sum_t where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
and  
				 
				line_name in (<<lineStr>>)
				and section_range>'1200'
                 and shift=[[shift]] and echelon_name=[[echelon_name]] and state>=0 
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'2' odr
                 from r_pqm_summary_t where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and 
				
				line_name in (<<lineStr>>) and shift=[[shift]] 
				and process_name in (<<processNameStr>>)

union all

select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				'3' odr
                 from r_pqm_daily_sum_smt_t where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and
				
				line_name in (<<lineStr>>)
				and section_range>'1200'
                 and shift=[[shift]] and echelon_name=[[echelon_name]] and state>=0 
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'4' odr
                 from r_pqm_summary_smt_t where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and 
				
				line_name in (<<lineStr>>) and shift=[[shift]] 
				and process_name in (<<processNameStr>>) 

                order by line_name,process_name,odr,section_range 

 --------------------------------------------
#getOriginalDVRdataByNightShift1


#getOriginalDVRdataByNightShift2
 --------------------------------------------
select line_name,
       process_name,
       section_range,
       to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
       to_char(sum(real_qty),'FM999,999,999') real_qty,
       AVG(capacity) capacity,
       round(avg(safe_rate), 2) safe_rate,
       round(avg(alert_rate), 2) alert_rate,
       '1' odr
  from r_pqm_daily_sum_t
 where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') 
 and line_name in (<<lineStr>>)
 and section_range > '1200'
 and shift = [[shift]]
 and echelon_name = [[echelon_name]]
 and state >= 0 
 and process_name in (<<processNameStr>>) 
 group by line_name, process_name, section_range
union all
select line_name,
       process_name,
       section_range,
       to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
       to_char(sum(real_qty),'FM999,999,999') real_qty,
       AVG(capacity) capacity,
       round(avg(safe_rate), 2) safe_rate,
       round(avg(alert_rate), 2) alert_rate,
       '2' odr
  from r_pqm_daily_sum_t
 where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
 and line_name in (<<lineStr>>)
 and section_range < '1200'
 and shift = [[shift]]
 and echelon_name = [[echelon_name]]
 and state >= 0
 and process_name in (<<processNameStr>>) 
 group by line_name, process_name, section_range
union all
select line_name,
       process_name,
       'ALL' section_range,
        to_char(sum_plan,'FM999,999,999') plan_qty,
       	to_char(sum_real,'FM999,999,999') real_qty,
       capacity capacity,
       0 safe_rate,
       0 alert_rate,
       '3' odr
  from r_pqm_summary_t
 where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') and
 line_name in (<<lineStr>>)
 and shift = [[shift]] 
 and process_name in (<<processNameStr>>) 

union all

select line_name,
       process_name,
       section_range,
       to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
       to_char(sum(real_qty),'FM999,999,999') real_qty,
       AVG(capacity) capacity,
       round(avg(safe_rate), 2) safe_rate,
       round(avg(alert_rate), 2) alert_rate,
       '4' odr
  from r_pqm_daily_sum_smt_t
 where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') and
 line_name in (<<lineStr>>) 
 and section_range > '1200'
 and shift = [[shift]]
 and echelon_name = [[echelon_name]]
 and state >= 0 
 and process_name in (<<processNameStr>>) 
 group by line_name, process_name, section_range
union all
select line_name,
       process_name,
       section_range,
       to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
       to_char(sum(real_qty),'FM999,999,999') real_qty,
       AVG(capacity) capacity,
       round(avg(safe_rate), 2) safe_rate,
       round(avg(alert_rate), 2) alert_rate,
       '5' odr
  from r_pqm_daily_sum_smt_t
 where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
 and line_name in (<<lineStr>>)
 and section_range < '1200'
 and shift = [[shift]]
 and echelon_name = [[echelon_name]]
 and state >= 0 
 and process_name in (<<processNameStr>>) 
 group by line_name, process_name, section_range
union all
select line_name,
       process_name,
       'ALL' section_range,
       to_char(sum_plan,'FM999,999,999') plan_qty,
       	to_char(sum_real,'FM999,999,999') real_qty,
       capacity capacity,
       0 safe_rate,
       0 alert_rate,
       '6' odr
  from r_pqm_summary_smt_t
 where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') 
 and line_name in (<<lineStr>>)
 and shift = [[shift]] 
 and process_name in (<<processNameStr>>) 

 order by line_name, process_name, odr, section_range
 --------------------------------------------
#getOriginalDVRdataByNightShift2


#getOutGroup
 --------------------------------------------
--随意挑选一个产出站和一個梯次，用}隔開
SELECT P1.OUT_GROUP
  FROM R_PQM_DAILY_SUM_T P1
 INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) A1
    ON P1.LINE_NAME = A1.LINE_NAME
 INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') C1
    ON A1.PROD_AREA_ID = C1.PROD_AREA_ID
 WHERE C1.PROD_AREA_ID = [[prod_area_id]] 
   AND P1.WORK_DATE = TO_CHAR(SYSDATE,'YYYYMMDD')	--'20160219'
   AND ROWNUM = 1
 --------------------------------------------
#getOutGroup


#getPandQOverview_automation_line_achieveRate
 --------------------------------------------
select line_rate rate from R_PQM_RATE_T where line_name=[[line_name]] 
and frequency = 1 
 --------------------------------------------
#getPandQOverview_automation_line_achieveRate


#getPandQOverview_automation_line_throughRate
 --------------------------------------------
select YIELD/*, to_char(YIELD, 'FM990.00') || '%' YIELD_S*/ 
  from (select nvl(EXP(SUM(LN(DECODE(RATE, 0, 0.00000001, NULL, 1, RATE)))) * 100,
                   0) YIELD
          from (select stc.rate, stc.group_name
                  from R_PQM_YIELD_T stc
                 where stc.line_name = [[line_name]] 
                   and stc.flag = 3))
 --------------------------------------------
#getPandQOverview_automation_line_throughRate


#getPandQOverviewByDayShift
 --------------------------------------------
--PQ總覽，白班，可以使用的原始查詢數據
select distinct t10.prod_area_id,                                                
      t10.line_name,
       -- t11.max_state(這個參數需要生成)
       t11.capacity,
       t11.yield,
       t12.archi_safe_rate,
       t12.archi_alert_rate,
       t13.archiver_lowwarning,
       t13.archiver_lowlimit,
       t13.Yieldr_Lowwarning,
       t13.yieldr_lowlimit,
       t14.open_line,
       t15.import_line
  from ((select 
  prod_area_id,
  line_name
           from C_PROD_AREA_LINE_T
          where prod_area_id = [[prod_area_id]]
         	and delete_flag = '0' 
            and line_name in (<<lineStr>>)) t10
       
        left join
       
        (SELECT SUMM.LINE_NAME,
                -- MAX(MAX_STATE) MAX_STATE,(這個參數需要生成)
                ROUND(AVG(CAPACITY), 3) CAPACITY,
                MIN(YIELD) YIELD
           FROM R_PQM_SUMMARY_T SUMM
          WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.SHIFT = [[shift]] --參數傳入
            AND SUMM.LINE_NAME in (<<lineStr>>) --參數傳入
          GROUP BY SUMM.LINE_NAME
         
         UNION ALL
         
         SELECT SUMM.LINE_NAME,
                -- MAX(MAX_STATE) MAX_STATE,(這個參數需要生成)
                ROUND(AVG(CAPACITY), 3) CAPACITY,
                MIN(YIELD) YIELD
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.SHIFT = [[shift]] --參數傳入
            AND SUMM.LINE_NAME in (<<lineStr>>) --參數傳入
          GROUP BY SUMM.LINE_NAME) t11 on t10.line_name = t11.line_name
       
        left join
       
       --獲取上限和下限的平均值
        (select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_t
          where work_date = to_char(sysdate, 'yyyymmdd')
            and shift = [[shift]] --參數傳入
            and line_name in (<<lineStr>>) --參數傳入
         --and rownum = 1 
          group by line_name
         
         union all
         
         select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_smt_t
          where work_date = to_char(sysdate, 'yyyymmdd')
            and shift = [[shift]] --參數傳入
            and line_name in (<<lineStr>>) --參數傳入
         --and rownum = 1 
          group by line_name) t12
       
        on t10.LINE_NAME = t12.line_name
       
        left join
       
       --獲取上下限(直通率和達成率)
        (select line_name,
                archiver_lowwarning,
                archiver_lowlimit,
                Yieldr_Lowwarning,
                yieldr_lowlimit
           from c_line_ct_runr_passr_alert_t
          where prod_area_id = [[prod_area_id]] --參數傳入
            and line_name in (<<lineStr>>)) t13
       
        on t10.line_name = t13.line_name
       
        left join
       
       --辨別是否已經開線
        (select distinct line_name open_line
           from R_PQM_SUMMARY_T
          where line_name in (<<lineStr>>)
            and work_date = to_char(sysdate, 'yyyymmdd') --參數傳入
         
         union all
         
         select distinct line_name open_line
           from R_PQM_SUMMARY_SMT_T
          where work_date = to_char(sysdate, 'yyyymmdd')
            and line_name in (<<lineStr>>)) t14 --參數傳入 
       
        on t10.line_name = t14.open_line
       
        left join
       
       --辨別是否已經導入
        (select distinct line_name import_line
           from R_PQM_SUMMARY_T
          where line_name in (<<lineStr>>) --參數傳入
         
         union all
         
         select distinct line_name import_line
           from R_PQM_SUMMARY_SMT_T
          where line_name in (<<lineStr>>)) t15 --參數傳入 
       
        on t10.line_name = t15.import_line
       
       )

 --------------------------------------------
#getPandQOverviewByDayShift


#getPandQOverviewByNightShift
 --------------------------------------------
--PQ總覽，夜班，可以使用的原始查詢數據
select distinct t10.prod_area_id,                                                
      t10.line_name,
       -- t11.max_state(這個參數需要生成)
       t11.capacity,
       t11.yield,
       t12.archi_safe_rate,
       t12.archi_alert_rate,
       t13.archiver_lowwarning,
       t13.archiver_lowlimit,
       t13.Yieldr_Lowwarning,
       t13.yieldr_lowlimit,
       t14.open_line,
       t15.import_line
  from ((select 
  prod_area_id,
  line_name
           from C_PROD_AREA_LINE_T 
          where prod_area_id = [[prod_area_id]]
         	and delete_flag = '0' 
            and line_name in (<<lineStr>>)) t10
       
        left join
       
        (SELECT SUMM.LINE_NAME,
                -- MAX(MAX_STATE) MAX_STATE,(這個參數需要生成)
                ROUND(AVG(CAPACITY), 3) CAPACITY,
                MIN(YIELD) YIELD
           FROM R_PQM_SUMMARY_T SUMM
          WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')	--減1
            AND SUMM.SHIFT = [[shift]] --參數傳入
            AND SUMM.LINE_NAME in (<<lineStr>>) --參數傳入
          GROUP BY SUMM.LINE_NAME
         
         UNION ALL
         
         SELECT SUMM.LINE_NAME,
                -- MAX(MAX_STATE) MAX_STATE,(這個參數需要生成)
                ROUND(AVG(CAPACITY), 3) CAPACITY,
                MIN(YIELD) YIELD
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD') --減1
            AND SUMM.SHIFT = [[shift]] --參數傳入
            AND SUMM.LINE_NAME in (<<lineStr>>) --參數傳入
          GROUP BY SUMM.LINE_NAME) t11 on t10.line_name = t11.line_name
       
        left join
       
       --獲取上限和下限的平均值
        (select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_t
          where work_date = to_char(sysdate, 'yyyymmdd')
            and shift = [[shift]] --參數傳入
            and line_name in (<<lineStr>>) --參數傳入
         --and rownum = 1 
          group by line_name
         
         union all
         
         select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_smt_t
          where work_date = to_char(sysdate, 'yyyymmdd')
            and shift = [[shift]] --參數傳入
            and line_name in (<<lineStr>>) --參數傳入
         --and rownum = 1 
          group by line_name) t12
       
        on t10.LINE_NAME = t12.line_name
       
        left join
       
       --獲取上下限(直通率和達成率)
        (select line_name,
                archiver_lowwarning,
                archiver_lowlimit,
                Yieldr_Lowwarning,
                yieldr_lowlimit
           from c_line_ct_runr_passr_alert_t
          where prod_area_id = [[prod_area_id]] --參數傳入
            and line_name in (<<lineStr>>)) t13
       
        on t10.line_name = t13.line_name
       
        left join
       
       --辨別是否已經開線
        (select distinct line_name open_line
           from R_PQM_SUMMARY_T
          where line_name in (<<lineStr>>) --參數傳入
         	and shift = [[shift]] --參數傳入
            and work_date = to_char(sysdate-1, 'yyyymmdd') --減1
         
         union all
         
         select distinct line_name open_line
           from R_PQM_SUMMARY_SMT_T
          where work_date = to_char(sysdate-1, 'yyyymmdd') --減1
         	and shift = [[shift]] --參數傳入
            and line_name in (<<lineStr>>)) t14 --參數傳入 
       
        on t10.line_name = t14.open_line
       
        left join
       
       --辨別是否已經導入
        (select distinct line_name import_line
           from R_PQM_SUMMARY_T
          where line_name in (<<lineStr>>) --參數傳入
         
         union all
         
         select distinct line_name import_line
           from R_PQM_SUMMARY_SMT_T
          where line_name in (<<lineStr>>)) t15 --參數傳入 
       
        on t10.line_name = t15.import_line
       
       )

 --------------------------------------------
#getPandQOverviewByNightShift


#getParamSeriesBy
 --------------------------------------------
  SELECT param.timenode logging_date, param.rate_value parameter_value, a.avg
    FROM R_DEMO_PARAMETER_VALUE_T param
    LEFT JOIN (SELECT AVG(param.rate_value) AVG
                 FROM R_DEMO_PARAMETER_VALUE_T param
                WHERE param.equipment_id = 'CNDG2P07002'
                  AND param.parameter_id = 'APX0013') a
      ON 1 = 1
   WHERE param.equipment_id = 'CNDG2P07002'
     AND param.parameter_id = 'APX0013'
   ORDER BY param.timenode
 --------------------------------------------
#getParamSeriesBy


#getParamTypeList
 --------------------------------------------
SELECT pt.param_code,
       pt.param_code || '--' || pt.param_desc para_label
  FROM c_equip_param_t pt 
 INNER JOIN r_equipment_param_rt_t pr
    ON pr.parameter_id = pt.parameter_type_id
 INNER JOIN c_equipment_basic_t bom
    ON pr.equipment_id = bom.equipment_id
 WHERE bom.equipment_id = [[EQUIPMENT_ID]]
 --------------------------------------------
#getParamTypeList


#getPartCondition
 --------------------------------------------
SELECT DISTINCT T.*
  FROM (SELECT CASE
                 WHEN (ROUND(PR.PARAM_VALUE / PT.UNIT_RATIO, 2) <
                      PT.PARAM_LSL) OR
                      (ROUND(PR.PARAM_VALUE / PT.UNIT_RATIO, 2) >
                      PT.PARAM_USL) THEN
                  PT.PARAM_DESC || ':' || '逾期保養'
                 ELSE
                  NVL2(PT.PARAM_DESC, PT.PARAM_DESC || ':' || '正常', NULL)
               END AS PART_NAME
          FROM R_EQUIPMENT_PARAM_RT_T PR
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON PR.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         INNER JOIN C_EQUIP_PARAM_T PT
            ON PR.PARAM_CODE = PT.PARAM_CODE
           AND PT.EQUIP_TYPE_ID = BASIC.TYPE_ID
         WHERE PR.EQUIPMENT_ID = [[EQUIPMENT_ID]]
           AND PT.PARAM_TYPE_ID = '1'
         ORDER BY CASE WHEN PT.PARAM_DESC IS NULL THEN 1 ELSE 0 END,PT.PARAM_CODE) T
 WHERE PART_NAME IS NOT NULL
 --------------------------------------------
#getPartCondition


#getPartConditionBackup170830
 --------------------------------------------
SELECT DISTINCT t.* FROM (
SELECT  CASE
         WHEN w.record_status = 0 OR w.record_status = 1 THEN
          w.sub_location || ':' || '維護期限 ' ||
          to_char(w.task_date, 'yyyy/mm/dd hh24:mi:ss')
         WHEN (round(pr.param_value / pt.unit_ratio, 2) < pt.PARAM_LSL) OR
              (round(pr.param_value / pt.unit_ratio, 2) > pt.PARAM_USL) THEN
          w.sub_location || ':' || '逾期保養'
         ELSE
          nvl2(w.sub_location, w.sub_location || ':' || '正常', NULL)
       END AS PART_NAME 
  FROM r_equipment_param_rt_t pr
 inner join c_equipment_basic_t basic
    on pr.equipment_id=basic.equipment_id
 INNER JOIN c_equip_param_t pt
    ON pr.param_code = pt.param_code
   and pt.equip_type_id=basic.type_id
 inner JOIN (SELECT b.lifetime_param,
                    b.sub_location,
                    it.task_date,
                    nt.record_status,
                    b.master_equip_id
               FROM R_EQUIPMENT_BOM_T b
               LEFT JOIN r_equip_inspect_task_t it
                 ON (it.sub_equip_type = b.sub_equip_type OR
                    it.sub_equip_type = '' OR b.sub_equip_type = '')
               LEFT JOIN r_equipment_notify_TASK_t nt
                 ON nt.task_id = it.task_id) w
    ON w.lifetime_param = pr.param_code
   and w.master_equip_id=pr.equipment_id
 WHERE pr.equipment_id =[[EQUIPMENT_ID]]
   AND pt.param_type_id = '1'
 ORDER BY CASE WHEN w.sub_location IS NULL THEN 1 ELSE 0 END, w.record_status, pt.param_code)t
 WHERE PART_NAME IS NOT NULL
 --------------------------------------------
#getPartConditionBackup170830


#getPartConditionRv1
 --------------------------------------------
SELECT pt.parameter_type_name || ':    ' || 
       pr.parameter_value || pt.param_unit || '/' ||
       pt.limit_value || pt.param_unit part_condition
  FROM r_equip_parameter_realtime_t pr
 INNER JOIN c_equipment_parameter_type_t pt
    ON pr.parameter_id = pt.parameter_type_id
 INNER JOIN r_equipment_interface_bom_t bom
    ON pr.interface_item_id = bom.interface_item_id
 WHERE bom.equipment_id = [[EQUIPMENT_ID]]
   AND pt.param_type = '1'
 --------------------------------------------
#getPartConditionRv1


#getPlanAndRealqty
 --------------------------------------------
SELECT NVL(REAL_QTY||'/'||PLAN_QTY,0||'/'||0) QTY FROM R_PQM_RATE_T 
WHERE LINE_NAME=[[LineName]] AND FREQUENCY=1
 --------------------------------------------
#getPlanAndRealqty


#getPlantSchemaList
 --------------------------------------------
SELECT DISTINCT SC.PLANT_CODE,SC.SCHEMA_NAME,SC.PLANT_DESC
  FROM C_EMP_DESC_T E
  LEFT JOIN SFCS.c_authority_local_role_main_t L
    ON E.EMP_PROPERTY = L.NAME
  LEFT JOIN SFCS.c_authority_local_role_org_t A
    ON L.ID = A.ID_LOCAL_ROLE
  LEFT JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') PA
    ON A.OBJECT_ITEM_VALUE = PA.PROD_AREA_ID
  LEFT JOIN SFCS.P_PQM_PLANT_SCHEMA_T SC
    ON PA.FACTORY = SC.PLANT_CODE
 WHERE EMP_NO = [[emp]]
   AND A.object_item_name = 'ObjI_Prod_Area'
   AND sc.plant_code IS NOT NULL
   ORDER by SC.PLANT_CODE
 --------------------------------------------
#getPlantSchemaList

#getPlantSchemaList-New
 --------------------------------------------
 --New version 20180618
SELECT DISTINCT SC.*
  FROM c_Emp_Desc_v E 
  LEFT JOIN c_authority_local_role_main_t L 
    ON E.EMP_PROPERTY = L.NAME 
  LEFT JOIN c_authority_local_role_org_t A 
    ON L.ID = A.ID_LOCAL_ROLE 
  LEFT JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') PA 
    ON A.OBJECT_ITEM_VALUE = PA.PROD_AREA_ID 
  LEFT JOIN P_PQM_PLANT_SCHEMA_T SC 
    ON PA.FACTORY = SC.PLANT_CODE 
 WHERE EMP_NO = [[empNo]] 
   AND A.object_item_name = 'ObjI_Prod_Area'
   AND sc.plant_code IS NOT NULL
   AND E.schema = [[inSchema]]
   ORDER BY SC.PLANT_CODE 
 --------------------------------------------
 #getPlantSchemaList-NEW
#getPQMDate
 --------------------------------------------
select sysdate - 200 as datefrom,sysdate as dateto from dual
 --------------------------------------------
#getPQMDate


#getPreviousDayDate
 --------------------------------------------
SELECT TO_CHAR(SYSDATE-1,'YYYYMMDDHH24MISS') SECTION_FROM from DUAL
 --------------------------------------------
#getPreviousDayDate


#getProcessName
 --------------------------------------------
select distinct t.process_name
  from r_pqm_daily_sum_t t
 INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) p
    ON t.line_name = t.line_name
 WHERE p.prod_area_id = [[prod_area_id]] 
   AND t.work_date = TO_CHAR(sysdate, 'yyyymmdd')
   AND t.echelon_name = [[echelon_name]] 
   AND t.process_name is not null
   AND t.process_name != 'NULL'
UNION
select distinct t.process_name
  from r_pqm_daily_sum_smt_t t
 INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) p
    ON t.line_name = t.line_name
 WHERE p.prod_area_id = [[prod_area_id]] 
   AND t.work_date = TO_CHAR(sysdate, 'yyyymmdd')
   AND t.echelon_name = [[echelon_name]] 
   AND t.process_name is not null
   AND t.process_name != 'NULL'
 order by process_name


/*select distinct process_name from c_model_process_group_t
 order by process_name
*/

 --------------------------------------------
#getProcessName


#getProdAreaAlertAnalysis
 --------------------------------------------
select line_name as STATUS_DETAIL, cnt as NT
  from (select al.line_name, al.line_name description, count(1) cnt
          from ( select * from c_prod_area_line_t where delete_flag='0' ) al
         inner join c_station_config_t sta 
         on al.line_name = sta.line_name 
         inner join r_exception_main_t ex 
         on sta.equipment_id = ex.equipment_id 
         where al.prod_area_id = 123
         group by al.line_name
         order by al.line_name),
       (select count(1) cnta
          from ( select * from c_prod_area_line_t where delete_flag='0' ) al
         inner join c_station_config_t sta 
         on al.line_name = sta.line_name 
         inner join r_exception_main_t ex 
          on sta.equipment_id = ex.equipment_id 
         where al.prod_area_id = 123)
 --------------------------------------------
#getProdAreaAlertAnalysis


#getProdAreaAlertRatio
 --------------------------------------------
select line_name id_0, 
	line_name desc_0,
	cnt no_0,
	ROUND(cnt * 100 / cnta,2) ratio_0  
  from (select al.line_name, al.line_name description, count(1) cnt
          from ( select * from c_prod_area_line_t where delete_flag='0' ) al
         inner join c_station_config_t sta 
         on al.line_name = sta.line_name 
         inner join r_exception_main_t ex 
         on sta.equipment_id = ex.equipment_id 
         where al.prod_area_id = [[prod_area_id]]
        	and ex.occur_time > sysdate - to_number([[rangeDay]]) 
         group by al.line_name
         order by al.line_name
       	),
       (select count(1) cnta
          from ( select * from c_prod_area_line_t where delete_flag='0' ) al
         inner join c_station_config_t sta 
         on al.line_name = sta.line_name 
         inner join r_exception_main_t ex 
          on sta.equipment_id = ex.equipment_id 
         where al.prod_area_id = [[prod_area_id]]
         and ex.occur_time > sysdate - to_number([[rangeDay]]) ) 
	order by no_0 desc
 --------------------------------------------
#getProdAreaAlertRatio


#getProdAreaListByFactory
 --------------------------------------------
select distinct 
       to_char(pa.prod_area_id) PROD_AREA_ID, 
	   pa.prod_area_code PROD_AREA_CODE,
       pa.prod_area_desc PROD_AREA 
from SFCS.C_PROD_AREA_T pa 
where pa.factory = [[factory]]
and pa.delete_flag='0'
order by PROD_AREA
 --------------------------------------------
#getProdAreaListByFactory


#getProdAreaListByFactory_new
 --------------------------------------------
SELECT DISTINCT to_char(pa.prod_area_id) PROD_AREA_ID,
                pa.prod_area_code PROD_AREA_CODE,
                pa.prod_area_desc PROD_AREA
  FROM C_EMP_DESC_T E
  LEFT JOIN SFCS.c_authority_local_role_main_t L
    ON E.EMP_PROPERTY = L.NAME
  LEFT JOIN SFCS.c_authority_local_role_org_t A
    ON L.ID = A.ID_LOCAL_ROLE
  LEFT JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') PA
    ON A.OBJECT_ITEM_VALUE = PA.PROD_AREA_ID
  LEFT JOIN SFCS.P_PQM_PLANT_SCHEMA_T SC
    ON PA.FACTORY = SC.PLANT_CODE
 WHERE EMP_NO = [[emp]] and pa.factory=[[factory]]
   AND A.object_item_name = 'ObjI_Prod_Area'
 --------------------------------------------
#getProdAreaListByFactory_new


#getProdPlant
 --------------------------------------------
select distinct 
to_char(pa.prod_area_id) prod_plant, 
pa.prod_area_desc area 
from (select * from sfcs.c_prod_area_t where  delete_flag='0') pa 
where pa.factory = [[empNo]]
order by area
 --------------------------------------------
#getProdPlant


#getProdPlantByFactory
 --------------------------------------------
SELECT DISTINCT TO_CHAR(PROD_AREA_ID) PRODID,PROD_AREA_DESC AREA FROM SFCS.C_PROD_AREA_T WHERE FACTORY = [[FACTORY]] and  delete_flag='0' ORDER BY PRODID
 --------------------------------------------
#getProdPlantByFactory


#getQty
 --------------------------------------------
select trunc(end_point,'hh')+1/24 timeNode,sum(pub.pass_qty*pcs.pcs_qty)*100/ceil(60*60/line.line_rate) rate , 100 as qty
  from r_equipment_pub_param_record_t pub
  inner join R_Equipment_Interface_BOM_t bom 
  on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
  inner join c_Equipment_Basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join R_DEMO_PROD_LINE_T line 
  on line.line_name=basic.line_name and line.out_group=basic.group_name 
  inner join  R_DEMO_EQUIPMENT_PCS_QTY_T pcs 
  on pcs.equipment_id=bom.equipment_id
  where basic.line_name='S26' and end_point >= trunc(sysdate-1)+1/3
group by trunc(end_point,'hh')+1/24,line.line_rate
order by 1
 --------------------------------------------
#getQty


#getQtyCopy
 --------------------------------------------
select trunc(end_point,'hh')+1/24 timeNode,sum(pub.pass_qty*pcs.pcs_qty)*100/ceil(60*60/line.line_rate) rate , 100 as qty
  from r_equipment_pub_param_record_t pub
  inner join R_Equipment_Interface_BOM_t bom 
  on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
  inner join c_Equipment_Basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join R_DEMO_PROD_LINE_T line 
  on line.line_name=basic.line_name and line.out_group=basic.group_name 
  inner join  R_DEMO_EQUIPMENT_PCS_QTY_T pcs 
  on pcs.equipment_id=bom.equipment_id
  where basic.line_name='P07' and end_point >= trunc(sysdate-1)+1/3
group by trunc(end_point,'hh')+1/24,line.line_rate
order by 1
 --------------------------------------------
#getQtyCopy


#getQualityChartList
 --------------------------------------------
SELECT TYPE_ID,TYPE_DESC FROM C_DSM_QUALITY_CHART_T ORDER BY 1
 --------------------------------------------
#getQualityChartList


#getQualityPassFailQty
 --------------------------------------------
SELECT TRIM(TO_CHAR(FAILQTY, '999G999G999G999')) || '/' ||
       TRIM(TO_CHAR(PASSQTY, '999G999G999G999')) QTY,
       trim(to_char((PASSQTY / DECODE((FAILQTY + PASSQTY),0,1,(FAILQTY + PASSQTY))) * 100,999.99))||'%' RATE
  FROM (SELECT NVL(SUM(RT.PASS_QTY * nvl(QTY.PCB_QTY, 1)), 0) PASSQTY,
               NVL(SUM(RT.FAIL_QTY * nvl(QTY.PCB_QTY, 1)), 0) FAILQTY,
               BASIC.EQUIPMENT_ID
          FROM C_EQUIPMENT_BASIC_T BASIC
         INNER JOIN R_EQUIPMENT_PUB_PARAM_RECORD_T RT
            ON RT.Equipment_Id = BASIC.EQUIPMENT_ID
           AND RT.END_POINT >= SYSDATE - 1
          LEFT JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
          LEFT JOIN R_EQUIP_PCB_QTY_T QTY
            ON QTY.GROUP_NAME = STC.GROUP_NAME
            AND QTY.MODEL_NAME = RT.MODEL_NAME
         WHERE BASIC.EQUIPMENT_ID = cast( [[EquipmentId]] as raw(16)) 
         GROUP BY BASIC.EQUIPMENT_ID)
 --------------------------------------------
#getQualityPassFailQty


#getQualityThrowMaterial
 --------------------------------------------
select failtable.failqty QTY,
       to_char(round(failtable.failqty/nvl(totaltable.totalqty,1)*100,2),'9999999990.99')||'%' PARAMETER_VALUE
  from (select equipment_id defectItem,
               count(1) failqty
          from r_equip_materials_msg_t
         where result<>'OK'
           and equipment_id=cast( [[equipmentID]] as raw(16)) 
           and insert_date>sysdate-1
           and material_no is not null
           and responsibility is null
         group by equipment_id) failtable
 inner join (select equipment_id defectItem,
                    count(1) totalqty
               from r_equip_materials_msg_t
              where equipment_id=cast( [[equipmentID]] as raw(16)) 
                and insert_date>sysdate-1
                and material_no is not null
                and responsibility is null
              group by equipment_id) totaltable
    on totaltable.defectItem=failtable.defectItem
 --------------------------------------------
#getQualityThrowMaterial


#getRateFor24Hr
 --------------------------------------------
select line_name,nvl(line_rate,0) line_rate,nvl(plan_qty,0) plan_qty,
         nvl(real_qty,0) real_qty from R_PQM_RATE_T where line_name=[[LineName]]
 --------------------------------------------
#getRateFor24Hr


#getRbline
 --------------------------------------------
select line_name from c_prod_area_line_t where DELETE_FLAG = '0' order by line_name
 --------------------------------------------
#getRbline


#getRunningInfo
 --------------------------------------------
SELECT fail.cnt error_count,
       ROUND(failtime.failTime, 2) error_time,
       out.outPut pass_qty,
       decode(MTBS.CNT, 0, 0, ROUND(failtime.failTime / MTBS.CNT, 2)) MTBS
  FROM (SELECT COUNT(1) cnt,
               nvl(SUM(status.end_point - status.begin_point) * 24 * 60, 0) failTime
          FROM c_Equipment_Basic_t basic
         INNER JOIN C_STATION_CONFIG_T bom
            ON bom.Equipment_Id = basic.Equipment_Id 
            AND BOM.LINE_NAME=[[LineName]]        
         INNER JOIN r_equipment_status_record_t status
            ON status.equipment_id = basic.equipment_id
           AND status.fail_flag = 1
           AND status.end_point >= SYSDATE - 1
         WHERE basic.equipment_ID =[[EQUIPMENT_ID]]) fail ,
       (SELECT nvl(SUM(status.end_point - status.begin_point) * 24 * 60, 0) failTime
          FROM c_Equipment_Basic_t basic
         INNER JOIN C_STATION_CONFIG_T bom
              ON bom.Equipment_Id = basic.Equipment_Id  
              AND BOM.LINE_NAME=[[LineName]] 
         INNER JOIN r_equipment_status_record_t status
            ON status.equipment_id = basic.equipment_id
           AND status.end_point >= SYSDATE - 1
         WHERE basic.equipment_id =[[EQUIPMENT_ID]]
           AND status.status = 1) failtime,
       (SELECT nvl(SUM(rt.pass_qty * nvl(pcs.pcb_qty, 1)), 0) outPut
          FROM c_Equipment_Basic_t basic
         INNER JOIN C_STATION_CONFIG_T bom
              ON bom.Equipment_Id = basic.Equipment_Id
              AND BOM.LINE_NAME=[[LineName]]             
         INNER JOIN r_equipment_pub_param_record_t rt
            ON rt.equipment_id = basic.equipment_id
           AND rt.end_point >= SYSDATE - 1
          LEFT JOIN r_equip_pcb_qty_t pcs
            ON pcs.group_name = bom.Group_Name
         WHERE basic.equipment_id =[[EQUIPMENT_ID]]) OUT,
       (SELECT COUNT(*) cnt
          FROM (SELECT MIN(begin_point) dstart, MAX(end_point) dend, status
                  FROM (SELECT status.begin_point,
                               status.end_point,
                               status.status,
                               status.end_point -
                               SUM(status.end_point - status.begin_point) over(PARTITION BY status.status ORDER BY status.begin_point) grp
                          FROM c_Equipment_Basic_t basic
                         INNER JOIN C_STATION_CONFIG_T bom
                              ON bom.Equipment_Id = basic.Equipment_Id 
                              AND BOM.LINE_NAME=[[LineName]]                            
                         INNER JOIN r_equipment_status_record_t status
                            ON status.equipment_id =
                               basic.equipment_id
                           AND status.end_point >= SYSDATE - 1
                         WHERE basic.equipment_id =[[EQUIPMENT_ID]]
                           AND status.status = 1)
                 GROUP BY grp, status)) MTBS
 --------------------------------------------
#getRunningInfo


#getRunningInfo_Artifical
 --------------------------------------------
SELECT 0 AS error_count,
       0 AS error_time,
     NVL(sum (st.pass_qty),0) AS pass_qty,
       0 AS MTBS
    from r_station_rec_t  st where 
     LINE_NAME =[[LineName]]
   AND GROUP_NAME =[[EQUIPMENT_ID]]
  AND INPUTDATE >sysdate-2
 --------------------------------------------
#getRunningInfo_Artifical


#getSchedule
 --------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT'  
AND 
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS') BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
ORDER BY 實際結束時間 DESC
 --------------------------------------------
#getSchedule


#getSchedule1
 --------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT'  
ORDER BY 實際結束時間 DESC
 --------------------------------------------
#getSchedule1


#getSchedule2
 --------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT' 
ORDER BY 計劃開始時間 


 --------------------------------------------
#getSchedule2


#getSchedule3
 --------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT' 
ORDER BY 計劃開始時間 
 --------------------------------------------
#getSchedule3


#getSchedule4
 --------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT' 
ORDER BY 計劃開始時間 
 --------------------------------------------
#getSchedule4


#getScheduleTest
 --------------------------------------------
SELECT B.LINE_NAME 線別,B.SFCS_MO 工單,B.SFCS_MODEL 機種,A.VORNR opcode,
B.COLL_STATION 採集站,B.SCHL_QTY 排程計劃數量,B.COLL_QTY 產出數量,ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度,
TO_CHAR(A.PLN_STAT_DATE,'YYYY/MM/DD')||' '||A.PLN_STAT_TIME 計劃開始時間,
TO_CHAR(A.PLN_FINS_DATE,'YYYY/MM/DD')||' '||A.PLN_FINS_TIME 計劃結束時間,
TO_CHAR(B.START_DATE,'YYYY/MM/DD HH24:MI:SS') 實際開始時間,TO_CHAR(B.CLOSE_DATE,'YYYY/MM/DD HH24:MI:SS') 實際結束時間,A.OI_RATE 線速,DECODE(B.FLAG,'0','未生產','1','生產中','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B
ON A.SCHL_NO = B.SCHL_NO
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE,'YYYY/MM/DD')||A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN (SYSDATE-40) AND SYSDATE
AND B.LINE_NAME IN ('P10')
AND B.FLAG = '0'
 --------------------------------------------
#getScheduleTest


#getSchema
 --------------------------------------------
select user from dual
 --------------------------------------------
#getSchema


#getSection_automation_line
 --------------------------------------------
select to_char(timeNode_in, 'HH24MI') TIME_NODE
  from (select trunc(sysdate - 1, 'hh') + level / 24 + 1 / 24 timeNode_in
          from dual
        connect by level < 25)
 order by timeNode_in
 --------------------------------------------
#getSection_automation_line


#getSectionByEchelonAndDayShift
 --------------------------------------------
select section_from||'-'||section_to section_range
from c_echelon_section_t 
where valid = '0' 
and echelon_name = [[echelon_name]]
and shift=[[shift]]
order by section_range asc
 --------------------------------------------
#getSectionByEchelonAndDayShift


#getSectionByEchelonAndNightShift
 --------------------------------------------
select section_from||'-'||section_to section_range, '1' odr
from c_echelon_section_t 
where valid = '0' 
and echelon_name = [[echelon_name]]
and shift=[[shift]]
and section_from>'1200'
union all
select section_from||'-'||section_to section_range, '2' odr
from c_echelon_section_t 
where valid = '0' 
and echelon_name = [[echelon_name]]
and shift=[[shift]]
and section_from<'1200'
order by odr asc,section_range asc

 --------------------------------------------
#getSectionByEchelonAndNightShift


#getShiftByEchelon
 --------------------------------------------
SELECT SHIFT
      FROM C_ECHELON_SECTION_T 
     WHERE VALID='0' 
       AND 
		(
          		SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') 
       			AND 
            	TO_CHAR(SYSDATE,'HH24MI') <= SECTION_TO
		)
       AND echelon_name = [[echelon_name]]
 --------------------------------------------
#getShiftByEchelon


#getShiftByEchelonButNoCurrentShift
 --------------------------------------------
SELECT SHIFT
  from (SELECT *
          FROM C_ECHELON_SECTION_T
         WHERE VALID = '0'
           AND TO_CHAR(SYSDATE,'HH24MI') >=SECTION_TO 
           AND echelon_name = [[echelon_name]]
         order by SECTION_TO desc)
 WHERE ROWNUM = 1
 --------------------------------------------
#getShiftByEchelonButNoCurrentShift


#getShiftByLineCurrentTime
 --------------------------------------------
SELECT SHIFT
  FROM C_LINE_ECHELON_T L
 INNER JOIN C_ECHELON_SECTION_T E
    ON E.ECHELON_NAME = L.ECHELON_NAME
 WHERE E.VALID = 0
   AND (E.SECTION_FROM <= (TO_CHAR(SYSDATE, 'hh24mi')) AND
       (TO_CHAR(SYSDATE, 'hh24mi')) <= E.SECTION_TO)
   AND L.LINE_NAME =[[lineName]]
   AND ROWNUM = 1
 --------------------------------------------
#getShiftByLineCurrentTime


#getShiftByLineCurrentTimeButNoCurrentShift
 --------------------------------------------
SELECT SHIFT
  FROM (SELECT *
          FROM C_LINE_ECHELON_T L
         INNER JOIN C_ECHELON_SECTION_T E
            ON E.ECHELON_NAME = L.ECHELON_NAME
         WHERE E.VALID = '0'
           AND TO_CHAR(SYSDATE, 'HH24MI') >= E.SECTION_TO
           AND L.LINE_NAME = [[lineName]]
         ORDER BY SECTION_TO DESC)
 WHERE ROWNUM = 1
 --------------------------------------------
#getShiftByLineCurrentTimeButNoCurrentShift


#getStationCycleTime
 --------------------------------------------
SELECT mo.rate, csc.group_name as station_name
  FROM (select *
          from (SELECT NVL(M.OI_RATE, 20) RATE, T.Line_Name
                FROM R_SCHEDULE_SFCS_T T
                LEFT JOIN R_SCHEDULE_SAP_T M
                 ON T.SCHL_NO = M.SCHL_NO
                 WHERE LINE_NAME = [[lineName]]
                   AND T.CLOSE_DATE IS NULL
                 ORDER BY T.SCHL_NO)
         WHERE ROWNUM = 1) mo
  inner join c_station_config_t csc
         on csc.line_name=mo.line_name   
  inner join c_equipment_basic_t STC
      on csc.equipment_id = STC.Equipment_Id
 order by csc.station_idx
 --------------------------------------------
#getStationCycleTime


#getStationEquipmentMsg
 --------------------------------------------
  select decode(rt.status,1,'故障',0,'正常','其他') satus,basic.equipment_id, count(str.fail_count) failCount
  from c_equipment_basic_t basic
  inner join r_equipment_interface_bom_t bom
  on bom.equipment_id=basic.equipment_id
  left join r_equip_pub_param_realtime_t rt
  on bom.interface_item_id=rt.interface_item_id
  left join r_equipment_status_record_t str
  on str.interface_item_id=rt.interface_item_id and str.begin_point>trunc(sysdate) and str.fail_count=1
  where basic.equipment_id=[[equipID]]
  group by rt.status,basic.equipment_id
 --------------------------------------------
#getStationEquipmentMsg


#getSysDate
 --------------------------------------------
select sysdate from dual
 --------------------------------------------
#getSysDate


#getSysdateHH24MI_infotable
 --------------------------------------------
select TO_CHAR(sysdate,'HH24MI') HHMM from dual
 --------------------------------------------
#getSysdateHH24MI_infotable


#getTestLine
 --------------------------------------------
select line_rate from R_DEMO_PROD_LINE_T where line_name=[[lineName]]
 --------------------------------------------
#getTestLine


#getToDateTest
 --------------------------------------------
select '2016/09/25 01:00:00' dateString,to_date('2016/09/25 01:00:00','yyyy/mm/dd hh24:mi:ss') dt,
sysdate,to_char(sysdate,'yyyy/mm/dd hh24:mi:ss') sysdateString from dual
 --------------------------------------------
#getToDateTest



#getUtilizationRate
 --------------------------------------------
with EqpUti as (
select EQUIPMENT_ID,
case when TRUNC(round(sum(UP_TIME)/1440*100,2))=100 then 100 else round(sum(UP_TIME)/1440*100,2) end as uti from (
 select BASIC.EQUIPMENT_ID,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
                    round(( case when  nvl(end_point,SYSDATE) >=  SYSDATE  then SYSDATE   else end_point end  - 
                           CASE WHEN PUB.BEGIN_POINT < (SYSDATE-1) 
                                THEN (SYSDATE-1) else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by BASIC.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by BASIC.EQUIPMENT_ID ) as cnt_by_eqp 
          FROM (
                     select EQUIPMENT_ID,BEGIN_POINT,END_POINT,STATUS 
		                   from r_equip_status_t 
                           where 1=1
                           and EQUIPMENT_ID =cast( [[EQUIPMENT_ID]] as raw(16))
                           and END_POINT > SYSDATE - 1  AND BEGIN_POINT <= SYSDATE
                          and STATUS = 0
                           union all
                           select EQUIPMENT_ID,BEGIN_POINT,END_POINT,STATUS 
                           from r_equip_status_t 
                           where 1=1
                           and EQUIPMENT_ID =cast( [[EQUIPMENT_ID]] as raw(16))
                           and END_POINT is null
                          and STATUS = 0
          
          ) PUB
         RIGHT JOIN (select * from C_EQUIPMENT_BASIC_T  
                              where EQUIPMENT_ID=cast( [[EQUIPMENT_ID]] as raw(16))
                             ) BASIC
                             on PUB.EQUIPMENT_ID=BASIC.EQUIPMENT_ID
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by EQUIPMENT_ID
) 
select a.EQUIPMENT_ID,TO_CHAR(a.uti, 'fm990.09') || '%' as RATE
from EqpUti a
 INNER JOIN (select * from C_STATION_CONFIG_T 
              where EQUIPMENT_ID=cast( [[EQUIPMENT_ID]] as raw(16))
              and line_name=[[lineName]]
             ) b
 on a.EQUIPMENT_ID=b.EQUIPMENT_ID
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON b.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
          where PAL.DELETE_FLAG = '0'
  
 --------------------------------------------
#getUtilizationRate

#getUtilizationRate-Old
 --------------------------------------------
SELECT   TO_CHAR(RATEVALUE, 'FM9999990.09') || '%' as RATE
     //CASE
     //    WHEN RATEVALUE > NVL(ACTIVATION_MAX, 100) THEN
     //     TO_CHAR((NVL(ACTIVATION_MAX, 100) - 1) + DBMS_RANDOM.VALUE,
     //             'FM9999990.09') || '%'
     //    ELSE
     //     TO_CHAR(RATEVALUE, 'FM9999990.09') || '%'
     //  END AS RATE
  FROM (SELECT NVL(SUM(NVL(PUB.END_POINT, SYSDATE) - CASE
                         WHEN PUB.BEGIN_POINT < SYSDATE - 1 THEN
                          SYSDATE - 1
                         ELSE
                          PUB.BEGIN_POINT
                       END),
                   0) * 24 / 20 * 100 RATEVALUE
          FROM R_EQUIPMENT_STATUS_RECORD_T PUB
         RIGHT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID
           AND PUB.STATUS = 0
           AND (PUB.BEGIN_POINT >= SYSDATE - 1 OR PUB.END_POINT IS NULL)
         WHERE BASIC.EQUIPMENT_ID = [[EQUIPMENT_ID]]) EQUIP
 INNER JOIN C_STATION_CONFIG_T STC
    ON STC.EQUIPMENT_ID = [[EQUIPMENT_ID]]
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON STC.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
 --------------------------------------------
#getUtilizationRate-Old


#idleChart
 --------------------------------------------
select alllist.begin_point,sum(alllist.delay_time) DELAY_TIME from (
  SELECT delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME begin_point,
         sum(delay.delay_time) delay_time
    FROM R_EQUIPMENT_DELAY_T DELAY
   inner join c_equipment_basic_t basic
      on delay.equipment_id=basic.equipment_id
   where DELAY.EQUIPMENT_ID=cast( [[equipmentID]] as raw(16)) 
     and delay.delay_res<>cast( [[equipmentID]] as raw(16)) 
     AND delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME > SYSDATE - [[rangeDay]] 
     AND DELAY.DELAY_TIME between basic.idle_lower and basic.idle_upper 
   group by delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME
   union
  SELECT delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME begin_point,
         sum(delay.delay_time) delay_time
    FROM R_EQUIPMENT_DELAY_T DELAY
   inner join c_equipment_basic_t basic
      on delay.equipment_id=basic.equipment_id
   where DELAY.EQUIPMENT_ID=cast( [[equipmentID]] as raw(16)) 
     and delay.delay_res=cast( [[equipmentID]] as raw(16)) 
     and delay.delay_type='p'
     AND delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME > SYSDATE - [[rangeDay]]
     AND DELAY.DELAY_TIME between basic.idle_lower and basic.idle_upper 
   group by delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME )alllist
 group by alllist.begin_point
 order by alllist.begin_point
 --------------------------------------------
#idleChart


#idleChart_7or30
 --------------------------------------------
SELECT TRUNC(delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME, 'DD') begin_point,
       sum(delay.delay_time) delay_time
  FROM R_EQUIPMENT_DELAY_T DELAY
 where DELAY.EQUIPMENT_ID=cast( [[equipmentID]] as raw(16)) 
   AND delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME > SYSDATE - [[rangeDay]]
 group by TRUNC(delay.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME, 'DD')
 --------------------------------------------
#idleChart_7or30


#IdleCountChart
 --------------------------------------------
select alllist.* from ( 
select 'EP'||basic.equipment_code||'-'||dl.delay_type error_code,
       dl.delay_desc,
       round(sum(dl.delay_time)/total_time.sum_delay,4) delay_time
  from r_equipment_delay_t dl
 inner join c_equipment_basic_t basic
    on dl.delay_res=basic.equipment_id
 inner join (select equipment_id,sum(delay_time) sum_delay from r_equipment_delay_t
              where equipment_id=cast( [[equipmentID]] as raw(16)) 
                and insert_date>sysdate-[[rangeDay]]
              group by equipment_id) total_time
    on dl.equipment_id=total_time.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res<>cast( [[equipmentID]] as raw(16)) 
   and dl.insert_date>sysdate-[[rangeDay]]
 group by 'EP'||basic.equipment_code,dl.delay_desc,total_time.sum_delay,dl.delay_type
 union
select 'EP'||basic.equipment_code||'-'||dl.delay_type error_code,
       dl.delay_desc,
       round(sum(dl.delay_time)/total_time.sum_delay,4) delay_time
  from r_equipment_delay_t dl
 inner join c_equipment_basic_t basic
    on dl.delay_res=basic.equipment_id
 inner join (select equipment_id,sum(delay_time) sum_delay from r_equipment_delay_t
              where equipment_id=cast( [[equipmentID]] as raw(16)) 
                and insert_date>sysdate-[[rangeDay]]
              group by equipment_id) total_time
    on dl.equipment_id=total_time.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_type='p'
   and dl.insert_date>sysdate-[[rangeDay]]
 group by 'EP'||basic.equipment_code,dl.delay_desc,total_time.sum_delay,dl.delay_type ) alllist
 where alllist.delay_desc<>'p'
   and alllist.delay_desc<>'q'
   and alllist.delay_desc<>'m'
 order by alllist.delay_desc
 --------------------------------------------
#IdleCountChart


#IdleRecords
 --------------------------------------------
select row_number() over (order by alllist.begin_point desc) as "ROWNUM",
      to_char( alllist.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,
     --  alllist.begin_point,
       alllist.delay_time,
       alllist.error_code,
       alllist.error_desc
  from ( select DELAY.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME BEGIN_POINT,
                DELAY.DELAY_TIME,
                'EP'||basic.equipment_code||'-'||delay.delay_type error_code,
                delay.delay_desc error_desc,
                delay.equipment_id
           from R_EQUIPMENT_DELAY_T DELAY
          inner join c_equipment_basic_t basic
             on delay.delay_res=basic.equipment_id
          inner join c_station_config_t stc
             on delay.equipment_id=stc.equipment_id
          inner join c_line_desc_t line
             on line.line_name=stc.line_name
          where delay.equipment_id=cast( [[equipmentID]] as raw(16)) 
            and delay.delay_res<>cast( [[equipmentID]] as raw(16)) 
            and DELAY.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME>sysdate-[[rangeDay]]
          union
         select DELAY.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME BEGIN_POINT,
                DELAY.DELAY_TIME,
                'EP'||basic.equipment_code||'-'||delay.delay_type error_code,
                delay.delay_desc error_desc,
                delay.equipment_id
           from R_EQUIPMENT_DELAY_T DELAY
          inner join c_equipment_basic_t basic
             on delay.delay_res=basic.equipment_id
          inner join c_station_config_t stc
             on delay.equipment_id=stc.equipment_id
          inner join c_line_desc_t line
             on line.line_name=stc.line_name
          where delay.equipment_id=cast( [[equipmentID]] as raw(16)) 
            and delay.delay_res=cast( [[equipmentID]] as raw(16)) 
            and delay.delay_type='p'
            and DELAY.INSERT_DATE-1/24/60/60*DELAY.ACTUAL_TIME>sysdate-[[rangeDay]]
          ) alllist
 inner join c_equipment_basic_t eb
    on eb.equipment_id=alllist.equipment_id
 where alllist.delay_time between eb.idle_lower and eb.idle_upper
 --------------------------------------------
#IdleRecords


#IdleTimeLabelChart
 --------------------------------------------
select alllist.delay_desc,
       alllist.delay_time
  from ( 
select dl.delay_desc,
       ROUND(sum(dl.delay_time)/60,2) delay_time
  from r_equipment_delay_t dl
 inner join c_equipment_basic_t basic
    on dl.delay_res=basic.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res<>cast( [[equipmentID]] as raw(16)) 
   and dl.insert_date>sysdate-1
 group by dl.delay_desc
 union
select dl.delay_desc,
       ROUND(sum(dl.delay_time)/60,2) delay_time
  from r_equipment_delay_t dl
 inner join c_equipment_basic_t basic
    on dl.delay_res=basic.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_type='p'
   and dl.insert_date>sysdate-1
 group by dl.delay_desc ) alllist
 order by alllist.delay_time
 --------------------------------------------
#IdleTimeLabelChart


#IdleTimePieChart
 --------------------------------------------
select '待機' delay_type,ROUND(sum(dl.delay_time)/60,2) sumtime
  from r_equipment_delay_t dl
 inner join  c_equipment_basic_t stc 
    on dl.equipment_id=stc.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res<>cast( [[equipmentID]] as raw(16))  
   and dl.insert_date>sysdate-1
   and dl.delay_time between stc.idle_lower and stc.idle_upper
 group by dl.equipment_id
 union
select '待料' delay_type,ROUND(sum(dl.delay_time)/60,2) sumtime
  from  r_equipment_delay_t dl
 inner join  c_equipment_basic_t stc 
    on dl.equipment_id=stc.equipment_id
 where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
   and dl.delay_res=cast( [[equipmentID]] as raw(16)) 
   and dl.insert_date>sysdate-1
   and dl.delay_type='p'
   and dl.delay_time between stc.idle_lower and stc.idle_upper
 group by dl.equipment_id
 --------------------------------------------
#IdleTimePieChart


#judgeDay
 --------------------------------------------
select [[rangeDay]] DAY from dual

 --------------------------------------------
#judgeDay


#judgeLineStyle
 --------------------------------------------
SELECT AUTOMATION_FLAG,DECODE(AUTOMATION_FLAG, 0, '人工線', 1, '自動化線', '其他') AUTOMATION_STR FROM (
SELECT TO_CHAR(NVL(SUM(T.AUTOMATION_FLAG), 0)) AUTOMATION_FLAG
  FROM C_LINE_DESC_T T
 WHERE T.LINE_NAME = [[lineName]])
 --------------------------------------------
#judgeLineStyle


#judgeProductNetwork
 --------------------------------------------
SELECT COUNT(1) CNT from sfcs.c_prd_network_segment_t t WHERE t.network_segment = SUBSTR([[ipAddress]],1,LENGTH(network_segment))
 --------------------------------------------
#judgeProductNetwork


#LinePassRateChartNode_7or30_CR
--------------------------------------------
--改成用R_PQM_LINE_SUM_T 重新計算每一個group的良率後再相乘
SELECT SUBSTR(WORK_DATE,5,2)||'-'||SUBSTR(WORK_DATE,7,2) TIMENODE,
       NVL(TRUNC(EXP(SUM(LN(DECODE(YIELD, 0, 0.00001, YIELD)))), 4),1)*100 as RATE,
       NVL(C.YIELDR_LOWWARNING, 95) YIELDR_LOWWARNING,
       NVL(C.YIELDR_LOWLIMIT, 90) YIELDR_LOWLIMIT 
  FROM (SELECT  T.line_name,case when night_flag='B' then to_char(to_date(work_date,'yyyymmdd')-1,'yyyyMMDD') else   work_date end work_date,
              T.GROUP_NAME,
               sum(PASS_QTY) as PASS_QTY,
               sum(FAIL_QTY) as FAIL_QTY,
               (CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
                  WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
                  ELSE ROUND(SUM(PASS_QTY) /
                         DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                                SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 6) END) as YIELD
          FROM R_PQM_LINE_SUM_T T
          LEFT JOIN (
                 select c.line_name,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end as group_name,max(c.station_idx) as  station_idx
                 from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,c_group_config_t e
                 where c.line_name=d.line_name
                 and c.group_name=e.group_name
                 and c.section_name=e.section_name
                 group by c.line_name,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end 
                ) SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME 
         WHERE T.LINE_NAME = [[lineName]]
           AND T.WORK_DATE >= TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD')
           AND NOT EXISTS  --去除前第N天的後半夜夜班，這部分統計在前一天
           (SELECT 0 FROM R_PQM_LINE_SUM_T A
         WHERE A.WORK_DATE = T.WORK_DATE
           AND A.LINE_NAME = T.LINE_NAME
           AND A.SHIFT = T.SHIFT 
           AND A.NIGHT_FLAG = A.NIGHT_FLAG
           AND A.SHIFT = 'NIGHT'
           AND A.NIGHT_FLAG = 'B'
           AND WORK_DATE = TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD'))
        group by   T.line_name,case when night_flag='B' then to_char(to_date(work_date,'yyyymmdd')-1,'yyyyMMDD') else   work_date end ,T.GROUP_NAME
       ) AA
   LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T C
     ON AA.LINE_NAME = C.LINE_NAME
     group by  SUBSTR(WORK_DATE,5,2)||'-'||SUBSTR(WORK_DATE,7,2),aa.line_name, NVL(C.YIELDR_LOWWARNING, 95), NVL(C.YIELDR_LOWLIMIT, 90)
     ORDER BY  SUBSTR(WORK_DATE,5,2)||'-'||SUBSTR(WORK_DATE,7,2)
--------------------------------------------
#LinePassRateChartNode_7or30_CR



#LinePassRateChartNode_CR_Day
 --------------------------------------------
SELECT TRUNC(EXP(SUM(LN(DECODE(AA.YIELD, 0, 0.00001, AA.YIELD)))), 4)*100 RATE,  --各站良率相乘
         END_TIME TIMENODE,
         NVL(C.YIELDR_LOWWARNING, 95) YIELDR_LOWWARNING,
         NVL(C.YIELDR_LOWLIMIT, 90) YIELDR_LOWLIMIT 
    FROM (SELECT WORK_DATE,
                 LINE_NAME,
                 GROUP_NAME,
                 YIELD, 
                 SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
            FROM R_PQM_LINE_GROUP_YIELD_T T
           WHERE LINE_NAME = [[lineName]]
             AND ( T.SHIFT = 'DAY' OR T.SHIFT = '日A')
             AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
         UNION ALL --前一个夜班，前半夜，日期為上一天
          SELECT WORK_DATE,
                 LINE_NAME,
                 GROUP_NAME,
                 YIELD, 
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
            FROM R_PQM_LINE_GROUP_YIELD_T T
           WHERE LINE_NAME = [[lineName]]
             AND T.SHIFT = 'NIGHT'
             AND WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
             AND SUBSTR(SECTION_RANGE,1,4)>'1200'
          UNION ALL --前一个夜班，后半夜
          SELECT WORK_DATE,
                 LINE_NAME,
                 GROUP_NAME,
                 YIELD, 
                 SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
            FROM R_PQM_LINE_GROUP_YIELD_T T
           WHERE LINE_NAME =[[lineName]]
             AND T.SHIFT = 'NIGHT'
             AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
             AND SUBSTR(SECTION_RANGE,1,4)<'1200') AA
   LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T C
     ON AA.LINE_NAME = C.LINE_NAME
   GROUP BY AA.WORK_DATE,AA.LINE_NAME, AA.END_TIME,C.YIELDR_LOWWARNING,C.YIELDR_LOWLIMIT
   ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#LinePassRateChartNode_CR_Day


#LinePassRateChartNode_CR_Night
 --------------------------------------------
SELECT TRUNC(EXP(SUM(LN(DECODE(AA.YIELD, 0, 0.00001, AA.YIELD)))), 4)*100 RATE,  --各站良率相乘
           END_TIME TIMENODE,         
      NVL(C.YIELDR_LOWWARNING, 95) YIELDR_LOWWARNING,
             NVL(C.YIELDR_LOWLIMIT, 90) YIELDR_LOWLIMIT 
     FROM (SELECT WORK_DATE,
                   LINE_NAME,
                   GROUP_NAME,
                   YIELD, 
                   SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
              FROM R_PQM_LINE_GROUP_YIELD_T T
             WHERE LINE_NAME = [[lineName]]
               AND ( T.SHIFT = 'DAY' OR T.SHIFT = '日A')
               AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                     ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
           UNION ALL --夜班，前半夜
           SELECT WORK_DATE,
                   LINE_NAME,
                   GROUP_NAME,
                   YIELD, 
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
              FROM R_PQM_LINE_GROUP_YIELD_T T
             WHERE LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                     ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
               AND SUBSTR(SECTION_RANGE,1,4)>'1200'
            UNION ALL --夜班，后半夜
           SELECT WORK_DATE,
                   LINE_NAME,
                   GROUP_NAME,
                   YIELD, 
                   SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END_TIME
              FROM R_PQM_LINE_GROUP_YIELD_T T
             WHERE LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE, 'YYYYMMDD')
                                     ELSE TO_CHAR(SYSDATE+1, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
               AND SUBSTR(SECTION_RANGE,1,4)<'1200') AA
     LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T C
       ON AA.LINE_NAME = C.LINE_NAME
     GROUP BY AA.WORK_DATE,AA.LINE_NAME, AA.END_TIME,C.YIELDR_LOWWARNING,C.YIELDR_LOWLIMIT
     ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#LinePassRateChartNode_CR_Night


#materialDefectLabelChart
 --------------------------------------------
select * from (
  select msg.result,
         uc.m_desc,
         count(msg.result) cnt
    from R_EQUIP_MATERIALS_MSG_T msg
    left join C_MATERIALS_USING_CODE_T uc
      on msg.result=uc.m_code
   where msg.result<>'OK'
     and msg.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and msg.insert_date>sysdate-[[rangeDay]]
     and msg.material_no=[[materialNO]]
   group by msg.result,uc.m_desc
   union
  select msg.result,
         msg.responsibility m_desc,
         count(msg.result) cnt
    from R_EQUIP_MATERIALS_MSG_T msg
   where msg.result<>'OK'
     and msg.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and msg.insert_date>sysdate-[[rangeDay]]
     and msg.responsibility=[[materialNO]]
   group by msg.result,msg.responsibility) a
 order by a.cnt desc
 --------------------------------------------
#materialDefectLabelChart


#materialFailRate
 --------------------------------------------
select alllist.defectItem material_no,
       to_char(round(alllist.failqty/nvl(alllist.totalqty,1)*100,2),'9999999990.99')||'%' failrate
  from (select failtable.defectItem, 
               totaltable.totalqty,
               failtable.failqty
          from (select material_no defectItem,
                       count(material_no) failqty
                  from r_equip_materials_msg_t
                 where result<>'OK'
                   and equipment_id=cast( [[equipmentID]] as raw(16)) 
                   and insert_date>sysdate-[[rangeDay]]
                   and material_no is not null
                   and responsibility is null
                 group by material_no) failtable
         inner join (select material_no defectItem,
                            count(material_no) totalqty
                       from r_equip_materials_msg_t
                      where equipment_id=cast( [[equipmentID]] as raw(16)) 
                        and insert_date>sysdate-[[rangeDay]]
                        and material_no is not null
                        and responsibility is null
                      group by material_no) totaltable
            on totaltable.defectItem=failtable.defectItem
         union 
        select failtable.defectItem, 
               totaltable.totalqty,
               failtable.failqty
          from (select responsibility defectItem,
                       count(responsibility) failqty
                  from r_equip_materials_msg_t
                 where result<>'OK'
                   and equipment_id=cast( [[equipmentID]] as raw(16)) 
                   and insert_date>sysdate-[[rangeDay]]
                   and responsibility is not null
                   and material_no is null
                 group by responsibility) failtable
         inner join (select responsibility defectItem,
                            count(responsibility) totalqty
                       from r_equip_materials_msg_t
                      where equipment_id=cast( [[equipmentID]] as raw(16)) 
                        and insert_date>sysdate-[[rangeDay]]
                        and responsibility is not null
                        and material_no is null
                      group by responsibility) totaltable
            on totaltable.defectItem=failtable.defectItem
         union
         select failtable.defectItem, 
               totaltable.totalqty,
               failtable.failqty
          from (select result defectItem,
                       count(result) failqty
                  from r_equip_materials_msg_t
                 where result<>'OK'
                   and equipment_id=cast( [[equipmentID]] as raw(16)) 
                   and insert_date>sysdate-[[rangeDay]]
                   and responsibility is null
                   and material_no is null
                 group by result) failtable
         , (select count(result) totalqty
                       from r_equip_materials_msg_t
                      where equipment_id=cast( [[equipmentID]] as raw(16)) 
                        and insert_date>sysdate-[[rangeDay]]
                        and responsibility is null
                        and material_no is null) totaltable) alllist
 --------------------------------------------
#materialFailRate


#materialFailRateChart
 --------------------------------------------
SELECT ALLLIST.FAILRATE rate,
       to_char(ALLLIST.TIMENODE, 'hh24:mi') TIMENODE,
       5 LIMITLINE
  FROM (SELECT NVL(RATETABLE.FAILRATE,0) FAILRATE,
               TIMETABLE.TIMENODE
          FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 + 1 / 24 TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < 25) TIMETABLE
          LEFT JOIN (SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select material_no,count(material_no) failqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                from r_equip_materials_msg_t
                               where result<>'OK'
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and material_no=[[materialNO]]
                                 and insert_date>sysdate-25/24
                               group by TRUNC(INSERT_DATE, 'HH'),material_no) failtable
                      inner join (select material_no,count(material_no) totalqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                    from r_equip_materials_msg_t
                                   where material_no=[[materialNO]]
                                     and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-25/24
                                   group by TRUNC(INSERT_DATE, 'HH'),material_no) totaltable
                         on totaltable.material_no=failtable.material_no
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select responsibility,count(responsibility) failqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                from r_equip_materials_msg_t
                               where result<>'OK'
                                 and responsibility=[[materialNO]]
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and insert_date>sysdate-25/24
                               group by TRUNC(INSERT_DATE, 'HH'),responsibility) failtable
                      inner join (select responsibility,count(responsibility) totalqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                    from r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-25/24
                                   group by TRUNC(INSERT_DATE, 'HH'),responsibility) totaltable
                         on totaltable.responsibility=failtable.responsibility
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select count(result) failqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                from r_equip_materials_msg_t
                               where result<>'OK'
                                 and result=[[materialNO]]
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and insert_date>sysdate-25/24
                               group by TRUNC(INSERT_DATE, 'HH')) failtable
                      inner join (select count(result) totalqty,TRUNC(INSERT_DATE, 'HH') + 1 / 24 TIMENODE
                                    from r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-25/24
                                   group by TRUNC(INSERT_DATE, 'HH')) totaltable
                         on totaltable.TIMENODE=failtable.TIMENODE) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.FAILRATE) ALLLIST
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#materialFailRateChart


#materialFailRateChart_7or30
 --------------------------------------------
SELECT ALLLIST.FAILRATE rate,
       to_char(ALLLIST.TIMENODE, 'MM/DD') TIMENODE,
       5 LIMITLINE
  FROM (SELECT NVL(RATETABLE.FAILRATE,0) FAILRATE,
               TIMETABLE.TIMENODE
          FROM (SELECT TRUNC(SYSDATE - [[rangeDay]], 'DD') + LEVEL TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < [[rangeDay]]+1) TIMETABLE
          LEFT JOIN (SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.TIMENODE
                       FROM (select material_no,count(material_no) failqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                               from r_equip_materials_msg_t
                              where result<>'OK'
                                and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                and material_no=[[materialNO]]
                                and insert_date>sysdate-[[rangeDay]]
                              group by TRUNC(INSERT_DATE, 'DD'),material_no) failtable
                      inner join (select material_no,count(material_no) totalqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                                    from r_equip_materials_msg_t
                                   where material_no=[[materialNO]]
                                     and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-[[rangeDay]]
                                   group by TRUNC(INSERT_DATE, 'DD'),material_no) totaltable
                         on totaltable.material_no=failtable.material_no
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.TIMENODE
                       FROM (select responsibility,count(responsibility) failqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                               from r_equip_materials_msg_t
                              where result<>'OK'
                                and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                and responsibility=[[materialNO]]
                                and insert_date>sysdate-[[rangeDay]]
                              group by TRUNC(INSERT_DATE, 'DD'),responsibility) failtable
                      inner join (select responsibility,count(responsibility) totalqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                                    from r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-[[rangeDay]]
                                   group by TRUNC(INSERT_DATE, 'DD'),responsibility) totaltable
                         on totaltable.responsibility=failtable.responsibility
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.TIMENODE
                       FROM (select count(result) failqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                               from r_equip_materials_msg_t
                              where result<>'OK'
                                and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                and result=[[materialNO]]
                                and insert_date>sysdate-[[rangeDay]]
                              group by TRUNC(INSERT_DATE, 'DD')) failtable
                      inner join (select count(result) totalqty,TRUNC(INSERT_DATE, 'DD') TIMENODE
                                    from r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>sysdate-[[rangeDay]]
                                   group by TRUNC(INSERT_DATE, 'DD')) totaltable
                         on totaltable.TIMENODE=failtable.TIMENODE) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.FAILRATE) ALLLIST
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#materialFailRateChart_7or30


#materialFailRatePostJSON
 --------------------------------------------
select * from (
select alllist.line_name,alllist.description,alllist.defectItem material_no,alllist.equipment_id,
       round(alllist.failqty/nvl(alllist.totalqty,1)*100,2) failrate
  from (select failtable.line_name,
               failtable.description,
               failtable.defectItem, 
               totaltable.totalqty,
               failtable.failqty,
               failtable.equipment_id
          from (select eq.line_name,
                       eq.equipment_id,
                       eq.description,
                       msg.material_no defectItem,
                       count(msg.material_no) failqty
                  from r_equip_materials_msg_t msg
                 inner join (select line.line_name,basic.equipment_id,basic.description
                               from c_line_desc_t line
                              inner join c_station_config_t stc
                                 on line.line_name=stc.line_name
                                and line.automation_flag='1' 
                              inner join c_equipment_basic_t basic
                                 on basic.equipment_id=stc.equipment_id
                              where automation_flag='1') eq
                    on msg.equipment_id=eq.equipment_id          
                 where result<>'OK'
                   and msg.material_no is not null
                   and msg.insert_date>sysdate-30
                 group by msg.material_no,eq.equipment_id,eq.line_name,eq.description
                 union
                 select eq.line_name,
                        eq.equipment_id,
                        eq.description,
                        msg.responsibility defectItem,
                        count(msg.responsibility) failqty
                  from r_equip_materials_msg_t msg
                 inner join (select line.line_name,basic.equipment_id,basic.description
                               from c_line_desc_t line
                              inner join c_station_config_t stc
                                 on line.line_name=stc.line_name
                                and line.automation_flag='1' 
                              inner join c_equipment_basic_t basic
                                 on basic.equipment_id=stc.equipment_id
                              where automation_flag='1') eq
                    on msg.equipment_id=eq.equipment_id          
                 where result<>'OK'
                   and msg.responsibility is not null
                   and msg.insert_date>sysdate-30
                 group by msg.responsibility,eq.equipment_id,eq.line_name,eq.description) failtable
         inner join (select eq.line_name,
                            eq.equipment_id,
                            eq.description,
                            msg.material_no defectItem,
                            count(msg.material_no) totalqty
                       from r_equip_materials_msg_t msg
                      inner join (select line.line_name,basic.equipment_id,basic.description
                                    from c_line_desc_t line
                                   inner join c_station_config_t stc
                                      on line.line_name=stc.line_name
                                     and line.automation_flag='1' 
                                   inner join c_equipment_basic_t basic 
                                      on basic.equipment_id=stc.equipment_id
                                   where automation_flag='1') eq
                         on msg.equipment_id=eq.equipment_id 
                      where msg.insert_date>sysdate-30
                        and msg.material_no is not null
                      group by material_no,eq.equipment_id,eq.line_name,eq.description
                      union
                     select eq.line_name,
                            eq.equipment_id,
                            eq.description,
                            msg.responsibility defectItem,
                            count(msg.responsibility) failqty
                      from r_equip_materials_msg_t msg
                     inner join (select line.line_name,basic.equipment_id,basic.description
                                   from c_line_desc_t line
                                  inner join c_station_config_t stc
                                     on line.line_name=stc.line_name
                                    and line.automation_flag='1' 
                                  inner join c_equipment_basic_t basic
                                     on basic.equipment_id=stc.equipment_id
                                  where automation_flag='1') eq
                        on msg.equipment_id=eq.equipment_id
                       and msg.responsibility is not null
                       and msg.insert_date>sysdate-30
                     group by msg.responsibility,eq.equipment_id,eq.line_name,eq.description) totaltable
            on totaltable.defectItem=failtable.defectItem
           and totaltable.equipment_id=failtable.equipment_id
           and totaltable.line_name=failtable.line_name) alllist ) s
            where s.failrate>5
 --------------------------------------------
#materialFailRatePostJSON


#materialFailRecords
 --------------------------------------------
select row_number() over (order by alllist.insert_date desc) as "ROWNUM",alllist.* from
 (select msg.material_no, 
         msg.model,
         msg.m_vendor,
         msg.m_dc,
         msg.insert_date,
         msg.result,
         uc.m_desc,
         msg.source eq_res
    from R_EQUIP_MATERIALS_MSG_T msg
    left join C_MATERIALS_USING_CODE_T uc
      on msg.result=uc.m_code
   where msg.result<>'OK'
     and msg.insert_date>sysdate-[[rangeDay]]
     and msg.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and msg.material_no=[[materialNO]]
   union
  select '' material_no, 
         msg.model,
         msg.m_vendor,
         msg.m_dc,
         msg.insert_date,
         msg.result,
         uc.m_desc,
         msg.responsibility eq_res
    from R_EQUIP_MATERIALS_MSG_T msg
    left join C_MATERIALS_USING_CODE_T uc
      on msg.result=uc.m_code
   where msg.result<>'OK'
     and msg.insert_date>sysdate-[[rangeDay]]
     and msg.equipment_id=cast( [[equipmentID]] as raw(16)) 
     and msg.responsibility=[[materialNO]]) alllist
 --------------------------------------------
#materialFailRecords


#materialQualityWarning
 --------------------------------------------
select part_no,
       occur_time
  from r_exception_main_t
 where part_no=[[partNO]]
   and occur_time>sysdate-[[rangeDay]]
 --------------------------------------------
#materialQualityWarning


#moMsg
 --------------------------------------------
SELECT A.*, B.MO_NUMBER NEXT_MO, B.MODEL_NAME NEXT_MODEL
  FROM (SELECT MO_NUMBER,
               MODEL_NAME,
               MO_QTY,
               MO_OUTPUT,
               MO_PASS_QTY,
               LINE_RATE,
               TO_CHAR(changeTime,'YYYY-MM-DD hh24:mi:ss') CHANGETIME
          FROM (SELECT TE.MO_NUMBER,
                       TE.MODEL_NAME,
                       TE.MO_QTY,
                       TE.MO_OUTPUT,
                       TE.MO_PASS_QTY,
                       LINE_RATE,
                       ((TE.MO_QTY - TE.MO_OUTPUT) * TE.LINE_RATE) / 24 / 3600 +
                       SYSDATE CHANGETIME,
                       ROWNUM RN
                  FROM (SELECT T.SFCS_MO MO_NUMBER,
                               T.SFCS_MODEL MODEL_NAME,
                               T.SCHL_QTY MO_QTY,
                               T.COLL_QTY MO_OUTPUT,
                               T.COLL_PASS_QTY MO_PASS_QTY,
                               M.OI_RATE LINE_RATE
                          FROM R_SCHEDULE_SFCS_T T
                          LEFT JOIN R_SCHEDULE_SAP_T M
                            ON T.SCHL_NO = M.SCHL_NO
                         WHERE T.LINE_NAME = [[LineName]]
                         AND T.FLAG <> 2
                         ORDER BY TO_CHAR(M.PLN_STAT_DATE, 'yyyy/mm/dd') ||
                              M.PLN_STAT_TIME) TE) A
         WHERE A.RN = 1) A,
       (SELECT *
          FROM (SELECT TE.MO_NUMBER, TE.MODEL_NAME, ROWNUM RN
                  FROM (SELECT T1.SFCS_MO MO_NUMBER,
                               T1.SFCS_MODEL MODEL_NAME,
                               T1.SCHL_QTY MO_QTY,
                               T1.COLL_QTY MO_OUTPUT,
                               M1.OI_RATE OI_RATE
                          FROM R_SCHEDULE_SFCS_T T1
                          LEFT JOIN R_SCHEDULE_SAP_T M1
                            ON T1.SCHL_NO = M1.SCHL_NO 
                         WHERE T1.LINE_NAME = [[LineName]]
                          AND T1.FLAG <> 2
                         ORDER BY TO_CHAR(M1.PLN_STAT_DATE, 'yyyy/mm/dd') ||
                              M1.PLN_STAT_TIME) TE)
         WHERE RN = 2) B
 --------------------------------------------
#moMsg


#moMsgManual
 --------------------------------------------
select CURMO.MO_NUMBER,CURMO.MODEL_NAME,CURMO.MO_QTY,CURMO.MO_OUTPUT,CURMO.MO_PASS_QTY,
       CURMO.LINE_RATE,NEXTMO.NEXT_MO,NEXTMO.NEXT_MODEL,TO_CHAR(NEXTMO.CHANGETIME ,'YYYY-MM-DD hh24:mi:ss') CHANGETIME
from (select DISTINCT A.line,A.mo_number,A.model_name,
     A.TARGET_QTY MO_QTY,(NVL(A.OUTPUT_QTY,0)+NVL(B.FAIL_QTY,0)) MO_OUTPUT,NVL(A.OUTPUT_QTY,0) MO_PASS_QTY,
     NORM_RATE LINE_RATE FROM
     (select distinct mo.* from r_mo_base_info_t mo    
     WHERE mo.line=[[LineName]] AND mo_flag=1 ) A left JOIN
     (SELECT R.MO_NUMBER,R.MODEL_NAME,R.LINE_NAME,R.GROUP_NAME,SUM(R.FAIL_QTY) FAIL_QTY
     FROM R_STATION_REC_T R LEFT JOIN  r_mo_base_info_t M ON R.MO_NUMBER=M.MO_NUMBER
     AND R.MODEL_NAME=M.MODEL_NAME AND R.GROUP_NAME=M.PRE_STATION
     WHERE mo_flag =1 AND R.GROUP_NAME IS NOT NULL
     GROUP BY R.MO_NUMBER,R.MODEL_NAME,LINE_NAME,R.GROUP_NAME) B
     ON A.MO_NUMBER=B.MO_NUMBER AND A.MODEL_NAME=B.MODEL_NAME
)CURMO LEFT JOIN (
    SELECT DISTINCT LINE,FIRST_VALUE(MO_NUMBER) OVER(ORDER BY LINE_ORDER) NEXT_MO,
     FIRST_VALUE(MODEL_NAME) OVER(ORDER BY LINE_ORDER) NEXT_MODEL,
      FIRST_VALUE(START_DATE) OVER(ORDER BY LINE_ORDER) CHANGETIME
    from r_mo_base_info_t mo 
       WHERE mo.line=[[LineName]] AND mo_flag=0
)NEXTMO
ON CURMO.LINE=NEXTMO.LINE
 --------------------------------------------
#moMsgManual


#moPassFailByGroup
 --------------------------------------------
SELECT REC.GROUP_NAME GROUP_NAME,
       NVL(PASS_QTY, 0) FIRST_PASS_QTY,
       NVL(F_FAIL_QTY, 0) FIRST_FAIL_QTY,
       TRUNC(NVL(PASS_QTY, 0) / (NVL(PASS_QTY, 0) + NVL(F_FAIL_QTY, 0)), 4) * 100 || '%' FIRST_PASS_RATE,
       NVL(PASS_QTY, 0) + NVL(REPASS, 0) TOTAL_PASS_QTY,
       NVL(FAIL_QTY, 0) TOTAL_FAIL_QTY,       
       TRUNC((NVL(PASS_QTY, 0) + NVL(REPASS, 0)) /
             (NVL(PASS_QTY, 0) + NVL(REPASS, 0) + NVL(FAIL_QTY, 0)),
             4) * 100 || '%' TOTAL_PASS_RATE
  FROM (SELECT MO_NUMBER,
               MODEL_NAME,
               T.GROUP_NAME,
               SUM(T.PASS_QTY) PASS_QTY,
               SUM(FAIL_QTY) F_FAIL_QTY
          FROM R_STATION_REC_T T
         WHERE MO_NUMBER =[[moNumber]]
         GROUP BY MO_NUMBER, MODEL_NAME, T.GROUP_NAME) REC
INNER JOIN R_MO_BASE_T MO
    ON REC.MO_NUMBER = MO.MO_NUMBER
   AND REC.MODEL_NAME = MO.MODEL_NAME
  LEFT JOIN (SELECT MODEL_NAME,
                    MO_NUMBER,
                    TEST_GROUP,
                    COUNT(DISTINCT SERIAL_NUMBER) REPASS
               FROM R_REPAIR_T T1
              WHERE MO_NUMBER =[[moNumber]]
                AND FINISH_FLAG = 'Y'
                AND NOT EXISTS
              (SELECT 0
                       FROM R_REPAIR_T T2
                      WHERE T2.SERIAL_NUMBER = T1.SERIAL_NUMBER
                        AND T2.MO_NUMBER = T1.MO_NUMBER
                        AND T2.MODEL_NAME = T1.MODEL_NAME
                        AND T2.TEST_GROUP = T1.TEST_GROUP
                        AND T2.FINISH_FLAG <> 'Y')
                AND EXISTS (SELECT 0
                       FROM R_SN_DETAIL_T SN
                      WHERE SN.SERIAL_NUMBER = T1.SERIAL_NUMBER
                        AND SN.MO_NUMBER = T1.MO_NUMBER
                        AND SN.MODEL_NAME = T1.MODEL_NAME
                        AND SN.GROUP_NAME = T1.TEST_GROUP
                        AND SN.ERROR_FLAG = 0)
              GROUP BY MODEL_NAME, MO_NUMBER, TEST_GROUP) R1
    ON REC.MO_NUMBER = R1.MO_NUMBER
   AND REC.MODEL_NAME = R1.MODEL_NAME
   AND REC.GROUP_NAME = R1.TEST_GROUP
  LEFT JOIN (SELECT MODEL_NAME,
                    MO_NUMBER,
                    TEST_GROUP,
                    COUNT(DISTINCT SERIAL_NUMBER) FAIL_QTY
               FROM R_REPAIR_T T1
              WHERE MO_NUMBER = [[moNumber]]
                AND FINISH_FLAG <> 'Y'
              GROUP BY MODEL_NAME, MO_NUMBER, TEST_GROUP) R2
    ON REC.MO_NUMBER = R2.MO_NUMBER
   AND REC.MODEL_NAME = R2.MODEL_NAME
   AND REC.GROUP_NAME = R2.TEST_GROUP
INNER JOIN C_ROUTE_CONTROL_T ROUTE
    ON MO.ROUTE_CODE = ROUTE.ROUTE_CODE
   AND ROUTE.GROUP_NEXT = REC.GROUP_NAME
   AND ROUTE.STATE_FLAG = 0
   AND ROUTE.ROUTE_DESC = 0
   AND ROUTE.GROUP_NEXT NOT IN
       (SELECT GROUP_NAME
          FROM C_ROUTE_CONTROL_T
         WHERE ROUTE_CODE = ROUTE.ROUTE_CODE
           AND ROUTE_DESC = 1)
   AND ROUTE.GROUP_NAME NOT IN
       (SELECT GROUP_NEXT
          FROM C_ROUTE_CONTROL_T
         WHERE ROUTE_CODE = ROUTE.ROUTE_CODE
           AND STATE_FLAG = 1)
WHERE REC.MO_NUMBER =[[moNumber]]
ORDER BY ROUTE.STEP_SEQUENCE

 --------------------------------------------
#moPassFailByGroup


#nextMoMsg
 --------------------------------------------
select * from 
(select te.mo_number,te.model_name,rownum rn from (
  select mo_number,model_name,mo_qty,mo_output,oi_rate
  from R_DEMO_MO_SCHEDULE_T 
  where line_name=[[LineName]] and mo_idx<>0
  order by mo_idx) te) where rn=2
 --------------------------------------------
#nextMoMsg


#process_output_distribution
 --------------------------------------------
SELECT C.LINE_NAME,
       C.EQUIPMENT_STATION || '->' || C.STORE_STATION TASK,
       MAX(CASE
         WHEN NVL(T1.PLC_STATUS, 'N/A') = '1' AND
              NVL(T1.TASK_CODE, 'N/A') = 'N/A' THEN
          '2-品檢中'
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'FINISH' THEN
          '0-運送完畢'
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'MOVE' OR
              UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'ROLL' THEN
          '1-運送中'
         WHEN NVL(T1.PLC_STATUS, 'N/A') = '0' AND
           UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'N/A' THEN
          '0-無產出配送需求'
       END) TASK_STATUS,
       MAX(CASE
         WHEN NVL(T1.PLC_STATUS, 'N/A') = '1' AND
              NVL(T1.TASK_CODE, 'N/A') = 'N/A' THEN 2  --dark YELLOW
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'FINISH' THEN 0 --GREEN
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'MOVE' OR
              UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'ROLL' THEN 1  --YELLOW
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'N/A' THEN 0 --GREEN
       END) COLOR_STATUS
  FROM C_AGV_CONVEYOR_CONFIG_T C
INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) L
    ON C.LINE_NAME = L.LINE_NAME
INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') A
    ON A.PROD_AREA_ID = L.PROD_AREA_ID
  LEFT JOIN R_AGV_COVEYOR_LOG_T T1
    ON T1.TASK_STATION = C.EQUIPMENT_STATION
WHERE C.AGV_TYPE = 'R'
   AND A.PROD_AREA_ID = [[prod_area_id]] 
   GROUP BY C.LINE_NAME, C.EQUIPMENT_STATION || '->' || C.STORE_STATION
ORDER BY COLOR_STATUS

 --------------------------------------------
#process_output_distribution


#product_ability_monitor
 --------------------------------------------
SELECT WORK_DATE,
       SECTION_RANGE,
       ROUND(SUM(REAL_QTY) / SUM(PLAN_QTY), 3) * 100 CAP
  FROM (SELECT P.LINE_NAME,
               P.MODEL_NAME,
               SUBSTR(P.SECTION_RANGE, 6, 4) SECTION_RANGE,
               P.WORK_DATE,
               P.LINE_RATE,
               DECODE(REAL_QTY,
                      0,
                      P.PLAN_QTY,
                      TRUNC(P.REAL_QTY / P.CAPACITY)) PLAN_QTY,
               P.REAL_QTY
          FROM R_PQM_DAILY_SUM_T P
         INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) A
            ON P.LINE_NAME = A.LINE_NAME
         INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') C
            ON A.PROD_AREA_ID = C.PROD_AREA_ID
         WHERE C.PROD_AREA_ID = [[prod_area_id]]
           AND P.WORK_DATE = TO_CHAR(SYSDATE-1,'YYYYMMDD')  --'20160218' 
           AND SUBSTR(P.SECTION_RANGE, 6, 4) >= TO_CHAR(sysdate, 'HH24MM')
           AND P.STATE >= 0
           AND P.OUT_GROUP = [[out_group]])
 GROUP BY SECTION_RANGE, WORK_DATE

union all

SELECT WORK_DATE,
       SECTION_RANGE,
       ROUND(SUM(REAL_QTY) / SUM(PLAN_QTY), 3) * 100 CAP
  FROM (SELECT P.LINE_NAME,
               P.MODEL_NAME,
               SUBSTR(P.SECTION_RANGE, 6, 4) SECTION_RANGE,
               P.WORK_DATE,
               P.LINE_RATE,
               DECODE(REAL_QTY,
                      0,
                      P.PLAN_QTY,
                      TRUNC(P.REAL_QTY / P.CAPACITY)) PLAN_QTY,
               P.REAL_QTY
          FROM R_PQM_DAILY_SUM_T P
         INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) A
            ON P.LINE_NAME = A.LINE_NAME
         INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') C
            ON A.PROD_AREA_ID = C.PROD_AREA_ID
         WHERE C.PROD_AREA_ID = [[prod_area_id]]
           AND P.WORK_DATE = TO_CHAR(SYSDATE,'YYYYMMDD')	-- '20160219' 
           AND SUBSTR(P.SECTION_RANGE, 6, 4) <= TO_CHAR(sysdate, 'HH24MM')
           AND P.STATE >= 0
           AND P.OUT_GROUP = [[out_group]])
 GROUP BY SECTION_RANGE, WORK_DATE

 ORDER BY WORK_DATE ASC, SECTION_RANGE ASC --最後的排序

 --------------------------------------------
#product_ability_monitor


#ProductionBaseInf_DSM
 --------------------------------------------
select output,planqty,to_char(output*100/planqty,'fm9999999999990.09')||'%' rate,  output*100/planqty ratevalue,
       running_time/60/60 runtime,line_rate from (
  select * from ( select nvl(sum((pub.pass_qty+pub.fail_qty)* nvl(pcs.pcs_qty, 1)),0) output,line.mo_idx,
  24*60*60/line.oi_rate planqty,line.oi_rate line_rate,nvl(sum(pub.running_time),0) running_time 
  from r_equipment_pub_param_record_t pub
  inner join r_equipment_interface_bom_t bom 
  on pub.interface_item_id=bom.interface_item_id and bom.valid='1' and pub.end_point > sysdate-1
  right join c_equipment_basic_t basic 
  on bom.equipment_id=basic.equipment_id 
  inner join r_demo_mo_schedule_t line 
  on line.line_name=basic.line_name  
  left join  r_demo_equipment_pcs_qty_t pcs 
  on pcs.equipment_id=basic.equipment_id
  where basic.equipment_id=cast( [[equipmentID]] as raw(16)) 
  and line.mo_idx > 0
  group by line.oi_rate,line.mo_idx
  order by line.mo_idx asc)where rownum < 2)
 --------------------------------------------
#ProductionBaseInf_DSM


#ProductionBaseInf_Shopfloor
 --------------------------------------------

 --------------------------------------------
#ProductionBaseInf_Shopfloor


#ProductionBaseInfDsm
 --------------------------------------------
SELECT OUTPUT,
       round(PLANQTY,0)  as PLANQTY,
       TO_CHAR(OUTPUT * 100 / PLANQTY, 'fm9999999999990.09') || '%' RATE,
       round(OUTPUT * 100 / PLANQTY,4) RATEVALUE,
       RUNNING_TIME / 60 / 60 RUNTIME,
       LINE_RATE
  FROM (SELECT NVL(SUM((PUB.PASS_QTY + PUB.FAIL_QTY) *
                       NVL(PCS.PCB_QTY, 1)),
                   0) OUTPUT,
               LINE.SCHL_NO,
               24 * 60 * 60 / M.OI_RATE PLANQTY,
               M.OI_RATE LINE_RATE,
               NVL(SUM(PUB.RUNNING_TIME), 0) RUNNING_TIME
          FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
         INNER JOIN C_EQUIPMENT_BASIC_T BOM
            ON PUB.EQUIPMENT_ID = BOM.EQUIPMENT_ID
           AND PUB.END_POINT > SYSDATE - 1
         INNER JOIN (select * from  C_STATION_CONFIG_T Where line_name = [[LineName]] ) CON
            ON CON.EQUIPMENT_ID = BOM.EQUIPMENT_ID
         INNER JOIN R_SCHEDULE_SFCS_T LINE
            ON LINE.LINE_NAME = CON.LINE_NAME
         INNER JOIN R_SCHEDULE_SAP_T M
            ON LINE.SCHL_NO = M.SCHL_NO
         Left JOIN R_EQUIP_PCB_QTY_T PCS
            ON PCS.GROUP_NAME = CON.GROUP_NAME
           AND LINE.CLOSE_DATE IS NULL
         WHERE BOM.EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
           AND LINE.FLAG='1'
         GROUP BY M.OI_RATE, LINE.SCHL_NO
         ORDER BY LINE.SCHL_NO ASC)
 --------------------------------------------
#ProductionBaseInfDsm


#ProductionBaseInfSP
 --------------------------------------------
select output,planqty,to_char(output*100/planqty,'fm9999999999990.09')||'%' rate,  output*100/planqty ratevalue,
       running_time/60/60 runtime,line_rate from (
  select * from ( select nvl(sum((pub.pass_qty+pub.fail_qty)* nvl(pcs.pcb_qty, 1)),0) output,line.Schl_No,
  24*60*60/M.Oi_Rate planqty,M.Oi_Rate line_rate,0 running_time 
  from r_station_rec_t pub
  inner join R_SCHEDULE_SFCS_T line
  on pub.Mo_Number=line.Sfcs_Mo
  and pub.Model_Name=line.Sfcs_Model
  and pub.line_name=line.Line_Name
  INNER JOIN R_SCHEDULE_SAP_T M
  ON line.Schl_No=M.SCHL_NO
  left join c_station_config_t  con
  on pub.line_name=con.line_name
  and pub.group_name=con.group_name
  left join R_EQUIP_PCB_QTY_T pcs
  on con.group_name=pcs.group_name
  where pub.line_name=[[LineName]]
    and pub.group_name=[[GroupName]]
    and pub.model_name=[[ModelName]]
    and line.Close_Date IS NULL
  group by M.oi_rate,line.Schl_No
  order by line.Schl_No asc)where rownum < 2)
 --------------------------------------------
#ProductionBaseInfSP


#ProductionCTDsm
 --------------------------------------------
select rp.cycle_time from r_equipment_basic_data_t rp
where EQUIPMENT_ID=cast( [[equipmentID]] as raw(16)) 

 --------------------------------------------
#ProductionCTDsm


#ProductionDelayDsm
 --------------------------------------------
select case de.status 
       when -1 then '無法連機'
       when 1 then '故障延誤'
       when 2 then '暫停'
       when 3 then '待機(無生產)'
       when 4 then '待料'
       when 5 then '產出滿料'
       else '其它延誤' end describe,
       count(de.status) status,
       sum(de.delay_time) delay_time 
       from (select dd.status,dd.status_code,
       (dd.end_point-dd.begin_point)*24*60 delay_time 
       from R_Equipment_Status_Record_t dd
       left join c_equipment_basic_t bom
       on dd.equipment_id=bom.equipment_id
where bom.equipment_code=cast( [[equipmentID]] as raw(16))  and dd.status<>0
       and dd.end_point > sysdate - 1) de 
group by de.status
 --------------------------------------------
#ProductionDelayDsm


#ProductionDelaySP
 --------------------------------------------
select loss.loss_desc describe,count(loss.loss_code) status,
       sum(loss.delay_time) delay_time 
 from (select delay.loss_desc,delay.loss_code,
      (delay.end_time-delay.begin_time)*24*60 delay_time  
 from p_pqm_line_loss_t delay 
where delay.line_name=[[LineName]] and delay.end_time > sysdate - 1) loss
group by loss.loss_desc
 --------------------------------------------
#ProductionDelaySP


#ProductionUPH_DSM
 --------------------------------------------
select NVL(sum(pub.pass_qty),0) as pass_qty  from r_equipment_pub_param_record_t pub
  inner join c_equipment_basic_t bom 
  on pub.equipment_id=bom.equipment_id and pub.end_point > sysdate-1/24
where bom.equipment_code=cast( [[equipmentID]] as raw(16)) 
 --------------------------------------------
#ProductionUPH_DSM


#ProductionUPH_Shopfloor
 --------------------------------------------
select NVL(sum(rec.pass_qty),0) as pass_qty from r_station_rec_t rec 
where rec.line_name = [[LineName]]
  and rec.group_name = cast( [[equipmentID]] as raw(16)) 
  and rec.inputdate > sysdate-1/24
 --------------------------------------------
#ProductionUPH_Shopfloor


#ProductionUphDsm
 --------------------------------------------
select pass_qty*pcb_qty pass_qty from (
select NVL(sum(pub.pass_qty),0) as pass_qty,NVL(equip.pcb_qty,1) pcb_qty  
  from r_equipment_pub_param_record_t pub
  left join c_station_config_t con
  on pub.equipment_id=con.equipment_id
  inner join c_equipment_basic_t bom 
  on pub.equipment_id=bom.equipment_id  
  LEFT join R_EQUIP_PCB_QTY_T equip
  on equip.group_name=con.group_name
where bom.equipment_id=cast( [[equipmentID]] as raw(16)) 
  and pub.end_point > sysdate-1/24
  group by equip.pcb_qty)

 --------------------------------------------
#ProductionUphDsm


#ProductionUphShopfloor
 --------------------------------------------
select qty.pass_qty*qty.pcb_unit pass_qty from( 
select rec.model_name,nvl(sum(rec.pass_qty),0) pass_qty,
       decode(md.pcb_qty_flag,'0',md.pcb_qty,1) pcb_unit 
from r_station_rec_t rec
inner join c_model_desc_t md  
 on rec.model_name=md.model_name
where rec.line_name=[[LineName]]
  and rec.group_name=cast( [[equipmentID]] as raw(16)) 
  and rec.inputdate>sysdate - 1/24 
  and rownum = 1
group by decode(md.pcb_qty_flag,'0',md.pcb_qty,1),rec.model_name
order by pass_qty) qty
 --------------------------------------------
#ProductionUphShopfloor


#ProductManageDelayChat
 --------------------------------------------
SELECT round(SUM(nvl(pub.end_point, SYSDATE) - CASE
             WHEN pub.begin_point < SYSDATE - 1 THEN
              SYSDATE - 1
             ELSE
              pub.begin_point
           END) * 24 * 60,4) nt,
       CASE
         WHEN pub.status_code = '0' THEN
          '0--其它'
         ELSE
          pub.status_code || '--' || sta.error_desc
       END AS STATUS_DETAIL
  FROM R_Equipment_Status_Record_t pub
 INNER JOIN c_equipment_basic_t  baisc
    ON pub.equipment_id = baisc.equipment_id
   AND pub.status = 1
  LEFT JOIN C_equipment_error_code_t sta
    on  sta.equipment_type = baisc.type_id
   AND sta.error_code = pub.status_code
 WHERE baisc.equipment_id = [[EQUIPMENT_ID]]
   AND (pub.end_point > = SYSDATE - 1 OR (pub.end_point IS NULL))
 GROUP BY pub.status_code, sta.error_desc 
 --------------------------------------------
#ProductManageDelayChat


#QualityDuty_manual
 --------------------------------------------
select * from 
(select count(1) AS Y_AXLE, decode(dc.duty_desc,null,'未知',dc.duty_desc) AS X_AXLE
  from r_repair_t rep
  left join c_duty_t dc
    on rep.duty_type = dc.duty_type
 where rep.mo_number = [[moNumber]]
   and rep.test_line = [[lineName]]
   and dc.prod_plant=(select prod_plant from c_prod_plant_line_t where line_name=[[lineName]] and rownum=1)
   and rep.repair_time > sysdate - [[rangeDay]]
 group by dc.duty_desc) alllist
 order by alllist.Y_AXLE desc
 --------------------------------------------
#QualityDuty_manual


#QualityErrorDesc_manual
 --------------------------------------------
 select * from 
(select count(1) AS Y_AXLE,  decode(ec.reason_desc,null,'未知',ec.reason_desc) AS X_AXLE
  from r_repair_t rep
  left join c_reason_code_t ec
    on rep.reason_code = ec.reason_code
 where rep.mo_number = [[moNumber]]
   and rep.test_line = [[lineName]]
   and rep.repair_time > sysdate - [[rangeDay]]
 group by ec.reason_desc) alllist
 order by alllist.Y_AXLE desc
 --------------------------------------------
#QualityErrorDesc_manual


#QualityImageVisible
 --------------------------------------------
SELECT DECODE(EQUIPMENT_ID, 'CNDG2P07009', 1, 0) VIS
  FROM C_EQUIPMENT_BASIC_T
 WHERE EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
 --------------------------------------------
#QualityImageVisible


#QualityLineChart
 --------------------------------------------
SELECT ROUND(RATE,2) CRR,ROUND(dbms_random.value(70,100),2) PLR,TIMENODE FROM (
SELECT NVL(SUM(PUB.PASS_QTY) / SUM(PUB.PASS_QTY + PUB.FAIL_QTY), 1) * 100 RATE,       
       TRUNC(PUB.END_POINT, 'hh') + 1 / 24 TIMENODE
  FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
 INNER JOIN R_EQUIPMENT_INTERFACE_BOM_T BOM
    ON PUB.INTERFACE_ITEM_ID = BOM.INTERFACE_ITEM_ID
   AND BOM.VALID = '1'
 WHERE BOM.EQUIPMENT_ID =cast( [[equipmentID]] as raw(16)) 
   AND END_POINT >= TRUNC([[DateFrom]])-- + 1 / 3
   AND END_POINT <= TRUNC([[DateTo]])
 GROUP BY TRUNC(PUB.END_POINT, 'hh'))
 ORDER BY TIMENODE
 --------------------------------------------
#QualityLineChart


#QualityPassFailQtyByLine_7or30_CR
 --------------------------------------------
 --同7天/30天直通率fact邏輯
 with dimAreaType as (
    select a.line_name,case when b.area_flag=1 then 'SMT' ELSE 'NotSMT' END as AREA_FLAG
    from (select * from c_prod_area_line_t where line_name =[[lineName]]) a left join (select * from sfcs.c_prod_area_t where  delete_flag='0') b
    ON a.PROD_AREA_ID = b.PROD_AREA_ID
),
dimGroup as (
--耀欽->主線是用C_STATION_CONFIG_T的group name , SMT是用C_GROUP_CONFIG_T的OP_GROUP_NAME，跨Group將數據加總，再計算良率
--耀欽->and A.SECTION_NAME=G.SECTION_NAME 串不串沒差
SELECT distinct a.line_name, a.section_name,  case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end  as Group_name,
        MAX(NVL(a.station_idx,0)) OVER (
                               PARTITION BY a.line_name,a.section_name,case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end
                                ) GROUP_INDEX                          
FROM C_STATION_CONFIG_T A 
INNER JOIN C_GROUP_CONFIG_T G ON A.GROUP_NAME=G.GROUP_NAME 
--and A.SECTION_NAME=G.SECTION_NAME
LEFT JOIN  C_OP_GROUP_CONFIG_T C1 ON C1.OP_GROUP_NAME=G.OP_GROUP_NAME 
LEFT JOIN C_OP_GROUP_TYPE_T C2 ON C1.OP_GROUP_TYPE_ID = C2.OP_GROUP_TYPE_ID
left join dimAreaType c3 on a.line_name=c3.line_name
left join C_LINE_ECHELON_T c4 on a.line_name=c4.line_name 
WHERE A.LINE_NAME=[[lineName]]
and c2.YIELD_FLAG = 'Y'
) 
 
SELECT  
              T.GROUP_NAME as X_AXLE,
              -- max(sc.station_idx) as GROUP_INDEX,
              -- sum(PASS_QTY) as PASS_QTY,
              -- sum(FAIL_QTY) as FAIL_QTY,
               (CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
                  WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
                  ELSE ROUND(SUM(PASS_QTY) /
                         DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                                SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 6) END)*100 as Y_AXLE
          FROM R_PQM_LINE_SUM_T T
          LEFT JOIN 
          --(
		  -- select c.line_name,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end as group_name,max(c.station_idx) as  station_idx
          --       from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,c_group_config_t e
          --       where c.line_name=d.line_name
          --       and c.group_name=e.group_name
          --       and c.section_name=e.section_name
          --       group by c.line_name,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end 
		 -- ) 
		 dimGroup SC 
		 ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME 
         WHERE T.LINE_NAME = [[lineName]]
           AND T.WORK_DATE >= TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD')
           AND NOT EXISTS  --去除前第N天的後半夜夜班，這部分統計在前一天
           (SELECT 0 FROM R_PQM_LINE_SUM_T A
         WHERE A.WORK_DATE = T.WORK_DATE
           AND A.LINE_NAME = T.LINE_NAME
           AND A.SHIFT = T.SHIFT 
           AND A.NIGHT_FLAG = A.NIGHT_FLAG
           AND A.SHIFT = 'NIGHT'
           AND A.NIGHT_FLAG = 'B'
           AND WORK_DATE = TO_CHAR(SYSDATE-[[rangeDay]], 'YYYYMMDD'))
        group by  
              T.GROUP_NAME,GROUP_INDEX
        ORDER BY GROUP_INDEX, T.GROUP_NAME
 --------------------------------------------
#QualityPassFailQtyByLine_7or30_CR


#QualityPassFailQtyByLine_Auto
 --------------------------------------------
select alllist.X_AXLE,alllist.Y_AXLE from 
(SELECT STC.GROUP_NAME AS X_AXLE,
        DECODE(SUM(PUB.PASS_QTY*DECODE(QTY.PCB_QTY,null,1,QTY.PCB_QTY) + PUB.FAIL_QTY),
              0,
              1,
              SUM(PUB.PASS_QTY) / SUM(PUB.PASS_QTY + PUB.FAIL_QTY))*100 AS Y_AXLE,
        stc.station_idx 
  FROM R_EQUIPMENT_PUB_PARAM_RECORD_T PUB
  LEFT JOIN C_STATION_CONFIG_T STC
    ON STC.EQUIPMENT_ID = PUB.EQUIPMENT_ID
   LEFT JOIN R_EQUIP_PCB_QTY_T QTY 
   ON STC.GROUP_NAME=QTY.GROUP_NAME
 WHERE STC.LINE_NAME = [[lineName]]
   AND PUB.END_POINT > SYSDATE - [[rangeDay]]
   AND STC.DEAL_FLAG = 1
 GROUP BY STC.GROUP_NAME,stc.station_idx) alllist
 order by alllist.station_idx
 --------------------------------------------
#QualityPassFailQtyByLine_Auto

--20180725 
#QualityPassFailQtyByLine_CR_Day
 --------------------------------------------
  with dimAreaType as (
    select a.line_name,case when b.area_flag=1 then 'SMT' ELSE 'NotSMT' END as AREA_FLAG
    from (select * from c_prod_area_line_t where line_name =[[lineName]]) a left join (select * from sfcs.c_prod_area_t where  delete_flag='0') b
    ON a.PROD_AREA_ID = b.PROD_AREA_ID
),
dimGroup as (
--耀欽->主線是用C_STATION_CONFIG_T的group name , SMT是用C_GROUP_CONFIG_T的OP_GROUP_NAME，跨Group將數據加總，再計算良率
--耀欽->and A.SECTION_NAME=G.SECTION_NAME 串不串沒差
SELECT distinct a.line_name, a.section_name,  case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end  as Group_name,
        MAX(NVL(a.station_idx,0)) OVER (
                               PARTITION BY a.line_name,a.section_name,case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end
                                ) GROUP_INDEX                          
FROM C_STATION_CONFIG_T A 
INNER JOIN C_GROUP_CONFIG_T G ON A.GROUP_NAME=G.GROUP_NAME 
--and A.SECTION_NAME=G.SECTION_NAME
LEFT JOIN  C_OP_GROUP_CONFIG_T C1 ON C1.OP_GROUP_NAME=G.OP_GROUP_NAME 
LEFT JOIN C_OP_GROUP_TYPE_T C2 ON C1.OP_GROUP_TYPE_ID = C2.OP_GROUP_TYPE_ID
left join dimAreaType c3 on a.line_name=c3.line_name
left join C_LINE_ECHELON_T c4 on a.line_name=c4.line_name 
WHERE A.LINE_NAME=[[lineName]]
and c2.YIELD_FLAG = 'Y'
) 
SELECT GROUP_NAME X_AXLE,
  (CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
        WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
        ELSE ROUND(SUM(PASS_QTY) /
               DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                      SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
      FROM (SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.GROUP_INDEX,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
              LEFT JOIN 
               -- (
			    --select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                -- from 
                -- (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                -- where c.line_name=d.line_name
                -- and c.group_name=e.group_name
                -- and c.section_name=e.section_name
			    -- )
			    dimGroup SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND (T.SHIFT = 'DAY' or T.SHIFT = '日A')
               AND T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
           UNION ALL --前一个夜班，前半夜，日期為上一天
            SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.GROUP_INDEX,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
                LEFT JOIN 
              --  (
			    --select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                -- from 
                -- (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                -- where c.line_name=d.line_name
                -- and c.group_name=e.group_name
                -- and c.section_name=e.section_name
			    -- )
			    dimGroup SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND T.WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)>'1200'
            UNION ALL --前一个夜班，后半夜
            SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.GROUP_INDEX,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
            LEFT JOIN 
               -- (
			    --select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                -- from 
                -- (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                -- where c.line_name=d.line_name
                -- and c.group_name=e.group_name
                -- and c.section_name=e.section_name
			    -- )
			    dimGroup SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)<'1200')YIELD         
     GROUP BY GROUP_NAME,GROUP_INDEX
     ORDER BY GROUP_INDEX
 --------------------------------------------
#QualityPassFailQtyByLine_CR_Day


#QualityPassFailQtyByLine_CR_Night
 --------------------------------------------
SELECT GROUP_NAME X_AXLE,
(CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
      WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
      ELSE ROUND(SUM(PASS_QTY) /
             DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                    SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
    FROM (SELECT T.GROUP_NAME,
                 PASS_QTY,
                 FAIL_QTY,
                 MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
            FROM R_PQM_LINE_GROUP_YIELD_T T
                 LEFT JOIN (
			    select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                 from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                 where c.line_name=d.line_name
                 and c.group_name=e.group_name
                 and c.section_name=e.section_name
			   ) SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
           WHERE T.LINE_NAME = [[lineName]]
             AND (T.SHIFT = 'DAY' or T.SHIFT = '日A')
             AND T.WORK_DATE = (CASE WHEN 'F'='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
         UNION ALL --夜班，前半夜
         SELECT T.GROUP_NAME,
                 PASS_QTY,
                 FAIL_QTY,
                 MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
            FROM R_PQM_LINE_GROUP_YIELD_T T
                 LEFT JOIN (
			    select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                 from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                 where c.line_name=d.line_name
                 and c.group_name=e.group_name
                 and c.section_name=e.section_name
			   ) SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
           WHERE T.LINE_NAME = [[lineName]]
             AND T.SHIFT = 'NIGHT'
             AND T.WORK_DATE = (CASE WHEN 'F'='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
             AND SUBSTR(SECTION_RANGE,1,4)>'1200'
          UNION ALL --夜班，后半夜
         SELECT T.GROUP_NAME,
                 PASS_QTY,
                 FAIL_QTY,
                 MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
            FROM R_PQM_LINE_GROUP_YIELD_T T
                 LEFT JOIN (
			    select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                 from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  ,  c_group_config_t e
                 where c.line_name=d.line_name
                 and c.group_name=e.group_name
                 and c.section_name=e.section_name
			   ) SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
           WHERE T.LINE_NAME = [[lineName]]
             AND T.SHIFT = 'NIGHT'
             AND T.WORK_DATE = (CASE WHEN 'F'='B' THEN TO_CHAR(SYSDATE, 'YYYYMMDD')
                                   ELSE TO_CHAR(SYSDATE+1, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前后半夜
             AND SUBSTR(SECTION_RANGE,1,4)<'1200') 
   GROUP BY GROUP_NAME,GROUP_INDEX
   ORDER BY GROUP_INDEX
 --------------------------------------------
#QualityPassFailQtyByLine_CR_Night


#QualityPassFailQtyByLine_Manual
 --------------------------------------------
SELECT Group_Name AS X_AXLE,
       Y_AXLE
  from (select route.Group_Name,
               DECODE(SUM(REC.PASS_QTY + REC.FAIL_QTY),
                      0,
                      1,
                      SUM(REC.PASS_QTY) / SUM(REC.PASS_QTY + REC.FAIL_QTY))*100 AS Y_AXLE
          from R_STATION_REC_T REC
          left join r_mo_overall_v mo
            on REC.Mo_Number = mo.mo_number
         right join c_route_control_t route
            on mo.route_code = route.route_code
           and REC.Group_Name = route.group_name
         where REC.Line_Name = [[lineName]]
           and REC.Mo_Number = [[moNumber]]
           and REC.INPUTDATE >= SYSDATE - [[rangeDay]]
         group by route.Group_Name)
 --------------------------------------------
#QualityPassFailQtyByLine_Manual


#QualityPassFailQtyByLine_Manual_noMo
 --------------------------------------------
SELECT REC.GROUP_NAME X_AXLE,
       DECODE(SUM(REC.PASS_QTY + REC.FAIL_QTY),
              0,
              1,
              SUM(REC.PASS_QTY) / SUM(REC.PASS_QTY + REC.FAIL_QTY)) * 100 AS Y_AXLE
  FROM R_STATION_REC_T REC
 WHERE REC.LINE_NAME = [[lineName]]
   AND REC.INPUTDATE > SYSDATE - [[rangeDay]]
   AND GROUP_NAME IS NOT NULL
 GROUP BY REC.GROUP_NAME
 ORDER by REC.GROUP_NAME
 --------------------------------------------
#QualityPassFailQtyByLine_Manual_noMo


#QualityThrowRateChart
 --------------------------------------------
SELECT T1.WARNING_VALUE ALERT, T1.LIMIT_VALUE USL, T.RATE_VALUE, T.TIMENODE
  FROM R_DEMO_PARAMETER_VALUE_T T
 INNER JOIN C_EQUIPMENT_PARAMETER_TYPE_T T1
    ON T.PARAMETER_ID = T1.PARAMETER_TYPE_ID
 WHERE EQUIPMENT_ID = cast( [[equipmentID]] as raw(16)) 
   AND PARAMETER_ID = 'APX0008'
   AND T.TIMENODE>TRUNC(SYSDATE)+1/8
 ORDER BY TIMENODE
 --------------------------------------------
#QualityThrowRateChart


#QualityXBarChart
 --------------------------------------------
SELECT T1.LIMIT_VALUE UTL,T1.DW_LIMIT LTL,T1.WARNING_VALUE USL,T1.DW_VALUE LSL,RATE_VALUE, TIMENODE
  FROM R_DEMO_PARAMETER_VALUE_T T
INNER JOIN C_EQUIPMENT_PARAMETER_TYPE_T T1
    ON T.PARAMETER_ID = T1.PARAMETER_TYPE_ID
 WHERE EQUIPMENT_ID =cast( [[equipmentID]] as raw(16)) 
   AND PARAMETER_ID = 'APX0013'
   AND T.TIMENODE>TRUNC(SYSDATE)+1/8
 ORDER BY TIMENODE
 --------------------------------------------
#QualityXBarChart


#queryGroupType
 --------------------------------------------
select group_type
  from c_station_config_t 
 where equipment_id=cast( [[equipmentID]] as raw(16))  or group_name=cast( [[equipmentID]] as raw(16)) 
 --------------------------------------------
#queryGroupType


#repeatAnalysis_M
 --------------------------------------------
select '' HALT_CODE,
       '' HALT_DESC,
       '' HALT_TIMES,
       '' LAST_WARNING_TIME,
       '' LAST_WARNING_REASON,
       '' LAST_WARNING_SOLUTION,
       '' STATUS,
	   '' ECN
  from DUAL
 --------------------------------------------
#repeatAnalysis_M


#request_material_and_board_list
 --------------------------------------------
SELECT SC.SFCS_MO MO, SA.VORNR OPCODE, SC.LINE_NAME LINE_NAME, MAX(KB.KB_FLAG) KB_FLAG
      FROM R_SCHEDULE_SAP_T SA
     INNER JOIN R_SCHEDULE_SFCS_T SC ON SA.SCHL_NO = SC.SCHL_NO
     INNER JOIN R_DELIVERY_BOM_T PR
        ON PR.MO_NUMBER = SC.SFCS_MO
       AND PR.MODEL_NAME = SC.SFCS_MODEL
       AND PR.OPCODE = SA.VORNR
     INNER JOIN C_OP_DELIVERT_T C
        ON SA.VORNR = C.OPCODE
       AND C.TYPE_CODE='P'   --B表示板子，P表示材料，此处固定为P
     INNER JOIN R_PART_KB_T KB
        ON PR.BOM_ID = KB.BOM_ID
     INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) T
        ON T.LINE_NAME = SC.LINE_NAME
     INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') D
        ON T.PROD_AREA_ID = D.PROD_AREA_ID
     WHERE D.PROD_AREA_ID = [[prod_area_id]]
     GROUP BY SC.SFCS_MO, SA.VORNR, SC.LINE_NAME

  UNION

    SELECT S.SFCS_MO MO, SA.VORNR OPCODE, S.LINE_NAME LINE_NAME, MAX(K.KB_FLAG) KB_FLAG       
      FROM R_SCHEDULE_SAP_T SA 
     INNER JOIN R_SCHEDULE_SFCS_T S ON SA.SCHL_NO = S.SCHL_NO
     INNER JOIN R_BOARD_KB_T K
        ON K.MO_NUMBER = S.SFCS_MO
       AND K.MODEL_NAME = S.SFCS_MODEL
       AND K.LINE_NAME = S.LINE_NAME
     INNER JOIN C_OP_DELIVERT_T C
        ON SA.VORNR = C.OPCODE
       AND C.TYPE_CODE='B'   --B表示板子，P表示材料，此处固定为B
     INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) T
        ON T.LINE_NAME = S.LINE_NAME
     INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') D
        ON T.PROD_AREA_ID = D.PROD_AREA_ID
     WHERE D.PROD_AREA_ID = [[prod_area_id]] 
     GROUP BY S.SFCS_MO, SA.VORNR, S.LINE_NAME

   ORDER BY KB_FLAG DESC, LINE_NAME ASC

 --------------------------------------------
#request_material_and_board_list


#request_material_board_detail
 --------------------------------------------
SELECT distinct 
	   C.TYPE_NAME||'(叫料)' TYPE_NAME,
       SC.LINE_NAME,
       PR.PART_NO, --'料號'
       DECODE(PR.SOURCE_CODE, '0', '0-主用料', '1-待用料') SOURCE_CODE, --'主次',
       PR.SLOT_STATION, --'配送站點',
       PR.QPA,
       to_char(KB.LEFT_QTY,'FM999,999,999') LEFT_QTY, --'站點庫存',
       to_char(KB.NEED_QTY,'FM999,999,999') NEED_QTY, --'叫料數量',
       to_char(KB.SEND_QTY,'FM999,999,999') SEND_QTY, --'已發數量',
       to_char(KB.REQUIRED_QTY,'FM999,999,999') REQUIRED_QTY, --'剩餘需求數量',
       TO_CHAR(SYSDATE +
               (KB.LEFT_QTY * SA.OI_RATE / PR.QPA) / (24 * 60 * 60),
               'hh24:mi') END_TIME, -- '料盡時間',
       KB_FLAG,
       (CASE
         WHEN NVL(K.TASK_STATUS, 'N/A') = '2' THEN
          '運送完畢'
         WHEN NVL(K.TASK_STATUS, 'N/A') = '5' THEN
          '已轉手動運料'
         WHEN UPPER(NVL(K.TASK_STATUS, 'N/A')) = '0' OR
              UPPER(NVL(K.TASK_STATUS, 'N/A')) = '3' THEN
          '未發車'
         WHEN UPPER(NVL(K.TASK_STATUS, 'N/A')) = '1' OR
              UPPER(NVL(K.TASK_STATUS, 'N/A')) = '4' THEN
          '運送中'
         WHEN UPPER(NVL(K.TASK_STATUS, 'N/A')) = 'N/A' THEN
          '備料中或未叫車'
       END) TASK_STATUS --AGV配送狀態
  FROM R_SCHEDULE_SAP_T SA
INNER JOIN R_SCHEDULE_SFCS_T SC
    ON SA.SCHL_NO = SC.SCHL_NO
INNER JOIN R_DELIVERY_BOM_T PR
    ON PR.MO_NUMBER = SC.SFCS_MO
   AND PR.MODEL_NAME = SC.SFCS_MODEL
   AND PR.OPCODE = SA.VORNR
INNER JOIN R_PART_KB_T KB
    ON PR.BOM_ID = KB.BOM_ID
INNER JOIN C_OP_DELIVERT_T C
    ON SA.VORNR = C.OPCODE
   AND C.TYPE_CODE = 'P'
INNER JOIN (SELECT MO_NUMBER,
                    MODEL_NAME,
                    PART_NO,
                    MAX(DELIVERY_ID) DELIVERY_ID
               FROM R_PART_DELIVERY_T
              WHERE MO_NUMBER = [[mo]] 
                AND OPCODE = [[opcode]] 
              GROUP BY MO_NUMBER, MODEL_NAME, PART_NO) P
    ON PR.MO_NUMBER = P.MO_NUMBER
   AND PR.MODEL_NAME = P.MODEL_NAME
   AND PR.PART_NO = P.PART_NO
  LEFT JOIN ELMS.R_PART_SEND_T S
    ON P.DELIVERY_ID = S.DELIVERY_ID
  LEFT JOIN C_AGV_TASK_T K
    ON S.TASK_CODE = K.TASK_CODE
WHERE PR.MO_NUMBER = [[mo]]
   AND PR.OPCODE = [[opcode]] 
   AND SC.LINE_NAME = [[line_name]] 
UNION ALL 
SELECT distinct 
 	   C.TYPE_NAME||'(叫板)' TYPE_NAME,
       K.LINE_NAME,
       K.MODEL_NAME PART_NO,
       'PWB板' SOURCE_CODE,
       K.SLOT_STATION,
       1 QPA,
       to_char(K.LEFT_QTY,'FM999,999,999') LEFT_QTY,
       to_char(K.NEED_QTY,'FM999,999,999') NEED_QTY,
       to_char(K.SEND_QTY,'FM999,999,999') SEND_QTY,
       to_char(K.REQUIRED_QTY - K.SEND_QTY,'FM999,999,999') REQUIRED_QTY,
       TO_CHAR(K.END_TIME, 'hh24:mi') END_TIME,
       KB_FLAG,
       (CASE
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'FINISH' THEN
          '運送完畢'
         WHEN UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'MOVE' OR
              UPPER(NVL(T1.AGV_METHOD, 'N/A')) = 'ROLL' THEN
          '運送中'
         WHEN UPPER(NVL(T2.AGV_METHOD, 'N/A')) = 'N/A' THEN
          '無配送需求'
       END) TASK_STATUS
  FROM R_BOARD_KB_T K
INNER JOIN C_OP_DELIVERT_T C
    ON K.OPCODE = C.OPCODE
   AND C.TYPE_CODE = 'B'
INNER JOIN C_AGV_CONVEYOR_CONFIG_T C1
    ON K.SLOT_STATION = '"' || C1.EQUIPMENT_STATION || '"'
   AND C1.AGV_TYPE = 'S'
  LEFT JOIN R_AGV_COVEYOR_LOG_T T1
    ON T1.TASK_STATION = C1.EQUIPMENT_STATION
  LEFT JOIN R_AGV_COVEYOR_LOG_T T2
    ON T1.TASK_CODE = T2.TASK_CODE
   AND T2.TASK_STATION = C1.STORE_STATION
WHERE K.MO_NUMBER = [[mo]] 
   AND K.OPCODE = [[opcode]] 
   AND K.LINE_NAME = [[line_name]] 
ORDER BY TYPE_NAME, KB_FLAG, LINE_NAME, PART_NO DESC






 --------------------------------------------
#request_material_board_detail


#smtPointByDay
 --------------------------------------------
select nvl(smt.point_qty,0) plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
   AND PQM.PROCESS_NAME= DECODE([[opCode]],'ALL',PQM.PROCESS_NAME,[[opCode]])
   and pqm.work_date>to_char(sysdate-[[rangeDay]],'YYYYMMDD')
 group by pqm.work_date,smt.point_qty
 order by pqm.work_date
 --------------------------------------------
#smtPointByDay


#smtPointBySection_CR_Day
 --------------------------------------------
select alllist.plant_point,
       alllist.real_point,
       SUBstr(alllist.time_point,9) time_point
 from ( 
 select nvl(smt.point_qty,0)/12 plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date,
       PQM.WORK_DATE||pqm.section_range time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
       AND PQM.SHIFT='DAY'
       AND PQM.PROCESS_NAME= DECODE([[opCode]],'ALL',PQM.PROCESS_NAME,[[opCode]]) --前個白班
       AND PQM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')        
 group by pqm.section_range,smt.point_qty,pqm.work_date
 UNION 
   select nvl(smt.point_qty,0)/12 plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date,
       PQM.WORK_DATE||pqm.section_range time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
       AND PQM.SHIFT = 'NIGHT'
       AND PQM.PROCESS_NAME= DECODE([[opCode]],'ALL',PQM.PROCESS_NAME,[[opCode]]) --當天白班
        AND WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
       AND SUBSTR(SECTION_RANGE,1,4)>'1200'
 group by pqm.section_range,smt.point_qty,pqm.work_date
  UNION 
   select nvl(smt.point_qty,0)/12 plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date,
       PQM.WORK_DATE||pqm.section_range time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
       AND PQM.SHIFT = 'NIGHT'
       AND PQM.PROCESS_NAME= DECODE([[opCode]],'ALL',PQM.PROCESS_NAME,[[opCode]]) --當天白班
        AND WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
       AND SUBSTR(SECTION_RANGE,1,4)<'1200'
 group by pqm.section_range,smt.point_qty,pqm.work_date) alllist
 order by alllist.time_point
 --------------------------------------------
#smtPointBySection_CR_Day


#smtPointBySection_CR_Night
 --------------------------------------------
SELECT ALLLIST.PLANT_POINT,
       ALLLIST.REAL_POINT,
       SUBSTR(ALLLIST.TIME_POINT, 9) TIME_POINT
  FROM (SELECT NVL(SMT.POINT_QTY, 0) / 12 PLANT_POINT,
               NVL(SUM(PQM.POINT_QTY), 0) REAL_POINT,
               PQM.WORK_DATE,
               PQM.WORK_DATE || PQM.SECTION_RANGE TIME_POINT
          FROM C_LINE_CT_RUNR_PASSR_ALERT_T SMT
         RIGHT JOIN R_PQM_DAILY_SUM_SMT_T PQM
            ON PQM.LINE_NAME = SMT.LINE_NAME
         WHERE PQM.LINE_NAME = [[lineName]]
           AND PQM.SHIFT = 'DAY'
           AND PQM.PROCESS_NAME =DECODE([[opCode]], 'ALL', PQM.PROCESS_NAME, [[opCode]]) --當天白班
           AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
                             ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END)
         GROUP BY PQM.SECTION_RANGE, SMT.POINT_QTY, PQM.WORK_DATE
        UNION
        SELECT NVL(SMT.POINT_QTY, 0) / 12 PLANT_POINT,
               NVL(SUM(PQM.POINT_QTY), 0) REAL_POINT,
               PQM.WORK_DATE,
               PQM.WORK_DATE || PQM.SECTION_RANGE TIME_POINT
          FROM C_LINE_CT_RUNR_PASSR_ALERT_T SMT
         RIGHT JOIN R_PQM_DAILY_SUM_SMT_T PQM
            ON PQM.LINE_NAME = SMT.LINE_NAME
         WHERE PQM.LINE_NAME = [[lineName]]
           AND PQM.SHIFT = 'NIGHT'
           AND PQM.PROCESS_NAME =DECODE([[opCode]], 'ALL', PQM.PROCESS_NAME, [[opCode]]) --前半夜
           AND WORK_DATE = (CASE
                 WHEN [[nightFlag]] = 'B' THEN
                  TO_CHAR(SYSDATE - 1, 'YYYYMMDD')
                 ELSE
                  TO_CHAR(SYSDATE, 'YYYYMMDD')
               END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
           AND SUBSTR(SECTION_RANGE, 1, 4) > '1200'
         GROUP BY PQM.SECTION_RANGE, SMT.POINT_QTY, PQM.WORK_DATE
        UNION
        SELECT NVL(SMT.POINT_QTY, 0) / 12 PLANT_POINT,
               NVL(SUM(PQM.POINT_QTY), 0) REAL_POINT,
               PQM.WORK_DATE,
               PQM.WORK_DATE || PQM.SECTION_RANGE TIME_POINT
          FROM C_LINE_CT_RUNR_PASSR_ALERT_T SMT
         RIGHT JOIN R_PQM_DAILY_SUM_SMT_T PQM
            ON PQM.LINE_NAME = SMT.LINE_NAME
         WHERE PQM.LINE_NAME = [[lineName]]
           AND PQM.SHIFT = 'NIGHT'
           AND PQM.PROCESS_NAME =DECODE([[opCode]], 'ALL', PQM.PROCESS_NAME, [[opCode]]) --後半夜
           AND WORK_DATE = (CASE
                 WHEN [[nightFlag]] = 'B' THEN
                  TO_CHAR(SYSDATE, 'YYYYMMDD')
                 ELSE
                  TO_CHAR(SYSDATE + 1, 'YYYYMMDD')
               END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
           AND SUBSTR(SECTION_RANGE, 1, 4) < '1200'
         GROUP BY PQM.SECTION_RANGE, SMT.POINT_QTY, PQM.WORK_DATE) ALLLIST
 ORDER BY ALLLIST.TIME_POINT
 --------------------------------------------
#smtPointBySection_CR_Night


#smtPointBySectionBackup170925
 --------------------------------------------
select alllist.plant_point,
       alllist.real_point,
       alllist.time_point
 from (
select nvl(smt.point_qty,0)/12 plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date,
       pqm.section_range time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
   and pqm.work_date between to_char(sysdate-1,'YYYYMMDD') and to_char(sysdate-1,'YYYYMMDD')
   and pqm.section_range>to_char(sysdate,'HH24')||'00'
 group by pqm.section_range,smt.point_qty,pqm.work_date
 union
select nvl(smt.point_qty,0)/12 plant_point,
       nvl(sum(pqm.point_qty),0) real_point,
       pqm.work_date,
       pqm.section_range time_point
  from C_LINE_CT_RUNR_PASSR_ALERT_T smt
 right join R_PQM_DAILY_SUM_SMT_T pqm
    on pqm.line_name=smt.line_name
 where pqm.line_name=[[lineName]]
   and pqm.work_date>to_char(sysdate-1,'YYYYMMDD')
 group by pqm.section_range,smt.point_qty,pqm.work_date) alllist
 order by alllist.time_point
 --------------------------------------------
#smtPointBySectionBackup170925


#StationAchievedChart
 --------------------------------------------
SELECT ALLLIST.RATE,
       to_char(ALLLIST.TIMENODE, 'hh24:mi') TIMENODE
  FROM (SELECT NVL(RATETABLE.RATE,0) RATE,
               TIMETABLE.TIMENODE
          FROM (SELECT TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < 25) TIMETABLE
          LEFT JOIN ( select nvl(sum((pub.pass_qty)*nvl(pcs.pcb_qty,1)),0)/(60*60/M.oi_rate)*100 rate,
                             TRUNC(pub.end_point, 'HH')  TIMENODE
                        from r_equipment_pub_param_record_t pub
                       inner join c_station_config_t con
                          on con.equipment_id=pub.equipment_id
                       inner join R_SCHEDULE_SFCS_T line
                          on line.line_name=con.line_name
                         and line.flag='1'
                       INNER JOIN R_SCHEDULE_SAP_T M
                          ON line.schl_no=m.schl_no   
                        left join (SELECT PCB.GROUP_NAME, PCB.PCB_QTY
                                     FROM R_EQUIP_PCB_QTY_T PCB
                                    INNER JOIN (SELECT DISTINCT FIRST_VALUE(T.SFCS_MODEL) OVER(PARTITION BY T.LINE_NAME ORDER BY T.SCHL_NO) MODEL_NAME
                                                 FROM R_SCHEDULE_SFCS_T T
                                                WHERE T.FLAG='1'
                                                  AND T.LINE_NAME = [[lineName]]) A
                                       ON PCB.MODEL_NAME = A.MODEL_NAME) PCS
                          on pcs.group_name=con.group_name
                       where pub.equipment_id=cast( [[equipmentID]] as raw(16)) 
                         and pub.end_point > SYSDATE - 25 / 24
                       group by M.oi_rate,TRUNC(pub.end_point, 'HH')) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.RATE) ALLLIST
 ORDER BY ALLLIST.TIMENODE
 --------------------------------------------
#StationAchievedChart


#T_getLineMachineList_js
 --------------------------------------------
SELECT EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
       ('http://172.17.38.14/images/'||IMAGE_NAME)  AREA,
       LINE_NAME      LINE,
       'ModelName' MODELNAME,
       'SchemaName' SCHEMANAME,
       IMAGE_NAME,
		'1213' as ImgUrl
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                  -- NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                    'PEOPLE.jpg'
                 ELSE 
                  -- ET.IMAGE_NAME
                    ET.TYPE_CODE || '.jpg'
                 END IMAGE_NAME    
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1 
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#T_getLineMachineList_js


#T_getLineMachineList_js_v2
 --------------------------------------------
SELECT EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
       [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                   NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                 ELSE 
                   ET.IMAGE_NAME
                 END IMAGE_NAME    
          FROM C_STATION_CONFIG_T SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE SC.LINE_NAME =[[lineName]] AND NVL(task_code,0) <>1
         ORDER BY STATION_IDX,EQUIPMENT_ID)
 --------------------------------------------
#T_getLineMachineList_js_v2


#totalIdleTime
 --------------------------------------------
select t1.TOTAL1+t2.TOTAL2 total from 
  (select cast( [[equipmentID]] as raw(16))  equipment_id,
           a1.TOTAL1
      from (
        select nvl(round(sum(dl.delay_time)/60,2),0) TOTAL1
         from r_equipment_delay_t dl
        inner join  c_equipment_basic_t basic
           on basic.equipment_id=dl.equipment_id
        where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
          and dl.delay_res=cast( [[equipmentID]] as raw(16)) 
          and dl.delay_type='p'
          and dl.insert_date>sysdate-1
          and dl.delay_time between basic.idle_lower and basic.idle_upper) a1) t1
 left join 
   (select cast( [[equipmentID]] as raw(16))  equipment_id,
           a2.TOTAL2
      from (
        select nvl(round(sum(dl.delay_time)/60,2),0) TOTAL2
         from  r_equipment_delay_t dl
        inner join  c_equipment_basic_t basic
           on basic.equipment_id=dl.equipment_id
        where dl.equipment_id=cast( [[equipmentID]] as raw(16)) 
          and dl.delay_res<>cast( [[equipmentID]] as raw(16)) 
          and dl.insert_date>sysdate-1
          and dl.delay_time between basic.idle_lower and basic.idle_upper) a2) T2
    on t1.equipment_id=t2.equipment_id
 --------------------------------------------
#totalIdleTime


#warningResume
 --------------------------------------------
select alllist.WARNING_TIME,
       alllist.WARNING_CODE,
       alllist.WARNING_DESC,
       alllist.SUSPEND_TIME,
       alllist.WARNING_FLAG,
       alllist.IS_REPEAT,
       alllist.REASON,
       alllist.SOLUTION,
       alllist.DEAL_EMP,
       alllist.pqm_flag
  from (
    select distinct tbs.begin_point WARNING_TIME,
           err.error_code WARNING_CODE,
           err.error_desc WARNING_DESC,
           case
             when tbs.end_point is null then
               0
             else
               round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2)
           end SUSPEND_TIME,
           case
             when tbs.end_point is null then
               'OPEN'
             else
               'CLOSE'
           end WARNING_FLAG,
           'N' IS_REPEAT,
           cause.cause_description REASON,
           alert.solution_description SOLUTION,
           exc.solve_emp DEAL_EMP,
           err.error_type pqm_flag 
      from r_equip_tbs_t tbs
     inner join c_equipment_basic_t basic
        on tbs.equipment_id=basic.equipment_id
     inner join c_equipment_error_code_t err
        on err.equipment_type=basic.type_id
       and tbs.status_code=err.error_code
      left join r_exception_main_t exc
        on tbs.equipment_id=exc.equipment_id
       and exc.occur_time=tbs.begin_point
      left join c_abnormal_cause_t cause
        on exc.reason_id=cause.reason_id
      left join c_alert_countermeasure_t alert
        on exc.solution_id=alert.solution_id
     where tbs.equipment_id=[[EQUIPMENT_ID]]
       and err.error_type='m'
       and tbs.begin_point>sysdate-[[Days]]
       and 0=[[type_m]]
     union
    select distinct tbs.begin_point WARNING_TIME,
           err.error_code WARNING_CODE,
           err.error_desc WARNING_DESC,
           case
             when tbs.end_point is null then
               0
             else
               round(ceil((tbs.end_point-tbs.begin_point)*24*60*60)/60,2)
           end SUSPEND_TIME,
           case
             when tbs.end_point is null then
               'OPEN'
             else
               'CLOSE'
           end WARNING_FLAG,
           'N' IS_REPEAT,
           cause.cause_description REASON,
           alert.solution_description SOLUTION,
           exc.solve_emp DEAL_EMP,
           err.error_type pqm_flag 
      from r_equip_tbs_t tbs
     inner join c_equipment_basic_t basic
        on tbs.equipment_id=basic.equipment_id
     inner join c_equipment_error_code_t err
        on err.equipment_type=basic.type_id
       and tbs.status_code=err.error_code
      left join r_exception_main_t exc
        on tbs.equipment_id=exc.equipment_id
       and exc.occur_time=tbs.begin_point
      left join c_abnormal_cause_t cause
        on exc.reason_id=cause.reason_id
      left join c_alert_countermeasure_t alert
        on exc.solution_id=alert.solution_id
     where tbs.equipment_id=[[EQUIPMENT_ID]]
       and tbs.begin_point>sysdate-[[Days]]
       and 1=[[type_m]] ) alllist
 order by alllist.WARNING_TIME desc
 --------------------------------------------
#warningResume


#warnOfProdLine
 --------------------------------------------
select line_name,
	   to_char(in24hrsOccur, 'FM999,999,999') as in24hrsOccur,
       to_char(in24hrsSolve, 'FM999,999,999') as in24hrsSolve,
       to_char(in24hrsNoSolve, 'FM999,999,999') as in24hrsNoSolve,
       to_char(over24hrsNoSolve, 'FM999,999,999') as over24hrsNoSolve
  from (select tem.line_name as line_name,
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_main_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 1) as in24hrsOccur, --24H內發生的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_main_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 1
                   and excep.status = '5') as in24hrsSolve, --24H發生且處理完成的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_main_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 1
                   and excep.status != '5') as in24hrsNoSolve, --24H發生且處理中的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_main_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time < sysdate - 1
                   and excep.status != '5') as over24hrsNoSolve --在24前並且未處理完成的
          from (select line_name
                  from c_prod_area_line_t
                 where prod_area_id = [[prod_area_id]]
				 and delete_flag='0' ) tem
        
        )
 where over24hrsNoSolve > 0
    or in24hrsOccur > 0 
 order by line_name asc

 --------------------------------------------
#warnOfProdLine


#warnOfProdLineDetail-old
 --------------------------------------------
with factException as (
select ID,PHENOMENON_ID,OCCUR_TIME,STATUS,REASON_ID,SOLUTION_ID,SOLVE_GROUP,SOLVE_EMP,SOLVE_TIME,
EQUIPMENT_ID
,SN,MO_NUMBER,MODEL_NAME,LINE_NAME,STATION_NAME,PART_NO,EXCEPTION_MESSAGE,UPDATE_TIME,PHENOMENON_CODE,ERROR_FLAG,ACCEPT_TIME,ACCEPT_EMP
from r_exception_main_t 
        where line_name = [[line_name]] 
        and 
        (
         (1=<<in24solve>> and occur_time >= sysdate - 1 and status = '5')
         or 
         (1=<<in24noSolve>> and occur_time >= sysdate - 1 and status != '5')
         or 
         (1=<<over24>> and occur_time < sysdate - 1 and status != '5')
        )
)
select ex.status status,
       ex.line_name LINE_NAME,
       basic.description EQUIPMENT_DESCRIPTION,
       TO_CHAR(ex.occur_time, 'YYYY/MM/DD HH24:MI:SS') OCCUR_TIME,
       NVL2(ex.phenomenon_id, ph.phenomenon_code, ex.phenomenon_code) PHENOMENON_CODE,
       /*ph.phenomenon_code PHENOMENON_CODE,*/
       ph.description PHENOMENON_DESCRIPTION,
       DECODE(ext.main_class, 'M', '設備', 'Q', '品質', 'P', '生產', '') TYPE,
       status.status_description STATUS_DESCRIPTION,
       ca.cause_description CAUSE_DESCRIPTION,
       mea.solution_description SOLUTION_DESCRIPTION, --處理對策
       emp.emp_name EMP_NAME,
       NVL2(ex.solve_time,
            to_char(ROUND((ex.solve_time - ex.occur_time) * 1440),
                    'FM999,999,999'),
            '') TIMELINESS
  from factException ex
  left join c_equipment_basic_t basic
  --left join (select  * from c_equipment_basic_t where equipment_id in (select EQUIPMENT_ID from factException )) basic
    on ex.equipment_id  =cast(basic.equipment_id as varchar(64))
    --cast(equipment_id as VARCHAR2(64)) as
  left join  c_abnormal_phenomenon_t ph
    on ex.phenomenon_id = ph.phenomenon_id
  left join c_abnormal_cause_t ca
    on ex.reason_id = ca.reason_id
  left join c_exception_type_t ext
    on ph.exception_type_id = ext.exception_type_id
  left join c_emp_desc_t emp
    on ex.solve_emp = emp.emp_no
  left join c_alert_countermeasure_t mea
    on ex.solution_id = mea.solution_id
  left join c_exception_process_status_t status
    on ex.status = status.status_code
 where  ph.phenomenon_code != '0'
 --------------------------------------------
#warnOfProdLineDetail-old


#warnOfProdLineRepeat
 --------------------------------------------
select line_name,
       to_char(over30daysOccur, 'FM999,999,999') as over30daysOccur,
       to_char(in30daysOccur, 'FM999,999,999') as in30daysOccur,
       to_char(in7daysOccur, 'FM999,999,999') as in7daysOccur,
       to_char(in24hrsOccur, 'FM999,999,999') as in24hrsOccur
  from (select tem.line_name as line_name,
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_repeated_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time < sysdate - 30) as over30daysOccur, --30d之前發生的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_repeated_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 30) as in30daysOccur, --近30d發生的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_repeated_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 7) as in7daysOccur, --近7d發生的
               (select count(1)
                  from c_station_config_t sta_conf
                 inner join c_equipment_basic_t basic
                    on sta_conf.equipment_id = basic.equipment_id
                 inner join r_exception_repeated_t excep
                    on basic.equipment_id = excep.equipment_id
                 where sta_conf.line_name = tem.line_name
                   and excep.occur_time >= sysdate - 1) as in24hrsOccur --近24h發生的
          from (select line_name
                  from c_prod_area_line_t
                 where prod_area_id = [[prod_area_id]] and delete_flag='0' ) tem)
 where over30daysOccur > 0
    or in30daysOccur > 0
 order by line_name asc 
 --------------------------------------------
#warnOfProdLineRepeat

#warnOfProdLineDetail
--------------------------------------------
select ex.status status,
       ex.line_name LINE_NAME,
       basic.description EQUIPMENT_DESCRIPTION,
       TO_CHAR(ex.occur_time, 'YYYY/MM/DD HH24:MI:SS') OCCUR_TIME,
       NVL2(ex.phenomenon_id, ph.phenomenon_code, ex.phenomenon_code) PHENOMENON_CODE,
       /*ph.phenomenon_code PHENOMENON_CODE,*/
       ph.description PHENOMENON_DESCRIPTION,
       DECODE(ext.main_class, 'M', '設備', 'Q', '品質', 'P', '生產', '') TYPE,
       status.status_description STATUS_DESCRIPTION,
       ca.cause_description CAUSE_DESCRIPTION,
       mea.solution_description SOLUTION_DESCRIPTION, --處理對策
       emp.emp_name EMP_NAME,
       NVL2(ex.solve_time,
            to_char(ROUND((ex.solve_time - ex.occur_time) * 1440),
                    'FM999,999,999'),
            '') TIMELINESS
  from r_exception_main_t ex
  left join c_equipment_basic_t basic
    on ex.equipment_id = basic.equipment_id
  left join c_abnormal_phenomenon_t ph
    on ex.phenomenon_id = ph.phenomenon_id
  left join c_abnormal_cause_t ca
    on ex.reason_id = ca.reason_id
  left join c_exception_type_t ext
    on ph.exception_type_id = ext.exception_type_id
  left join c_emp_desc_t emp
    on ex.solve_emp = emp.emp_no
  left join c_alert_countermeasure_t mea
    on ex.solution_id = mea.solution_id
  left join c_exception_process_status_t status
    on ex.status = status.status_code
 where ex.line_name = [[line_name]]
   and ph.phenomenon_code != '0' 
   and ex.occur_time < sysdate - 1
   and ex.status != '5'
   and 1 = [[over24]]

union all

select ex.status status,
       ex.line_name LINE_NAME,
       basic.description EQUIPMENT_DESCRIPTION,
       TO_CHAR(ex.occur_time, 'YYYY/MM/DD HH24:MI:SS') OCCUR_TIME,
       NVL2(ex.phenomenon_id, ph.phenomenon_code, ex.phenomenon_code) PHENOMENON_CODE,
       /*ph.phenomenon_code PHENOMENON_CODE,*/
       ph.description PHENOMENON_DESCRIPTION,
       DECODE(ext.main_class, 'M', '設備', 'Q', '品質', 'P', '生產', '') TYPE,
       status.status_description STATUS_DESCRIPTION,
       ca.cause_description CAUSE_DESCRIPTION,
       mea.solution_description SOLUTION_DESCRIPTION, --處理對策
       emp.emp_name EMP_NAME,
       NVL2(ex.solve_time,
            to_char(ROUND((ex.solve_time - ex.occur_time) * 1440),
                    'FM999,999,999'),
            '') TIMELINESS
  from r_exception_main_t ex
  left join c_equipment_basic_t basic
    on ex.equipment_id = basic.equipment_id
  left join c_abnormal_phenomenon_t ph
    on ex.phenomenon_id = ph.phenomenon_id
  left join c_abnormal_cause_t ca
    on ex.reason_id = ca.reason_id
  left join c_exception_type_t ext
    on ph.exception_type_id = ext.exception_type_id
  left join c_emp_desc_t emp
    on ex.solve_emp = emp.emp_no
  left join c_alert_countermeasure_t mea
    on ex.solution_id = mea.solution_id
  left join c_exception_process_status_t status
    on ex.status = status.status_code
 where ex.line_name = [[line_name]] 
   and ph.phenomenon_code != '0' 
   and ex.occur_time >= sysdate - 1
   and ex.status = '5'
   and 1 = [[in24solve]]

union all

select ex.status status,
       ex.line_name LINE_NAME,
       basic.description EQUIPMENT_DESCRIPTION,
       TO_CHAR(ex.occur_time, 'YYYY/MM/DD HH24:MI:SS') OCCUR_TIME,
       NVL2(ex.phenomenon_id, ph.phenomenon_code, ex.phenomenon_code) PHENOMENON_CODE,
       /*ph.phenomenon_code PHENOMENON_CODE,*/
       ph.description PHENOMENON_DESCRIPTION,
       DECODE(ext.main_class, 'M', '設備', 'Q', '品質', 'P', '生產', '') TYPE,
       status.status_description STATUS_DESCRIPTION,
       ca.cause_description CAUSE_DESCRIPTION,
       mea.solution_description SOLUTION_DESCRIPTION, --處理對策
       emp.emp_name EMP_NAME,
       NVL2(ex.solve_time,
            to_char(ROUND((ex.solve_time - ex.occur_time) * 1440),
                    'FM999,999,999'),
            '') TIMELINESS
  from r_exception_main_t ex
  left join c_equipment_basic_t basic
    on ex.equipment_id = basic.equipment_id
  left join c_abnormal_phenomenon_t ph
    on ex.phenomenon_id = ph.phenomenon_id
  left join c_abnormal_cause_t ca
    on ex.reason_id = ca.reason_id
  left join c_exception_type_t ext
    on ph.exception_type_id = ext.exception_type_id
  left join c_emp_desc_t emp
    on ex.solve_emp = emp.emp_no
  left join c_alert_countermeasure_t mea
    on ex.solution_id = mea.solution_id
  left join c_exception_process_status_t status
    on ex.status = status.status_code
 where ex.line_name = [[line_name]] 
   and ph.phenomenon_code != '0' 
   and ex.occur_time >= sysdate - 1 
   and ex.status != '5'
   and 1 = [[in24noSolve]]

 order by occur_time desc, status asc

 --------------------------------------------
#warnOfProdLineDetail 

#warnOfProdLineRepeatDetail
 --------------------------------------------
select ex.line_name LINE_NAME,
       basic.description EQUIPMENT_DESCRIPTION,
       ph.phenomenon_code PHENOMENON_CODE,
       ph.description PHENOMENON_DESCRIPTION,
       (select to_char(count(1), 'FM999,999,999') || '次/180天'
          from r_exception_main_t ex_main     --統計記錄主檔表
         where ex_main.phenomenon_id = ex.phenomenon_id --該現象
           and ex_main.equipment_id = ex.equipment_id   --該設備
           and ex_main.occur_time >= sysdate - 180) DAYS_TIMES,
       TO_CHAR(ex.occur_time,'YYYY/MM/DD HH24:MI:SS') OCCUR_TIME,
       ex.reason_desc REASON_DESC,
       ex.solution_desc SOLUTION_DESC,
                   basic.equipment_code equipment_code,
       status.status_description STATUS_DESCRIPTION,
       substr(pat.prod_area_desc,0,INSTR(pat.prod_area_desc,'_',1,1)-1) factoryArea,
       pat.prod_area_desc producingZone,
       cei.TYPE_CODE,
       st.status,
       case when (jt.UUID) is null then 'empty' else jt.UUID end  URL_Link
  from r_exception_repeated_t ex 
 left join c_equipment_basic_t basic
    on ex.equipment_id = basic.equipment_id
left join c_abnormal_phenomenon_t ph
    on ex.phenomenon_id = ph.phenomenon_id
left join c_exception_process_status_t status
    on ex.status = status.status_code
left join ( select * from c_prod_area_line_t where delete_flag='0' ) cat 
    on cat.LINE_NAME = ex.line_name
left join (select * from sfcs.c_prod_area_t where  delete_flag='0') pat
    on pat.prod_area_id = cat.prod_area_id
left join C_EQUIP_TYPE_T cei 
    on cei.type_id = basic.type_id
left join (select EQUIPMENT_ID,STATUS from  r_equipment_basic_data_t order by COLLECT_DATE) st
    on basic.equipment_id = st.equipment_id
left join r_jarvis_community_exception_repeated_opening_t jt
    on jt.LINE_NAME = ex.line_name and cei.TYPE_CODE = jt.EQUIPMENT_TYPE and ph.phenomenon_code = jt.error_code
    where ex.line_name = [[line_name]]
order by ex.line_name, ex.occur_time desc

 --------------------------------------------
#warnOfProdLineRepeatDetail


#延誤分佈圖
 --------------------------------------------
select timeTable.timeNode,case rateTable.status 
       when 1 then '故障報警中'
       when 2 then '暫停'
       when 3 then '待機(無生產)'
       when 4 then '待料'
       when 5 then '產出滿料'
       else '無法連機' end describe,sum(rateTable.sumstatus) sumstatus from 
  (select trunc(sysdate-1,'hh')+level/6+1/6 timeNode
     from dual
   connect by level <= 6) timeTable
   left join
  (select trunc(end_point,'hh')+1/24 timeNode,de.status, count(de.status) sumstatus
  from R_Equipment_Status_Record_t de
  inner join R_Equipment_Interface_BOM_t bom 
  on de.interface_item_id=bom.interface_item_id and bom.valid='1' 
  where bom.equipment_id=cast( [[equipmentID]] as raw(16))  and end_point >= trunc(sysdate-1)
   and de.status<>0
  group by trunc(end_point,'hh')+1/24,de.status) rateTable
  on rateTable.timeNode <timeTable.timeNode and rateTable.timeNode >=timeTable.timeNode-1/6
  group by timeTable.timeNode,rateTable.status
  order by timeTable.timeNode
 --------------------------------------------
#延誤分佈圖


#延誤時長
 --------------------------------------------
select delay.delay_reason,sum(delay.delay_time) as long_time from R_DEMO_PRODUCT_DELAY_T delay
where delay.equipment_id=cast( [[equipmentID]] as raw(16))  group by delay.delay_reason
 --------------------------------------------
#延誤時長


#設備軟件版本信息
 --------------------------------------------
select ver.version from  R_Equipment_Interface_BOM_t ver where ver.equipment_id=cast( [[equipmentID]] as raw(16)) 
 --------------------------------------------
#設備軟件版本信息


#設備達成率
 --------------------------------------------
select nvl(rateTable.rate,0) as rate, timeTable.timeNode from 
  (select trunc(sysdate-1,'hh')+level/24+1/24 timeNode
     from dual
   connect by level < 25) timeTable
   left join
(select trunc(end_point,'hh')+1/24 timeNode,sum(pub.pass_qty*pcs.pcs_qty)*100/ceil(60*60/line.line_rate) rate 
from r_equipment_pub_param_record_t pub
inner join R_Equipment_Interface_BOM_t bom 
on pub.interface_item_id=bom.interface_item_id and bom.valid='1' 
inner join c_Equipment_Basic_t basic 
on bom.equipment_id=basic.equipment_id 
inner join R_DEMO_PROD_LINE_T line 
on line.line_name=basic.line_name
inner join  R_DEMO_EQUIPMENT_PCS_QTY_T pcs 
  on pcs.equipment_id=bom.equipment_id
  where basic.equipment_id=cast( [[equipmentID]] as raw(16))  and pub.end_point >= trunc(sysdate-1)
  group by trunc(end_point,'hh')+1/24,line.line_rate) rateTable
  on rateTable.timeNode=timeTable.timeNode
  order by timeTable.timeNode
 --------------------------------------------
#設備達成率

#getCurrentShiftTimeSlotByEchelon
 --------------------------------------------
 with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,
			section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,
            min(WORK_DATE||SECTION_FROM) over (partition by ECHELON_NAME,SHIFT) as min_from,
            max(WORK_DATE||SECTION_TO)   over (partition by ECHELON_NAME,SHIFT) as max_to
from (

select b.*,
 CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE)-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE)+1,'yyyyMMdd')
            ELSE  TO_CHAR((SYSDATE),'yyyyMMdd') END as WORK_DATE,
			 max(case when shift=cur_shift and section_from = cur_section_from then night_flag else '' end )   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
          from (
  SELECT ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,					
  --     CASE WHEN a.CUR_SHIFT='DAY' and a.shift='DAY' and a.SECTION_FROM<='24' then '' 												
  --                   when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM <='12' and a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'  	
  --                   when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM <='12' and a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
  --                   when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM >='17' and a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
  --                   when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM >='17' and a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'  							
  --                   WHEN a.CUR_SHIFT='DAY' and a.shift='NIGHT' AND a.SECTION_FROM <='12'  then 'B'	
  --                   WHEN a.CUR_SHIFT='DAY' and a.shift='NIGHT' AND a.SECTION_FROM >='17'  then 'F'	
  --                   ELSE '' end as NIGHT_FLAG
         CASE WHEN a.shift='DAY' and a.SECTION_FROM<='24' then '' 												
                     when a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'  	
                     when a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'  							
                     WHEN a.shift='NIGHT'   AND a.SECTION_FROM <='12'  then 'B'	
                     WHEN  a.shift='NIGHT'  AND a.SECTION_FROM >='17'  then 'F'	
                     ELSE '' end as NIGHT_FLAG
                    ,REST_from,REST_to
    --                 SN_BY_ECHELON,
    --         min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
   --          max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift
                                      												
   from (												
       SELECT E.ECHELON_NAME,												
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR((SYSDATE+10/24),'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,											
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,												
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,												
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR((SYSDATE),'HH24')>='0000' and  TO_CHAR((SYSDATE),'HH24') <='12' then  TO_CHAR((SYSDATE)-1,'YYYYMMDD') else  TO_CHAR((SYSDATE),'YYYYMMDD') end as CUR_DATE
         from (
         select ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,WORK_TIME,VALID,SET_EMP,SET_TIME
         ,case when work_time<duration and rest_to is null then to_char(to_date(TO_CHAR((SYSDATE),'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when work_time<duration and rest_to is null  then section_to else rest_to end rest_to
		
         from C_ECHELON_SECTION_T
         where ECHELON_NAME=[[EchelonName]]  and VALID = '0'
         ) E 												
           )  a
		  ) b
       ) d
      where 1=1 
    and cur_shift=shift 	
      order by section_from
)

 select * from (
  select a.* ,sys_connect_by_path(section_range,',') path
  from ( select t.*,
             min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
             max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift,
        --2018/07/20 if shift='日A' then from '24 Hour' 
            case when shift='日A' then ' 24 Hour'
			     else
					INITCAP(SHIFT) || '(' || SUBSTR(min_from, -4, 2) || ':' ||SUBSTR(min_from, -2, 2) || 
					'-' || SUBSTR(max_to, -4, 2) || ':' ||SUBSTR(max_to, -2, 2) || ')' 
				 End TimeRange,
                   SUM(ORI_WORK_TIME)over (partition by ECHELON_NAME,SHIFT )  WORK_TIME_by_shift,
        --2018/07/20 if shift='日A' then from '0800' 
            case when shift='日A' then SUBSTR(min_from,1, 8)||'0800' else  min_from end   as SECTION_FROM_By_shift,
        --2018/07/20 if shift='日A' then from '0800' 
        case when shift='日A' then to_char(to_date(SUBSTR(min_from,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0759' else  max_to end  
            as SECTION_TO_By_shift,
			 To_char(to_date(substr(min_from,1,8),'YYYYMMDD')-case when substr(min_from,1,8)=substr(max_to,1,8) then 1 else 0 end,'YYYYMMDD')||substr(max_to,9) SECTION_FROM_By_PRE_shift
         from DimOriCanlendar t )
         a
　start with  SN_BY_ECHELON=min_sn_by_shift 
  connect by  prior SN_BY_ECHELON = SN_BY_ECHELON-1
  ) where SN_BY_ECHELON=max_sn_by_shift
 --------------------------------------------
#getCurrentShiftTimeSlotByEchelon


#getCurrentShiftTimeSlotByLineNameStrNoUse
 --------------------------------------------
with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME,line_name order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,line_name,SHIFT,SECTION_FROM,SECTION_TO,
                                           section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,
            min(WORK_DATE||SECTION_FROM) over (partition by ECHELON_NAME,line_name,SHIFT) as min_from,
            max(WORK_DATE||SECTION_TO)   over (partition by ECHELON_NAME,line_name,SHIFT) as max_to
           
from (
select b.*,
CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE)-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE)+1,'yyyyMMdd')
            ELSE  TO_CHAR((SYSDATE),'yyyyMMdd') END as WORK_DATE,
                                           max(case when shift=cur_shift and section_from = cur_section_from then night_flag else '' end )   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
          from (
  SELECT line_name,ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,                                                             

         CASE WHEN a.shift='DAY' and a.SECTION_FROM<='24' then ''                                                                                                                                                                          
                     when a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'                
                     when a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'                                                                                                       
                     WHEN a.shift='NIGHT'   AND a.SECTION_FROM <='12'  then 'B'              
                     WHEN  a.shift='NIGHT'  AND a.SECTION_FROM >='17'  then 'F'              
                     ELSE '' end as NIGHT_FLAG
                    ,REST_from,REST_to

                                                                                                                                                                                                          
   from (                                                                                                                                                              
       SELECT E.line_name,E.ECHELON_NAME,                                                                                                                                                                     
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR((SYSDATE+10/24),'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,                                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,                                                                                                                                                                             
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR((SYSDATE),'HH24')>='0000' and  TO_CHAR((SYSDATE),'HH24') <='12' then  TO_CHAR((SYSDATE)-1,'YYYYMMDD') else  TO_CHAR((SYSDATE),'YYYYMMDD') end as CUR_DATE
         from (
         select b.line_name,a.ECHELON_NAME,a.SHIFT,a.SECTION_FROM,a.SECTION_TO,a.DURATION,a.WORK_TIME,a.VALID,a.SET_EMP,a.SET_TIME
         ,case when a.work_time<duration and rest_to is null then to_char(to_date(TO_CHAR((SYSDATE),'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when a.work_time<duration and rest_to is null  then section_to else rest_to end rest_to
         from (select * from C_ECHELON_SECTION_T where VALID = '0') a inner join (select * from  C_LINE_ECHELON_T where line_name in ([[lineNameStr]])) b
         on a.ECHELON_name=b.ECHELON_name 
         ) E                                                                                                                                                                              
           )  a
                               ) b
       ) d
      where 1=1 
    and cur_shift=shift      
      order by section_from
)

select * from (
  select a.* ,sys_connect_by_path(section_range,',') path
  from ( select t.*,
             min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
             max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift,
            case when shift='日A' then ' 24 Hour'
                                                else
                                                                        INITCAP(SHIFT) || '(' || SUBSTR(min_from, -4, 2) || ':' ||SUBSTR(min_from, -2, 2) || 
                                                                        '-' || SUBSTR(max_to, -4, 2) || ':' ||SUBSTR(max_to, -2, 2) || ')' 
                                                           End TimeRange,
                   SUM(ORI_WORK_TIME)over (partition by ECHELON_NAME,SHIFT )  WORK_TIME_by_shift,
            case when shift='日A' then SUBSTR(min_from,1, 8)||'0800' else  min_from end   as SECTION_FROM_By_shift,
        case when shift='日A' then to_char(to_date(SUBSTR(min_from,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0759' else  max_to end  
            as SECTION_TO_By_shift,
                                           To_char(to_date(substr(min_from,1,8),'YYYYMMDD')-case when substr(min_from,1,8)=substr(max_to,1,8) then 1 else 0 end,'YYYYMMDD')||substr(max_to,9) SECTION_FROM_By_PRE_shift
         from DimOriCanlendar t )
         a
　start with  SN_BY_ECHELON=min_sn_by_shift 
  connect by  prior SN_BY_ECHELON = SN_BY_ECHELON-1 
  and prior line_name=line_name  
  ) where SN_BY_ECHELON=max_sn_by_shift
 --------------------------------------------
#getCurrentShiftTimeSlotByLineNameStrNoUse


#getCurrentShiftTimeSlotByLineNameStr--old
 --------------------------------------------
with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME,line_name order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,line_name,SHIFT,SECTION_FROM,SECTION_TO,
                                           section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,
            min(WORK_DATE||SECTION_FROM) over (partition by ECHELON_NAME,line_name,SHIFT) as min_from,
            max(WORK_DATE||SECTION_TO)   over (partition by ECHELON_NAME,line_name,SHIFT) as max_to
           
from (
select b.*,
CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE)-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE)+1,'yyyyMMdd')
            ELSE  TO_CHAR((SYSDATE),'yyyyMMdd') END as WORK_DATE,
                                           max(case when shift=cur_shift and section_from = cur_section_from then night_flag else '' end )   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
          from (
  SELECT line_name,ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,                                                             

         CASE WHEN a.shift='DAY' and a.SECTION_FROM<='24' then ''                                                                                                                                                                          
                     when a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'                
                     when a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'                                                                                                       
                     WHEN a.shift='NIGHT'   AND a.SECTION_FROM <='12'  then 'B'              
                     WHEN  a.shift='NIGHT'  AND a.SECTION_FROM >='17'  then 'F'              
                     ELSE '' end as NIGHT_FLAG
                    ,REST_from,REST_to

                                                                                                                                                                                                          
   from (                                                                                                                                                              
       SELECT E.line_name,E.ECHELON_NAME,                                                                                                                                                                     
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR((SYSDATE+10/24),'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,                                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,                                                                                                                                                                             
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR((SYSDATE),'HH24')>='0000' and  TO_CHAR((SYSDATE),'HH24') <='12' then  TO_CHAR((SYSDATE)-1,'YYYYMMDD') else  TO_CHAR((SYSDATE),'YYYYMMDD') end as CUR_DATE
         from (
         select b.line_name,a.ECHELON_NAME,a.SHIFT,a.SECTION_FROM,a.SECTION_TO,a.DURATION,a.WORK_TIME,a.VALID,a.SET_EMP,a.SET_TIME
         ,case when a.work_time<duration and rest_to is null then to_char(to_date(TO_CHAR((SYSDATE),'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when a.work_time<duration and rest_to is null  then section_to else rest_to end rest_to
         from (select * from C_ECHELON_SECTION_T where VALID = '0') a inner join (select * from  C_LINE_ECHELON_T where line_name in ([[lineNameStr]])) b
         on a.ECHELON_name=b.ECHELON_name 
         ) E                                                                                                                                                                              
           )  a
                               ) b
       ) d
      where 1=1 
    and cur_shift=shift      
      order by section_from
)



select * from (
  select a.* ,sys_connect_by_path(section_range,',') path
  from ( select t.*,
             min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
             max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift,
            case when shift='日A' then ' 24 Hour'
                                                else
                                                                        INITCAP(SHIFT) || '(' || SUBSTR(min_from, -4, 2) || ':' ||SUBSTR(min_from, -2, 2) || 
                                                                        '-' || SUBSTR(max_to, -4, 2) || ':' ||SUBSTR(max_to, -2, 2) || ')' 
                                                           End TimeRange,
                   SUM(ORI_WORK_TIME)over (partition by ECHELON_NAME,SHIFT )  WORK_TIME_by_shift,
            case when shift='日A' then SUBSTR(min_from,1, 8)||'0800' else  min_from end   as SECTION_FROM_By_shift,
        case when shift='日A' then to_char(to_date(SUBSTR(min_from,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0759' else  max_to end  
            as SECTION_TO_By_shift,
                                           To_char(to_date(substr(min_from,1,8),'YYYYMMDD')-case when substr(min_from,1,8)=substr(max_to,1,8) then 1 else 0 end,'YYYYMMDD')||substr(max_to,9) SECTION_FROM_By_PRE_shift
         from DimOriCanlendar t )
         a
　start with  SN_BY_ECHELON=min_sn_by_shift 
  connect by  prior SN_BY_ECHELON = SN_BY_ECHELON-1 
  and prior line_name=line_name  
  ) where SN_BY_ECHELON=max_sn_by_shift

 --------------------------------------------
#getCurrentShiftTimeSlotByLineNameStr--old


#getCurrentShiftTimeSlotByLineName
 --------------------------------------------
with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME,line_name order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,line_name,SHIFT,SECTION_FROM,SECTION_TO,
                                           section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,
            min(WORK_DATE||SECTION_FROM) over (partition by ECHELON_NAME,line_name,SHIFT) as min_from,
            max(WORK_DATE||SECTION_TO)   over (partition by ECHELON_NAME,line_name,SHIFT) as max_to
           
from (
select b.*,
CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE)-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE)+1,'yyyyMMdd')
            ELSE  TO_CHAR((SYSDATE),'yyyyMMdd') END as WORK_DATE,
                                           max(case when shift=cur_shift and section_from = cur_section_from then night_flag else '' end )   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
          from (
  SELECT line_name,ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,                                                             

         CASE WHEN a.shift='DAY' and a.SECTION_FROM<='24' then ''                                                                                                                                                                          
                     when a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'                
                     when a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'                                                                                                       
                     WHEN a.shift='NIGHT'   AND a.SECTION_FROM <='12'  then 'B'              
                     WHEN  a.shift='NIGHT'  AND a.SECTION_FROM >='17'  then 'F'              
                     ELSE '' end as NIGHT_FLAG
                    ,REST_from,REST_to

                                                                                                                                                                                                          
   from (                                                                                                                                                              
       SELECT E.line_name,E.ECHELON_NAME,                                                                                                                                                                     
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR((SYSDATE+10/24),'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,                                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,                                                                                                                                                                             
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR((SYSDATE),'HH24')>='0000' and  TO_CHAR((SYSDATE),'HH24') <='12' then  TO_CHAR((SYSDATE)-1,'YYYYMMDD') else  TO_CHAR((SYSDATE),'YYYYMMDD') end as CUR_DATE
         from (
         select b.line_name,a.ECHELON_NAME,a.SHIFT,a.SECTION_FROM,a.SECTION_TO,a.DURATION,a.WORK_TIME,a.VALID,a.SET_EMP,a.SET_TIME
         ,case when a.work_time<duration and rest_to is null then to_char(to_date(TO_CHAR((SYSDATE),'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when a.work_time<duration and rest_to is null  then section_to else rest_to end rest_to
         from (select * from C_ECHELON_SECTION_T where VALID = '0') a inner join (select * from  C_LINE_ECHELON_T where line_name in ([[lineNameStr]])) b
         on a.ECHELON_name=b.ECHELON_name 
         ) E                                                                                                                                                                              
           )  a
      ) b
       ) d
      where 1=1      
    order by section_from
)

SELECT WORK_DATE,SN_BY_ECHELON,ECHELON_NAME,LINE_NAME,SHIFT,SECTION_FROM,SECTION_TO,SECTION_RANGE,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,MIN_FROM,MAX_TO,MIN_SN_BY_SHIFT,MAX_SN_BY_SHIFT,PRE_TIMERANGE,TIMERANGE,WORK_TIME_BY_SHIFT,SECTION_FROM_BY_SHIFT,SECTION_TO_BY_SHIFT,SECTION_FROM_BY_PRE_SHIFT,PATH from (
select t.*,max(case when cur_shift=shift then '' else TimeRange   end) over (partition by line_name) as pre_TimeRange
from (
  select a.* ,sys_connect_by_path(section_range,',') path
  from ( select t.*,
             min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
             max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift,
            case when shift='日A' then ' 24 Hour'
                                                else
                                                                        INITCAP(SHIFT) || '(' || SUBSTR(min_from, -4, 2) || ':' ||SUBSTR(min_from, -2, 2) || 
                                                                        '-' || SUBSTR(max_to, -4, 2) || ':' ||SUBSTR(max_to, -2, 2) || ')' 
                                                           End TimeRange,                                                          
                   SUM(ORI_WORK_TIME)over (partition by ECHELON_NAME,SHIFT )  WORK_TIME_by_shift,
            case when shift='日A' then SUBSTR(min_from,1, 8)||'0800' else  min_from end   as SECTION_FROM_By_shift,
        case when shift='日A' then to_char(to_date(SUBSTR(min_from,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0759' else  max_to end  
            as SECTION_TO_By_shift, To_char(to_date(substr(min_from,1,8),'YYYYMMDD')-case when substr(min_from,1,8)=substr(max_to,1,8) then 1 else 0 end,'YYYYMMDD')||substr(max_to,9) SECTION_FROM_By_PRE_shift
         from DimOriCanlendar t )
         a
　start with  SN_BY_ECHELON=min_sn_by_shift 
  connect by  prior SN_BY_ECHELON = SN_BY_ECHELON-1 
  and prior line_name=line_name  
    and prior shift=shift 
  ) t
 where SN_BY_ECHELON=max_sn_by_shift
) where cur_shift=shift  
 --------------------------------------------
#getCurrentShiftTimeSlotByLineName




#getCurrentShftTimeSlotByEchelonOld
---------------------------------------------
with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,MIN_FROM,MAX_TO,CUR_NIGHT_FLAG
from (

select b.*,
 CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR(SYSDATE-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR(SYSDATE,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR(SYSDATE,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR(SYSDATE+1,'yyyyMMdd')
            ELSE  TO_CHAR(SYSDATE,'yyyyMMdd') END as WORK_DATE,
min(SECTION_FROM) over (partition by ECHELON_NAME,SHIFT,nvl(night_flag,'')) as min_from,
             max(SECTION_TO)   over (partition by ECHELON_NAME,SHIFT,nvl(night_flag,'')) as max_to,
			 max(nvl(night_flag,''))   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
          from (
  SELECT ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,					
       CASE WHEN a.CUR_SHIFT='DAY' and a.shift='DAY' and a.SECTION_FROM<='24' then '' 												
                     when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM <='12' and a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'  	
                     when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM <='12' and a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM >='17' and a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when a.CUR_SHIFT='NIGHT'  and  a.CUR_SECTION_FROM >='17' and a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'  							
                     WHEN a.CUR_SHIFT='DAY' and a.shift='NIGHT' AND a.SECTION_FROM <='12'  then 'B'	
                     WHEN a.CUR_SHIFT='DAY' and a.shift='NIGHT' AND a.SECTION_FROM >='17'  then 'F'	
                     ELSE '' end as NIGHT_FLAG,REST_from,REST_to
    --                 SN_BY_ECHELON,
    --         min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
   --          max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift
                                      												
   from (												
       SELECT E.ECHELON_NAME,												
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR(SYSDATE,'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,											
            max(case when E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,												
            max(case when E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,												
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR(SYSDATE,'HH24')>='0000' and  TO_CHAR(SYSDATE,'HH24') <='12' then  TO_CHAR(SYSDATE-1,'YYYYMMDD') else  TO_CHAR(SYSDATE,'YYYYMMDD') end as CUR_DATE
         from (
         select ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,WORK_TIME,VALID,SET_EMP,SET_TIME
         ,case when work_time<duration and rest_to is null then to_char(to_date(TO_CHAR(SYSDATE,'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when work_time<duration and rest_to is null  then section_to else rest_to end rest_to
		
         from C_ECHELON_SECTION_T
         where ECHELON_NAME=[[EchelonName]]  and VALID = '0'
         ) E 												
           )  a
		  ) b
       ) d
      where 1=1 
      and cur_shift=shift 	
      order by section_from
)


 select * from (
  select a.* ,sys_connect_by_path(section_range,',') path
  from ( select t.*,
             min(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT) as min_sn_by_shift,
             max(SN_BY_ECHELON) over (partition by ECHELON_NAME,SHIFT ) as max_sn_by_shift,
            INITCAP(SHIFT) || '(' || SUBSTR(min_from, -4, 2) || ':' ||SUBSTR(min_from, -2, 2) || 
            '-' || SUBSTR(max_to, -4, 2) || ':' ||SUBSTR(max_to, -2, 2) || ')' TimeRange,
                   SUM(ORI_WORK_TIME)over (partition by ECHELON_NAME,SHIFT )  WORK_TIME_by_shift,
             min(work_date) over (partition by ECHELON_NAME,SHIFT )||min_from   as SECTION_FROM_By_shift,
             min(work_date) over (partition by ECHELON_NAME,SHIFT )||max_to   as SECTION_TO_By_shift
         from DimOriCanlendar t )
         a
　start with  SN_BY_ECHELON=min_sn_by_shift 
  connect by  prior SN_BY_ECHELON = SN_BY_ECHELON-1
  ) where SN_BY_ECHELON=max_sn_by_shift
---------------------------------------------
#getCurrentShftTimeSlotByEchelonOld

--main line
#getPivotForProdArchiveRate
 --------------------------------------------
with factHourlySum as (
select line_name,process_name,
             section_range ,     
                 sum(real_qty) real_qty,
                  round(decode(AVG(work_time)*60,0,0,SUM(real_qty*line_rate)/ (AVG(work_time)*60)),4) as capacity,
                 case when round(decode(AVG(work_time)*60,0,0,AVG(real_qty*line_rate)/ (AVG(work_time)*60)),4)=0 then 0 else
                 to_number(trunc(sum(real_qty)/decode(AVG(work_time)*60,0,0,sum(real_qty*line_rate)/ (AVG(work_time)*60)))) end  plan_qty,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 case when  section_range is not null then '1' else '2' end as odr
                 from R_PQM_DAILY_SUM_T 
     
                 where ( work_date in (CASE WHEN [[nightFlagStr]]='F' THEN  TO_CHAR(SYSDATE+1,'yyyyMMdd') 
				                          WHEN [[nightFlagStr]]='B' THEN  TO_CHAR(SYSDATE-1,'yyyyMMdd') 
										  ELSE TO_CHAR(SYSDATE,'yyyyMMdd')
										  END  ) 
                        or 
						 work_date in TO_CHAR(SYSDATE,'yyyyMMdd') 
						 )
				 and Substr(SECTION_RANGE,1,2) >=   case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT' and  [[nightFlagStr]]='B'   then '17' 
                                                   when work_date= TO_CHAR(SYSDATE,'yyyyMMdd') and shift='NIGHT' and  [[nightFlagStr]]='F'  then '17'
                                                   else '00' end 		 
                -- and Substr(SECTION_RANGE,1,2) >= case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT'  then '17' else '00' end
				 and line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] 
				 and echelon_name in (<<echelon_name>>) and state>=0
				and process_name in (<<processNameStr>>) 
                -- group by line_name,process_name,section_range 
                --and line_name in ('P11','P10')/*('APPLE-N5','APPLE-N6')*/
                --and shift='DAY' and echelon_name='PC(NEW6)' and state>=0
				--and process_name in ('前段投入') 
                      group by line_name,process_name,section_range
),
factunpivot as (
select  LINE_NAME,PROCESS_NAME,SECTION_RANGE,SAFE_RATE,ALERT_RATE,QTY_TYPE,QTY_VALUE
from   ( select LINE_NAME,PROCESS_NAME,SECTION_RANGE,PLAN_QTY,REAL_QTY,CAPACITY,SAFE_RATE,ALERT_RATE,ODR
         from   factHourlySum
         union all
         select LINE_NAME,PROCESS_NAME,'ALL',sum(PLAN_QTY)as PLAN_QTY,sum(REAL_QTY) as REAL_QTY,case when sum(PLAN_QTY)>0 then round(sum(REAL_QTY)/sum(PLAN_QTY),4) else 0 end as CAPACITY,
         max(SAFE_RATE) as SAFE_RATE,max(ALERT_RATE) as ALERT_RATE,'2' ODR
         from   factHourlySum
         group by  LINE_NAME,PROCESS_NAME
       )
       unpivot
       ( Qty_value
         for qty_type in (PLAN_QTY, REAL_QTY,Capacity)
       )
  )

SELECT * FROM
   (
       SELECT LINE_NAME,PROCESS_NAME,SECTION_RANGE,QTY_TYPE,QTY_VALUE,SAFE_RATE,ALERT_RATE
       FROM factunpivot 
   )
   PIVOT
   (
       sum(QTY_VALUE)                                                                -- Multiple Aggregate Functions
        FOR (section_range) IN (<<timeSlotStr>>)    -- Multiple Pivot Columns
   )
 ORDER BY  line_name,process_name,CASE WHEN QTY_TYPE='CAPACITY' THEN 3
                                       WHEN QTY_TYPE='REAL_QTY' THEN 2
                                        else 1 end             

 --------------------------------------------
#getPivotForProdArchiveRate

--smt line 2019/3/12
#getSMTPivotForProdArchiveRate
 --------------------------------------------
with factHourlySum as (
select line_name,
             section_range ,     
                 sum(real_qty) real_qty,
                  round(decode(AVG(work_time)*60,0,0,SUM(real_qty*line_rate)/ (AVG(work_time)*60)),4) as capacity,
                 case when round(decode(AVG(work_time)*60,0,0,AVG(real_qty*line_rate)/ (AVG(work_time)*60)),4)=0 then 0 else
                 to_number(trunc(sum(real_qty)/decode(AVG(work_time)*60,0,0,sum(real_qty*line_rate)/ (AVG(work_time)*60)))) end  plan_qty,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 case when  section_range is not null then '1' else '2' end as odr
                 from r_pqm_daily_sum_smt_t 
                 where ( work_date in (CASE WHEN [[nightFlagStr]]='F' THEN  TO_CHAR(SYSDATE+1,'yyyyMMdd') 
				                          WHEN [[nightFlagStr]]='B' THEN  TO_CHAR(SYSDATE-1,'yyyyMMdd') 
										  ELSE TO_CHAR(SYSDATE,'yyyyMMdd')
										  END  ) 
                        or 
						 work_date in TO_CHAR(SYSDATE,'yyyyMMdd') 
						 )
				 and Substr(SECTION_RANGE,1,2) >=   case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT' and  [[nightFlagStr]]='B'   then '17' 
                                                   when work_date= TO_CHAR(SYSDATE,'yyyyMMdd') and shift='NIGHT' and  [[nightFlagStr]]='F'  then '17'
                                                   else '00' end 		 
				 and line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] 
				 and echelon_name in (<<echelon_name>>) and state>=0
                group by line_name,section_range
),
factunpivot as (
select  LINE_NAME,SECTION_RANGE,SAFE_RATE,ALERT_RATE,QTY_TYPE,QTY_VALUE
from   ( select LINE_NAME,SECTION_RANGE,PLAN_QTY,REAL_QTY,CAPACITY,SAFE_RATE,ALERT_RATE,ODR
         from   factHourlySum
         union all
         select LINE_NAME,'ALL',sum(PLAN_QTY)as PLAN_QTY,sum(REAL_QTY) as REAL_QTY,case when sum(PLAN_QTY)>0 then round(sum(REAL_QTY)/sum(PLAN_QTY),4) else 0 end as CAPACITY,
         max(SAFE_RATE) as SAFE_RATE,max(ALERT_RATE) as ALERT_RATE,'2' ODR
         from   factHourlySum
         group by  LINE_NAME
       )
       unpivot
       ( Qty_value
         for qty_type in (PLAN_QTY, REAL_QTY,Capacity)
       )
  )

SELECT * FROM
   (
       SELECT LINE_NAME,SECTION_RANGE,QTY_TYPE,QTY_VALUE,SAFE_RATE,ALERT_RATE
       FROM factunpivot 
   )
   PIVOT
   (
       sum(QTY_VALUE)       -- Multiple Aggregate Functions
        FOR (section_range) IN (<<timeSlotStr>>)    -- Multiple Pivot Columns
   )
 ORDER BY  line_name,CASE WHEN QTY_TYPE='CAPACITY' THEN 3
                          WHEN QTY_TYPE='REAL_QTY' THEN 2
                          else 1 end                
 --------------------------------------------
#getSMTPivotForProdArchiveRate

#getPandQOverviewAll
 --------------------------------------------
 with DimLine as (
     select  a.LINE_NAME,a.PROD_AREA_ID,a.CREATE_DATE,a.CREATE_EMP,a.DELETE_FLAG,b.prod_area_desc,
             NVL(c.LINE_STYLE,'ASSEMBLY') LINE_STYLE,c.automation_flag,CASE wHEN c.automation_flag=0 then '人工線' else '自動化線' end as Line_Category,d.ARCHIVER_LOWWARNING,d.ARCHIVER_LOWLIMIT,LINE_STYLE as ORI_LINE_STYLE,
            d.Yieldr_Lowwarning, d.yieldr_lowlimit

     from ( select * from c_prod_area_line_t where delete_flag='0' ) a inner join (select * from sfcs.c_prod_area_t where  delete_flag='0') b on a.PROD_AREA_ID=b.PROD_AREA_ID 
     inner join  C_LINE_DESC_T c on a.LINE_NAME=c.line_name
     left join C_LINE_CT_RUNR_PASSR_ALERT_T d on a.PROD_AREA_ID=d.PROD_AREA_ID and a.line_name=d.line_name
     WHERE 1=1 
     and a.PROD_AREA_ID =  [[prod_area_id]]
	 --By Line: and a.line_name=#line_name
),
DimCanlendar as (
  SELECT Factory_DATE,a.LINE_NAME,LINE_TYPE,ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM                    												
   from (												
       SELECT  L.LINE_NAME, l.LINE_TYPE,E.ECHELON_NAME,												
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration,TO_CHAR(SYSDATE,'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,											
            max(case when E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  L.LINE_NAME, l.LINE_TYPE,E.ECHELON_NAME) as CUR_SHIFT,												
            max(case when E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  L.LINE_NAME, l.LINE_TYPE,E.ECHELON_NAME) as CUR_SECTION_FROM,												
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR(SYSDATE,'HH24MI') AND TO_CHAR(SYSDATE,'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR(SYSDATE,'HH24')>='0000' and  TO_CHAR(SYSDATE,'HH24') <='1200' then  TO_CHAR(SYSDATE-1,'YYYYMMDD') else  TO_CHAR(SYSDATE,'YYYYMMDD') end as Factory_DATE
          From C_LINE_ECHELON_T L												
         INNER JOIN C_ECHELON_SECTION_T E ON E.ECHELON_NAME = L.ECHELON_NAME 												
         WHERE 1=1
           --By Line:and l.line_name =#line_name												
           and l.line_name in (select line_name from DimLine)	
           AND E.VALID = '0'																										
           )  a		
),
dimMatrix as (
select b.factory_date,b.cur_shift,a.*
from DimLine a ,(select distinct factory_date,cur_shift,line_name from DimCanlendar) b
where a.line_name=b.line_name
),
fact as (
  SELECT SUMM.WORK_DATE,SUMM.LINE_NAME,SUMM.SHIFT,ROUND(AVG(CAPACITY), 3) CAPACITY, MIN(YIELD) YIELD
  FROM R_PQM_SUMMARY_T SUMM
  WHERE  SUMM.WORK_DATE in (select factory_date from dimMatrix ) --減1
  GROUP BY SUMM.WORK_DATE,SUMM.SHIFT,SUMM.LINE_NAME
  UNION ALL
  SELECT SUMM.WORK_DATE,SUMM.LINE_NAME,SUMM.SHIFT,ROUND(AVG(CAPACITY), 3) CAPACITY, MIN(YIELD) YIELD
  FROM R_PQM_SUMMARY_SMT_T SUMM
  WHERE  SUMM.WORK_DATE in (select factory_date from dimMatrix ) --減1
  GROUP BY SUMM.WORK_DATE,SUMM.SHIFT,SUMM.LINE_NAME
)
select a.*,b.CAPACITY,YIELD,a.line_name as import_line,b.line_name as open_line
from dimMatrix a left join  fact b
on a.line_name=b.line_name
and a.factory_date=b.work_date
and a.cur_shift=b.shift
order by a.line_name
 --------------------------------------------
#getPandQOverviewAll

#getStationManageFallCountByHour
--------------------------------------------
 SELECT to_char(tdate.serialtime, 'hh24:mi') hour,
       nvl(fail_per, '0') fail_count
  FROM (SELECT TRUNC(to_date([[beginTime]],
                             'YYYYMMDDhh24miss') + (LEVEL - 1) / 24,
                     'hh24') serialtime
          FROM DUAL
        CONNECT BY LEVEL <=
                   (to_date([[endTime]],
                            'YYYYMMDDhh24miss') -
                   to_date([[beginTime]] ,
                            'YYYYMMDDhh24miss')) * 24 + 1) tdate
  left join (SELECT to_date(scnt.hour || '00', 'YYYYMMDDhh24mi') hour,
                    to_char(sum(nvl(fcnt.fail_cnt, 0) )) fail_per
               FROM (SELECT to_char(sd.in_station_time, 'YYYYMMDDhh24') hour,
                            count(1) cnt
                       FROM r_sn_detail_t sd
                      where sd.line_name = [[lineName]]
                        and sd.station_name = [[stationName]]
                        and sd.in_station_time >=
                            to_date([[beginTime]],
                                    'YYYYMMDDhh24miss')
                        and sd.in_station_time <
                            to_date([[endTime]] ,
                                    'YYYYMMDDhh24miss')
                      group by to_char(sd.in_station_time, 'YYYYMMDDhh24')
                      order by to_char(sd.in_station_time, 'YYYYMMDDhh24')) scnt
               left join (SELECT to_char(test_time, 'YYYYMMDDhh24') hour,
                                count(0) fail_cnt
                           FROM r_repair_t re
                          where test_line = [[lineName]]
                            and test_station = [[stationName]] 
                            and test_time >=
                                to_date([[beginTime]],
                                        'YYYYMMDDhh24miss')
                            and test_time <
                                to_date([[endTime]],
                                        'YYYYMMDDhh24miss')
                          and  
               exists ( --抓取首次pass的序號信息
                select 0
                  from (select serial_number,
                                test_group,
                                min(test_time) test_time
                           from r_repair_t r1
                          where r1.serial_number = re.serial_number
                            and r1.test_group = re.test_group
                          group by serial_number, test_group) rr
                 where rr.serial_number = re.serial_number
                   and rr.test_group = re.test_group
                   and re.test_time = rr.test_time)
           and not exists --排除本次時間範圍內二次不良的序號
         (SELECT 0
                  FROM r_repair_t r2
                 where r2.serial_number = re.serial_number
                   and r2.test_group = re.test_group
                   and r2.test_time < to_date([[beginTime]],'YYYYMMDDhh24miss'))
           and not exists --排除首次pass回流fail的序號
         (SELECT 0
                  FROM R_SN_DETAIL_T r3
                 where r3.serial_number = re.serial_number
                   and r3.group_name = re.test_group
                   and r3.error_flag = 0
                   and r3.in_station_time < re.test_time)

                          group by to_char(test_time, 'YYYYMMDDhh24')
                          order by to_char(test_time, 'YYYYMMDDhh24')) fcnt
                 on fcnt.hour = scnt.hour
             		group by scnt.hour
            ) fdata
    on fdata.hour = tdate.serialtime
 where tdate.serialtime <
       to_date([[endTime]], 'YYYYMMDDhh24miss')
 order by tdate.serialtime
--------------------------------------------
#getStationManageFallCountByHour

#getChangeProdutionLine
 --------------------------------------------
with DimLine as (
     select  a.LINE_NAME,a.PROD_AREA_ID,a.CREATE_DATE,a.CREATE_EMP,a.DELETE_FLAG,b.prod_area_desc,
             NVL(c.LINE_STYLE,'ASSEMBLY') LINE_STYLE,c.automation_flag,CASE wHEN c.automation_flag=0 then '人工線' else '自動化線' end as Line_Category,d.ARCHIVER_LOWWARNING,d.ARCHIVER_LOWLIMIT,LINE_STYLE as ORI_LINE_STYLE
     from  ( select * from c_prod_area_line_t where delete_flag='0' ) a inner join ( Select * from SFCS.C_PROD_AREA_T  where PROD_AREA_ID =  [[prod_area_id]] and  delete_flag='0' ) b on a.PROD_AREA_ID=b.PROD_AREA_ID 
     inner join   C_LINE_DESC_T c on a.LINE_NAME=c.line_name
     left join  C_LINE_CT_RUNR_PASSR_ALERT_T d on a.PROD_AREA_ID=d.PROD_AREA_ID and a.line_name=d.line_name
     WHERE 1=1
	 and a.line_name in (<<lineStr>>)
     and b.factory = [[factory]]
)
,DimLimeWithPart as (
  select E.PROD_AREA_ID,E.prod_area_desc,PR.LINE_NAME,PR.MO_NUMBER,PR.MODEL_NAME,
   NVL(B.START_DATE, TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYYMMDD') || ' ' || A.PLN_STAT_TIME, 'yyyymmdd hh24:mi:ss')) S_DATE,
   TO_CHAR(B.SCHL_QTY, 'FM999,999,999') SCHL_QTY,ALART_FLAG,
                               DECODE(ALART_FLAG,
                                    1,
                                    TO_CHAR(CONFIRM_TIME, 'hh24:mi'),
                                    TO_CHAR(NVL(B.START_DATE, TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYYMMDD') || ' ' ||
                               A.PLN_STAT_TIME,
                               'yyyymmdd hh24:mi:ss')) - P.ALART_TIME / 1440, 'hh24:mi') 
                               ) Warnning_time,p.*
    FROM (select * from R_PQM_LINE_PREPARE_OP_T where opcode in (<<opcode>>) )PR
              INNER JOIN C_PQM_PART_OP_T P
                 ON PR.PART_TYPE = P.PART_TYPE
                AND PR.OPCODE = P.OPCODE
              INNER JOIN ( select * from R_SCHEDULE_SAP_T 
                           where LINE in (<<lineStr>>) 
                           AND TO_DATE(TO_CHAR(PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS') BETWEEN SYSDATE - 30 AND SYSDATE + 7
                           ) A
                 ON PR.LINE_NAME = A.LINE
                AND PR.OPCODE = A.VORNR
                  INNER JOIN (select * from R_SCHEDULE_SFCS_T where FLAG = 0) B
                 ON A.SCHL_NO = B.SCHL_NO
                AND PR.MO_NUMBER = B.SFCS_MO
                AND PR.MODEL_NAME = B.SFCS_MODEL
                inner join DimLine E
                on PR.LINE_NAME =E.line_name
) 
,
fact as (
select a.*,
       to_char((CASE
                 WHEN ROUND((S_DATE - SYSDATE) * 24 * 60) < 0 THEN
                  0
                 ELSE
                  ROUND((S_DATE - SYSDATE) * 24 * 60)
               END),
               'FM999,999,999') || 'm/' ||
           (CASE
                 WHEN ROUND((S_DATE - SYSDATE) * 24 * 60) < 0 THEN
                  0
                 ELSE
                  ROUND((S_DATE - SYSDATE) * 24, 1)
               END) || 'h' LEFT_TIME
from DimLimeWithPart a
--where mo_number='2231809290'
) 
--select * from fact
SELECT * FROM
   (
       SELECT  PROD_AREA_ID,PROD_AREA_DESC,LINE_NAME as line,MO_NUMBER as SFCS_MO,MODEL_NAME as SFCS_MODEL,S_DATE,SCHL_QTY,OPCODE as CPCODE,PART_TYPE,ALART_FLAG,Warnning_time
       --PRE_TIME,ALART_TIME,
       FROM fact 
   )
   PIVOT
   (
       MAX(case when ALART_FLAG || Warnning_time is null then '' else ALART_FLAG||Warnning_time end)
       --,                     -- Multiple Aggregate Functions
       --MAX(ALART_FLAG  )  
       FOR (PART_TYPE) IN (<<changeLineItems>> )   -- Multiple Pivot Columns
   )
   ORDER BY    S_DATE, LINE, CPCODE, SFCS_MO DESC  
 --------------------------------------------
#getChangeProdutionLine


#request_material_board_detail_new2
 --------------------------------------------
SELECT T.MO_NUMBER,
T.KB_FLAG, 
       DECODE(T.TASK_TYPE, 'M', '主線叫料', '主線叫板') as TYPE_NAME,
       T.PART_NO, 
       T.LOCATION_NAME,
       B.QPA,
       T.LEFT_QTY, 
	   T.PICK_QTY,
       T.NEED_QTY, 
       T.SEND_QTY, 
       to_char(T.STOP_TIME, 'MM-dd HH24:MI:ss') as STOP_TIME, 
       to_char(T.AGV_END_TIME,'MM-dd HH24:MI:ss') as AGV_END_TIME, 
       T.STORAGE_QTY, 
       T.AGV_ID, 
       (CASE
         WHEN T.PN_STATUS = '0' THEN
          '無叫料請求'
         WHEN T.PN_STATUS = '1' THEN
          '已叫料，未備料' 
         WHEN T.PN_STATUS = '2' THEN
          '工單材料已發完'
         WHEN T.PN_STATUS = '3' THEN
          '備料中，未叫車'
         WHEN T.PN_STATUS = '4' THEN
          '備料完，已叫車'
         WHEN T.PN_STATUS = '5' THEN
          'DOD指派任務中'
         WHEN T.PN_STATUS = '6' THEN
          'AGV運送中' || ' (任務編號:'||T.MISSION_ID||')'
         WHEN T.PN_STATUS = '7' THEN
          'AGV已配送到位' || ' (任務編號:'||T.MISSION_ID||')'
         WHEN T.PN_STATUS = '8' THEN
            'AGV任務異常或已取消配送' || ' (任務編號:'||T.MISSION_ID||')'
           ELSE
             'DOD未回傳任務狀態' || ' (任務編號:'||T.MISSION_ID||')'
       END)as PN_STATUS 
  FROM R_MO_DELIVERY_DETAIL_T T
INNER JOIN R_MO_DELIVERY_BOM_T B
    ON T.MO_NUMBER = B.MO_NUMBER
   AND T.MODEL_NAME = B.MODEL_NAME
   AND T.LOCATION_NAME = B.LOCATION_NAME
   AND T.PART_NO = B.PART_NO
   AND T.SC_OPCODE = B.SC_OPCODE
WHERE T.LINE_NAME = [[lineName]] and T.MO_NUMBER = [[MO]]
ORDER BY  T.KB_FLAG DESC,T.TASK_TYPE
 --------------------------------------------
#request_material_board_detail_new2



#request_material_and_board_list_new-old
 --------------------------------------------
select a.SFCS_MO MO,a.LINE_NAME,a.KB_FLAG,a.CALL_TIME,a.PROD_AREA_ID as aa from (
 SELECT SC.SFCS_MO,
       SC.LINE_NAME,
       MAX(PR.KB_FLAG) KB_FLAG,  -- 2-紅色；1-黃色；0-綠色
       MIN(PR.CALL_TIME) CALL_TIME  --用於排程，叫料最緊急的排在最前面
       ,T.PROD_AREA_ID
  FROM R_SCHEDULE_SAP_T SA --同步ERP智能排程表
INNER JOIN R_SCHEDULE_SFCS_T SC --MES記錄排程工單相關信息表
    ON SA.SCHL_NO = SC.SCHL_NO
INNER JOIN R_MO_DELIVERY_DETAIL_T PR --叫料信息表
    ON PR.MO_NUMBER = SC.SFCS_MO
   AND PR.MODEL_NAME = SC.SFCS_MODEL
   AND PR.SC_OPCODE = SA.VORNR
INNER JOIN C_PROD_AREA_LINE_T T --生產區域與線別對應表
    ON T.LINE_NAME = SC.LINE_NAME
WHERE 
    TO_DATE((TO_CHAR(SA.PLN_STAT_DATE, 'yyyy-MM-dd') ||' ' || SA.PLN_STAT_TIME),'yyyy-MM-dd HH24:MI:ss') BETWEEN TO_DATE('2005-01-01 13:14:20','yyyy-MM-dd HH24:MI:ss') AND SYSDATE+7
AND T.PROD_AREA_ID in ('3',[[prod_area_id]])
     AND NOT EXISTS --排除已發料完畢的工單
  (SELECT MO_NUMBER, MODEL_NAME
           FROM R_MO_DELIVERY_DETAIL_T D
          WHERE PR.MO_NUMBER = D.MO_NUMBER
            AND PR.MODEL_NAME = D.MODEL_NAME
            HAVING MIN(D.FINISH_FLAG) > 0
          GROUP BY D.MO_NUMBER, D.MODEL_NAME)

GROUP BY SC.SFCS_MO, SC.LINE_NAME,T.PROD_AREA_ID,(TO_CHAR(SA.PLN_STAT_DATE, 'yyyy-MM-dd') ||' ' || SA.PLN_STAT_TIME)
ORDER BY KB_FLAG DESC, CALL_TIME, LINE_NAME
)a 
 --------------------------------------------
#request_material_and_board_list_new-old

#request_material_and_board_list_new
 --------------------------------------------

select a.SFCS_MO MO,a.LINE_NAME,a.KB_FLAG,a.CALL_TIME,a.PROD_AREA_ID as aa from (
 SELECT SC.SFCS_MO,
       SC.LINE_NAME,
       MAX(PR.KB_FLAG) KB_FLAG,  -- 2-紅色；1-黃色；0-綠色
       MIN(PR.CALL_TIME) CALL_TIME  --用於排程，叫料最緊急的排在最前面
       ,T.PROD_AREA_ID
  FROM (select * from R_SCHEDULE_SAP_T
       where TO_DATE((TO_CHAR(PLN_STAT_DATE, 'yyyy-MM-dd') ||' ' || PLN_STAT_TIME),'yyyy-MM-dd HH24:MI:ss') BETWEEN SYSDATE - 7 AND SYSDATE+3
       and line in ( select line_name from C_PROD_AREA_LINE_T where PROD_AREA_ID in ('3',[[prod_area_id]]) and delete_flag='0')
       )
  SA --同步ERP智能排程表
INNER JOIN R_SCHEDULE_SFCS_T SC --MES記錄排程工單相關信息表
    ON SA.SCHL_NO = SC.SCHL_NO
INNER JOIN R_MO_DELIVERY_DETAIL_T PR --叫料信息表
    ON PR.MO_NUMBER = SC.SFCS_MO
   AND PR.MODEL_NAME = SC.SFCS_MODEL
   AND PR.SC_OPCODE = SA.VORNR
INNER JOIN (Select * from C_PROD_AREA_LINE_T   where PROD_AREA_ID in ('3',[[prod_area_id]]) and delete_flag='0' ) T --生產區域與線別對應表
    ON T.LINE_NAME = SC.LINE_NAME
GROUP BY SC.SFCS_MO, SC.LINE_NAME,T.PROD_AREA_ID,(TO_CHAR(SA.PLN_STAT_DATE, 'yyyy-MM-dd') ||' ' || SA.PLN_STAT_TIME)
ORDER BY KB_FLAG DESC, CALL_TIME, LINE_NAME
)a  
WHERE a.SFCS_MO||a.LINE_NAME
 NOT in --排除已發料完畢的工單
  (SELECT MO_NUMBER|| MODEL_NAME
           FROM R_MO_DELIVERY_DETAIL_T D
           group by MO_NUMBER, MODEL_NAME
            HAVING MIN(D.FINISH_FLAG) > 0
) and KB_FLAG > 0
ORDER BY KB_FLAG DESC, CALL_TIME, LINE_NAME
 --------------------------------------------
#request_material_and_board_list_new


#getLineAchievedChartNodeByTwoShift
 --------------------------------------------
SELECT ROUND(NVL(CAPACITY, 0), 4) * 100 RATE,
         END_TIME TIMENODE,
         NVL(ARCHIVER_LOWWARNING, 0.95)*100 ARCHIVER_LOWWARNING,
         NVL(ARCHIVER_LOWLIMIT, 0.90)*100 ARCHIVER_LOWLIMIT    
     FROM (SELECT WORK_DATE, 
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
				CASE WHEN SHIFT in ('DAY', '日A') THEN SUBSTR(SECTION_RANGE, 6, 4)||'(D)'
                      ELSE  SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END
                 END_TIME
                 --SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
            FROM R_PQM_DAILY_SUM_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND (
                    (('DAY' =[[shift]] or '日A' =[[shift]]) AND ( (work_date=to_char(SysDATE,'YYYYMMDD') ) or (work_date=to_char(SysDATE-1,'YYYYMMDD')AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700)))
                    --因DAY 可以超過 1700 (('DAY' =[[shift]] or '日A' =[[shift]]) AND ( (work_date=to_char(SysDATE,'YYYYMMDD') AND  SUBSTR(SECTION_RANGE,1,4)<1700) or (work_date=to_char(SysDATE-1,'YYYYMMDD')AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700)))
                    or 
                    ('NIGHT' =[[shift]]  AND 'B'= [[nightFlag]] AND ( (work_date=to_char(SysDATE,'YYYYMMDD') AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)<1200) or (work_date=to_char(SysDATE-1,'YYYYMMDD') AND SHIFT='DAY')))
                    or 
                    ('NIGHT' =[[shift]]  AND 'F'= [[nightFlag]] AND work_date=to_char(SysDATE,'YYYYMMDD') AND ((SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700) or SHIFT='DAY'))
                   ) 
             --AND T.SHIFT = 'DAY'
             --AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
             --                      ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
            GROUP BY WORK_DATE,LINE_NAME,  CASE WHEN SHIFT in ('DAY', '日A') THEN SUBSTR(SECTION_RANGE, 6, 4)||'(D)'
                      ELSE  SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END
       

          UNION ALL--SMT線
         SELECT WORK_DATE,   --前一個班次，白班
                 LINE_NAME,
                 AVG(CAPACITY) CAPACITY,
                 AVG(T.SAFE_RATE) ARCHIVER_LOWWARNING,
                 AVG(T.ALERT_RATE) ARCHIVER_LOWLIMIT,
				CASE WHEN SHIFT in ('DAY', '日A') THEN SUBSTR(SECTION_RANGE, 6, 4)||'(D)'
                      ELSE  SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END
                 END_TIME
                 --SUBSTR(SECTION_RANGE, 6, 4)||'(D)' END_TIME
            FROM R_PQM_DAILY_SUM_SMT_T T
           WHERE LINE_NAME = [[lineName]]
             AND STATE >= 0
             AND NVL(T.PROCESS_NAME,'N/A') = DECODE([[opCode]],'ALL',NVL(T.PROCESS_NAME,'N/A'),[[opCode]])
             AND (
                    (('DAY' =[[shift]] or '日A' =[[shift]]) AND ( (work_date=to_char(SysDATE,'YYYYMMDD') ) or (work_date=to_char(SysDATE-1,'YYYYMMDD')AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700)))
                    or 
                    ('NIGHT' =[[shift]]  AND 'B'= [[nightFlag]] AND ( (work_date=to_char(SysDATE,'YYYYMMDD') AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)<1200) or (work_date=to_char(SysDATE-1,'YYYYMMDD') AND SHIFT='DAY')))
                    or 
                    ('NIGHT' =[[shift]]  AND 'F'= [[nightFlag]] AND work_date=to_char(SysDATE,'YYYYMMDD') AND ((SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700) or SHIFT='DAY'))
                   ) 
             --AND T.SHIFT = 'DAY'
             --AND WORK_DATE = (CASE WHEN [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') 
             --                      ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) --'F'為傳入的參數，判斷當前夜班屬於前半夜還是後半夜
             GROUP BY WORK_DATE,LINE_NAME,  CASE WHEN SHIFT in ('DAY', '日A') THEN SUBSTR(SECTION_RANGE, 6, 4)||'(D)'
                      ELSE  SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END

         )
   ORDER BY WORK_DATE,TIMENODE
 --------------------------------------------
#getLineAchievedChartNodeByTwoShift


#getLinePassRateChartNodeByTwoShift
 --------------------------------------------
SELECT TRUNC(EXP(SUM(LN(DECODE(AA.YIELD, 0, 0.00001, AA.YIELD)))), 4)*100 RATE,  --各站良率相乘
           END_TIME TIMENODE,         
      NVL(C.YIELDR_LOWWARNING, 95) YIELDR_LOWWARNING,
             NVL(C.YIELDR_LOWLIMIT, 90) YIELDR_LOWLIMIT 
     FROM (SELECT WORK_DATE,
                   LINE_NAME,
                   GROUP_NAME,
                   YIELD, 
                   CASE WHEN SHIFT in ('DAY', '日A') THEN SUBSTR(SECTION_RANGE, 6, 4)||'(D)'
                   ELSE  SUBSTR(SECTION_RANGE, 6, 4)||'(N)' END END_TIME
              FROM R_PQM_LINE_GROUP_YIELD_T T
             WHERE LINE_NAME = [[lineName]]
					and(	
					     (
				         ([[shiftType]]='CUR' AND WORK_DATE = CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
				         or
						 ([[shiftType]]='PRE' AND WORK_DATE = CASE WHEN [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
						 )
						or 
						 work_date=TO_CHAR(SYSDATE, 'YYYYMMDD')
					   )
					AND SHIFT = [[shift]]
					and Substr(SECTION_RANGE,1,2) >=   case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT' and  [[nightFlag]]='B'   then '17' 
                                                   when work_date= TO_CHAR(SYSDATE,'yyyyMMdd') and shift='NIGHT' and  [[nightFlag]]='F'  then '17'
                                                   else '00' end  
					--and Substr(SECTION_RANGE,1,2) >= case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT'  then '17' else '00' end
          ) AA
     LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T C
       ON AA.LINE_NAME = C.LINE_NAME
     GROUP BY AA.WORK_DATE,AA.LINE_NAME, AA.END_TIME,C.YIELDR_LOWWARNING,C.YIELDR_LOWLIMIT
     ORDER BY WORK_DATE,TIMENODE  
 --------------------------------------------
#getLinePassRateChartNodeByTwoShift



#getQualityPassFailQtyByLineByTwoShift
 --------------------------------------------
with dimAreaType as (
    select a.line_name,case when b.area_flag=1 then 'SMT' ELSE 'NotSMT' END as AREA_FLAG
    from (select * from c_prod_area_line_t where line_name =[[lineName]]) a left join (select * from sfcs.c_prod_area_t where  delete_flag='0') b
    ON a.PROD_AREA_ID = b.PROD_AREA_ID
),
dimGroup as (
--耀欽->主線是用C_STATION_CONFIG_T的group name , SMT是用C_GROUP_CONFIG_T的OP_GROUP_NAME，跨Group將數據加總，再計算良率
--耀欽->and A.SECTION_NAME=G.SECTION_NAME 串不串沒差
SELECT distinct a.line_name, a.section_name,  case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end  as Group_name,
        MAX(NVL(a.station_idx,0)) OVER (
                               PARTITION BY a.line_name,a.section_name,case when AREA_FLAG ='SMT' then 
                                         case when ECHELON_name='日A' then g.group_desc  else c1.OP_GROUP_NAME end 
                                else 
                                         case when ECHELON_name='日A' then g.group_desc  else a.group_name end 
                                end
                                ) GROUP_INDEX                          
FROM C_STATION_CONFIG_T A 
INNER JOIN C_GROUP_CONFIG_T G ON A.GROUP_NAME=G.GROUP_NAME 
--and A.SECTION_NAME=G.SECTION_NAME
LEFT JOIN  C_OP_GROUP_CONFIG_T C1 ON C1.OP_GROUP_NAME=G.OP_GROUP_NAME 
LEFT JOIN C_OP_GROUP_TYPE_T C2 ON C1.OP_GROUP_TYPE_ID = C2.OP_GROUP_TYPE_ID
left join dimAreaType c3 on a.line_name=c3.line_name
left join C_LINE_ECHELON_T c4 on a.line_name=c4.line_name 
WHERE A.LINE_NAME=[[lineName]]
and c2.YIELD_FLAG = 'Y'
) 
--select temp.*,   EXP(SUM(LN(DECODE(RATE, 0, 0.000001, NULL, 0.000001, RATE))) over ()) * 100  as FPYR
--from (
SELECT GROUP_NAME X_AXLE,
(CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
      WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
      ELSE ROUND(SUM(PASS_QTY) /
             DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                    SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
  --,(CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
  --    WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
  --    ELSE ROUND(SUM(PASS_QTY) /
  --           DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
  --                  SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END) RATE                  
                    
    FROM (SELECT T.GROUP_NAME,
                 PASS_QTY,
                 FAIL_QTY,
                 NVL(sc.GROUP_INDEX,0) GROUP_INDEX
            FROM ( SELECT *
			       FROM R_PQM_LINE_GROUP_YIELD_T
             WHERE LINE_NAME = [[lineName]]
					and(	
					     (
				         ([[shiftType]]='CUR' AND WORK_DATE = CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
				         or
						 ([[shiftType]]='PRE' AND WORK_DATE = CASE WHEN [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
						 )
						or 
						 work_date=TO_CHAR(SYSDATE, 'YYYYMMDD')
					   )
					AND SHIFT = [[shift]]
					and Substr(SECTION_RANGE,1,2) >=   case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT' and  [[nightFlag]]='B'   then '17' 
                                                   when work_date= TO_CHAR(SYSDATE,'yyyyMMdd') and shift='NIGHT' and  [[nightFlag]]='F'  then '17'
                                                   else '00' end  
					--and Substr(SECTION_RANGE,1,2) >= case when work_date= TO_CHAR(SYSDATE-1,'yyyyMMdd') and shift='NIGHT'  then '17' else '00' end
				  ) T
				  --2018-07-23 iMES length of group_name is more great than PQM3.0, so if the iMES(Shift=日A) join the fact table by group_desc(IA Must maintain the IA's Group Name in this column)
            LEFT JOIN dimGroup SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME 
         ) 
   GROUP BY GROUP_NAME,GROUP_INDEX
   ORDER BY GROUP_INDEX
 --------------------------------------------
#getQualityPassFailQtyByLineByTwoShift


#getQualityPassFailQtyByLineByTwoShift--OLD
 --------------------------------------------
SELECT GROUP_NAME X_AXLE,
(CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
      WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
      ELSE ROUND(SUM(PASS_QTY) /
             DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                    SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
    FROM (SELECT T.GROUP_NAME,
                 PASS_QTY,
                 FAIL_QTY,
                 MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
            FROM ( SELECT *
			       FROM R_PQM_LINE_GROUP_YIELD_T
				   WHERE LINE_NAME = [[lineName]]
				   AND (
						(('DAY' =[[shift]] or '日A' =[[shift]]) AND (work_date=to_char(SysDATE,'YYYYMMDD') or (work_date=to_char(SysDATE-1,'YYYYMMDD') AND SHIFT='NIGHT' AND NIGHT_FLAG='F' )))
						or 
						('NIGHT' =[[shift]]  AND 'B'= [[nightFlag]] AND ( (work_date=to_char(SysDATE,'YYYYMMDD') AND SHIFT='NIGHT' AND NIGHT_FLAG='B') or (work_date=to_char(SysDATE-1,'YYYYMMDD') AND SHIFT='DAY')))
						or 
						('NIGHT' =[[shift]]  AND 'F'= [[nightFlag]] AND work_date=to_char(SysDATE,'YYYYMMDD') AND ((SHIFT='NIGHT' AND NIGHT_FLAG='F') or SHIFT='DAY'))
					   )
				  ) T
				  --2018-07-23 iMES length of group_name is more great than PQM3.0, so if the iMES(Shift=日A) join the fact table by group_desc(IA Must maintain the IA's Group Name in this column)
            LEFT JOIN (
             select c.line_name,c.section_name,c.station_idx,case when d.ECHELON_name='日A'  then e.group_desc  else c.group_name end  as group_name
                 from (select * from  C_STATION_CONFIG_T where line_name=[[lineName]] ) c,(select * from C_LINE_ECHELON_T where line_name=[[lineName]]) d  , c_group_config_t e
                 
                 -- c_group_config_t e
                 where c.line_name=d.line_name
                 and c.group_name=e.group_name
                 and c.section_name=e.section_name
            ) SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME 
         ) 
   GROUP BY GROUP_NAME,GROUP_INDEX
   ORDER BY GROUP_INDEX
 --------------------------------------------
#getQualityPassFailQtyByLineByTwoShift--OLD


#getLineEquipRunningRateAll
 --------------------------------------------
with EqpUti as (
select EQUIPMENT_ID,DESCRIPTION,
case when TRUNC(round(sum(UP_TIME)/((SYSDATE - (TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>)))*1440)*100,2))=100 then 100 else round(sum(UP_TIME)/((SYSDATE - (TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>)))*1440)*100,2) end as uti from (
 Select BASIC.EQUIPMENT_ID,DESCRIPTION,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
            round((case when  nvl(end_point,SYSDATE) >=  SYSDATE then SYSDATE   else end_point end - 
                           CASE WHEN PUB.BEGIN_POINT < TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>) 
                                THEN   TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>) else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by BASIC.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by BASIC.EQUIPMENT_ID ) as cnt_by_eqp 
         -- FROM R_EQUIPMENT_STATUS_RECORD_T PUB RIGHT JOIN C_EQUIPMENT_BASIC_T BASIC
           FROM (select * from r_equip_status_t 
                 where EQUIPMENT_ID in (select EQUIPMENT_ID from C_STATION_CONFIG_T where LINE_NAME =[[lineName]])
                 AND (
					( 
					END_POINT > ( TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>)) AND BEGIN_POINT <= SYSDATE
					) 
					OR
					END_POINT IS NULL
			        )  
                AND STATUS = 0 
                ) PUB RIGHT JOIN C_EQUIPMENT_BASIC_T BASIC        
		    ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID		
          -- AND (PUB.BEGIN_POINT >=( TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>)) OR PUB.END_POINT IS NULL)
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by EQUIPMENT_ID,DESCRIPTION
) 
select ROUND(nvl(a.uti,0),4) as RATE,a.DESCRIPTION as STATION_NAME
from EqpUti a
 INNER JOIN (select * from C_STATION_CONFIG_T where LINE_NAME =[[lineName]])   b
 on a.EQUIPMENT_ID=b.EQUIPMENT_ID
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON b.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
          where PAL.DELETE_FLAG = '0'
    order by b.STATION_IDX
 --------------------------------------------
#getLineEquipRunningRateAll

#getLineEquipRunningRateAll-Old
 --------------------------------------------
SELECT round( CASE
         WHEN WORKTIME * 100 > 100 THEN
          (NVL(ACTIVATION_MAX, 100) - 1) + DBMS_RANDOM.VALUE
         ELSE
          WORKTIME * 100
       END,4) RATE,
       DESCRIPTION STATION_NAME
  FROM (SELECT case when end_point >=  SYSDATE then SYSDATE   else end_point end - CASE
                         WHEN PUB.BEGIN_POINT <
                              TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>) THEN
                          TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-<<rangeDay>>
                         ELSE
                          PUB.BEGIN_POINT
                       END),
                   0) / (SYSDATE - (TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>))) WORKTIME,
               BASIC.DESCRIPTION,
               BASIC.EQUIPMENT_ID,
               STC.LINE_NAME,
               STC.STATION_IDX
          FROM R_EQUIPMENT_STATUS_RECORD_T PUB
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
           AND PUB.STATUS = 0
           AND (
				    ( 
					PUB.END_POINT >= ( TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS')-DECODE(<<rangeDay>>,1,0,<<rangeDay>>)) AND PUB.BEGIN_POINT <= SYSDATE
			   		) 
				   OR
				   PUB.END_POINT IS NULL
			   )
         INNER JOIN C_STATION_CONFIG_T STC
            ON STC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE STC.LINE_NAME =[[lineName]]
         GROUP BY BASIC.EQUIPMENT_ID,
                  STC.STATION_IDX,
                  BASIC.DESCRIPTION,
                  STC.LINE_NAME) EUQIP
 INNER JOIN C_PROD_AREA_LINE_T PAL
    ON EUQIP.LINE_NAME = PAL.LINE_NAME
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
    ON PAL.PROD_AREA_ID = PA.PROD_AREA_ID
 ORDER BY EUQIP.STATION_IDX
 --------------------------------------------
#getLineEquipRunningRateAll-Old

#getSMTpointAll
 --------------------------------------------
 SELECT ALLLIST.PLANT_POINT,
       ALLLIST.REAL_POINT,
       CASE WHEN LENGTH(ALLLIST.TIME_POINT)>9 then SUBSTR(ALLLIST.TIME_POINT, 9) else ALLLIST.TIME_POINT end TIME_POINT
  FROM (SELECT NVL(AVG(SMT.POINT_QTY), 0) / 12 PLANT_POINT,
               NVL(SUM(PQM.POINT_QTY), 0) REAL_POINT,
               PQM.WORK_DATE || CASE WHEN NVL(<<rangeDay>>,1)=1 THEN PQM.SECTION_RANGE  ELSE ' ' END TIME_POINT
          FROM C_LINE_CT_RUNR_PASSR_ALERT_T SMT
         RIGHT JOIN R_PQM_DAILY_SUM_SMT_T PQM
            ON PQM.LINE_NAME = SMT.LINE_NAME
         WHERE PQM.LINE_NAME = [[lineName]]
           AND PQM.PROCESS_NAME =DECODE([[opCode]], 'ALL', PQM.PROCESS_NAME, [[opCode]]) 
          AND  (
		         (NVL(<<rangeDay>>,1)=1 AND
				   (
						('DAY' =[[shift]] AND ( (work_date=to_char(SysDATE,'YYYYMMDD') ) or (work_date=to_char(SysDATE-1,'YYYYMMDD')AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700)))
						or 
						('NIGHT' =[[shift]]  AND 'B'= [[nightFlag]] AND ( (work_date=to_char(SysDATE,'YYYYMMDD') AND SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)<1200) or (work_date=to_char(SysDATE-1,'YYYYMMDD') AND SHIFT='DAY')))
						or 
						('NIGHT' =[[shift]]  AND 'F'= [[nightFlag]] AND work_date=to_char(SysDATE,'YYYYMMDD') AND ((SHIFT='NIGHT' AND SUBSTR(SECTION_RANGE,1,4)>1700) or SHIFT='DAY'))
				   ) 
				)
				OR
				 (
				 NVL(<<rangeDay>>,1)<>1 
				 AND pqm.work_date>to_char(sysdate-<<rangeDay>>,'YYYYMMDD') 
				 )
			   )
         GROUP BY   PQM.WORK_DATE || CASE WHEN NVL(<<rangeDay>>,1)=1 THEN PQM.SECTION_RANGE  ELSE ' ' END
      ) ALLLIST
 ORDER BY ALLLIST.TIME_POINT
 --------------------------------------------
#getSMTpointAll

#materialFailRateChartAll
 --------------------------------------------
 SELECT ALLLIST.FAILRATE rate,
       CASE WHEN NVL(1,1)=1 THEN  to_char(ALLLIST.TIMENODE, 'hh24:mi')else   to_char(ALLLIST.TIMENODE, 'MM/DD') end TIMENODE,
       5 LIMITLINE
  FROM (SELECT NVL(RATETABLE.FAILRATE,0) FAILRATE,
               TIMETABLE.TIMENODE
          FROM (SELECT  CASE WHEN NVL(<<rangeDay>>,1)=1 THEN TRUNC(SYSDATE - 1, 'HH') + LEVEL / 24 + 1 / 24 ELSE TRUNC(SYSDATE - 1, 'DD') + LEVEL END TIMENODE
                  FROM DUAL
               CONNECT BY LEVEL < CASE WHEN NVL(<<rangeDay>>,1)=1 then 25 else 1+1 end ) TIMETABLE
          LEFT JOIN (SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select material_no,count(material_no) failqty,CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end TIMENODE
                                from r_equip_materials_msg_t
                               where result<>'OK'
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and material_no=[[materialNO]]
                                 and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else 1 END)
                               group by CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end,material_no) failtable
                      inner join (select material_no,count(material_no) totalqty,CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end TIMENODE
                                    from  r_equip_materials_msg_t
                                   where material_no=[[materialNO]]
                                     and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else <<rangeDay>> END)
                                   group by  CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end,material_no) totaltable
                         on totaltable.material_no=failtable.material_no
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select responsibility,count(responsibility) failqty,CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end TIMENODE
                                from  r_equip_materials_msg_t
                               where result<>'OK'
                                 and responsibility=[[materialNO]]
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else <<rangeDay>> END)
                               group by  CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end,responsibility) failtable
                      inner join (select responsibility,count(responsibility) totalqty,CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end TIMENODE
                                    from  r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else <<rangeDay>> END)
                                   group by  CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end ,responsibility) totaltable
                         on totaltable.responsibility=failtable.responsibility
                        and totaltable.TIMENODE=failtable.TIMENODE
                      union
                     SELECT failtable.failqty/nvl(totaltable.totalqty,1)*100 failrate,
                            failtable.timenode
                       FROM  (select count(result) failqty,CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end  TIMENODE
                                from  r_equip_materials_msg_t
                               where result<>'OK'
                                 and result=[[materialNO]]
                                 and equipment_id=cast( [[equipmentID]] as raw(16)) 
                                 and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else <<rangeDay>> END)
                               group by  CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end) failtable
                      inner join (select count(result) totalqty,CASE WHEN NVL(<<rangeDay>>,1)=1 THEN TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end TIMENODE
                                    from  r_equip_materials_msg_t
                                   where equipment_id=cast( [[equipmentID]] as raw(16)) 
                                     and insert_date>(sysdate-CASE WHEN NVL(<<rangeDay>>,1)=1 then 25/24 else <<rangeDay>> END)
                                   group by  CASE WHEN NVL(<<rangeDay>>,1)=1 then TRUNC(INSERT_DATE, 'HH') + 1 / 24 else TRUNC(INSERT_DATE, 'DD') end) totaltable
                         on totaltable.TIMENODE=failtable.TIMENODE) RATETABLE
            ON TIMETABLE.TIMENODE = RATETABLE.TIMENODE
         GROUP BY TIMETABLE.TIMENODE,RATETABLE.FAILRATE) ALLLIST
 ORDER BY ALLLIST.TIMENODE

  --------------------------------------------
#materialFailRateChartAll


#getLineKPIAchieveInfoTwoShift
-------------------------------------------
--shiftType
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
   FROM (SELECT 'ALL' PROCESS_NAME, --各製程段匯總的
                TRUNC(MIN(SUMM.SUM_REAL)) || '/' ||
                TRUNC(MIN(SUMM.SUM_REAL)/DECODE(AVG(CAPACITY),0,1,AVG(CAPACITY))) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE (
		        [[shiftType]]='CUR' AND WORK_DATE = (CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
		        or
				[[shiftType]]='PRE' AND WORK_DATE = (CASE WHEN  [[shiftType]]='PRE' AND [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
				)
            AND SUMM.LINE_NAME = [[lineName]]
            AND SUMM.SHIFT = [[shift]] 
         UNION --分製程段的
         SELECT SUMM.PROCESS_NAME,
                NVL(SUMM.SUM_REAL, 0) || '/' || NVL(SUMM.SUM_PLAN, 0) QTY,
                CAPACITY * 100 CAPACITY,
                CAPACITY * 100 || '%' CAPACITY_S,
                NVL(SUMM.MAX_STATE, -1) MAX_STATE
           FROM R_PQM_SUMMARY_T SUMM
          WHERE (
		        [[shiftType]]='CUR' AND WORK_DATE = (CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
		        or
				[[shiftType]]='PRE' AND WORK_DATE = (CASE WHEN  [[shiftType]]='PRE' AND [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
				)
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT =[[shift]]
       )
        WHERE CAPACITY IS NOT NULL  AND PROCESS_NAME =[[opCode]]
         UNION
SELECT QTY, CAPACITY, CAPACITY_S, MAX_STATE
FROM (
         SELECT 'ALL' PROCESS_NAME, --各製程段匯總的
                TRUNC(MIN(SUMM.SUM_REAL)) || '/' ||
                TRUNC(MIN(SUMM.SUM_REAL)/DECODE(AVG(CAPACITY),0,1,AVG(CAPACITY))) QTY,
                ROUND(AVG(CAPACITY), 4) * 100 CAPACITY,
                ROUND(AVG(CAPACITY), 4) * 100 || '%' CAPACITY_S,
                MAX(SUMM.MAX_STATE) MAX_STATE
           FROM R_PQM_SUMMARY_SMT_T SUMM
          WHERE (
		        [[shiftType]]='CUR' AND WORK_DATE = (CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
		        or
				[[shiftType]]='PRE' AND WORK_DATE = (CASE WHEN  [[shiftType]]='PRE' AND [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
				)
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]

  )
  WHERE CAPACITY IS NOT NULL
 --------------------------------------------
#getLineKPIAchieveInfoTwoShift


#getPandQOverview
 --------------------------------------------
with DimOriCanlendar as (
select      
            WORK_DATE,row_number() over (partition by ECHELON_NAME,line_name order by WORK_DATE,section_from) as SN_BY_ECHELON,
            ECHELON_NAME,line_name,SHIFT,SECTION_FROM,SECTION_TO,section_From||'-'||section_to as section_range,DURATION,ORI_WORK_TIME,CUR_TIME,CUR_SHIFT,CUR_SECTION_FROM,NIGHT_FLAG,REST_FROM,REST_TO,CUR_NIGHT_FLAG,
            min(WORK_DATE||SECTION_FROM) over (partition by ECHELON_NAME,line_name,SHIFT) as min_from,
            max(WORK_DATE||SECTION_TO)   over (partition by ECHELON_NAME,line_name,SHIFT) as max_to
from (
select b.*,
CASE WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE)-1,'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='B' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='F'THEN  TO_CHAR((SYSDATE),'yyyyMMdd')
            WHEN  max(nvl(night_flag,''))   over (partition by ECHELON_NAME,line_name,SHIFT,CUR_SECTION_FROM)='F' and NIGHT_FLAG='B'THEN  TO_CHAR((SYSDATE)+1,'yyyyMMdd')
            ELSE  TO_CHAR((SYSDATE),'yyyyMMdd') END as WORK_DATE,
            max(case when shift=cur_shift and section_from = cur_section_from then night_flag else '' end )   over (partition by ECHELON_NAME,SHIFT,CUR_SECTION_FROM) as cur_night_flag
           from (
  SELECT line_name,ECHELON_NAME,SHIFT,SECTION_FROM,SECTION_TO,DURATION,ori_work_time,CUR_TIME, a.CUR_SHIFT, a.CUR_SECTION_FROM,                                                             
         CASE WHEN a.shift='DAY' and a.SECTION_FROM<='24' then ''                                                                                                                                                                          
                     when a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B'                
                     when a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM<='1200'  then  'B' 
                     when  a.shift='NIGHT'  and a.SECTION_FROM>='1700'  then  'F'                                                                                                       
                     WHEN a.shift='NIGHT'   AND a.SECTION_FROM <='12'  then 'B'              
                     WHEN  a.shift='NIGHT'  AND a.SECTION_FROM >='17'  then 'F'              
                     ELSE '' end as NIGHT_FLAG
                    ,REST_from,REST_to                                                                                                                                                                                                    
   from (                                                                                                                                                              
       SELECT E.line_name,E.ECHELON_NAME,                                                                                                                                                                     
            E.SHIFT,E.SECTION_FROM,E.SECTION_TO,E.duration, E.work_time as ori_work_time,TO_CHAR((SYSDATE+10/24),'HH24MI') as CUR_TIME,  REST_FROM,REST_TO,                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SHIFT else '' end ) over ( partition by  E.ECHELON_NAME) as CUR_SHIFT,                                                                                                                                                                   
            max(case when E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO  then SECTION_FROM else '' end ) over (partition by  E.ECHELON_NAME) as CUR_SECTION_FROM,                                                                                                                                                                             
            CASE WHEN MIN(case when (E.SECTION_FROM <= TO_CHAR((SYSDATE),'HH24MI') AND TO_CHAR((SYSDATE),'HH24MI') <= E.SECTION_TO) then SHIFT else '' end) over ()='NIGHT' AND  TO_CHAR((SYSDATE),'HH24')>='0000' and  TO_CHAR((SYSDATE),'HH24') <='12' then  TO_CHAR((SYSDATE)-1,'YYYYMMDD') else  TO_CHAR((SYSDATE),'YYYYMMDD') end as CUR_DATE
         from (
         select b.line_name,a.ECHELON_NAME,a.SHIFT,a.SECTION_FROM,a.SECTION_TO,a.DURATION,a.WORK_TIME,a.VALID,a.SET_EMP,a.SET_TIME
         ,case when a.work_time<duration and rest_to is null then to_char(to_date(TO_CHAR((SYSDATE),'yyyy-MM-dd')||' '||SECTION_FROM, 'yyyy-mm-dd hh24mi')+ ((work_time)/1440),'hh24mi') else rest_from end as rest_from
         ,case when a.work_time<duration and rest_to is null  then section_to else rest_to end rest_to
         from (select * from C_ECHELON_SECTION_T where VALID = '0') a inner join 
                                                        (select * from  C_LINE_ECHELON_T
                                                         where line_name in (select line_name from  C_PROD_AREA_LINE_T where prod_area_id=<<prod_area_id>> and delete_flag='0')
                                                                  ) b
         on a.ECHELON_name=b.ECHELON_name 
         ) E                                                                                                                                                                              
           )  a
    ) b
       ) d
      where 1=1 
    and cur_shift=shift      
    order by section_from
),
DimTime as (
 select line_name,ECHELON_NAME,SHIFT,
        SUM(ORI_WORK_TIME)as  WORK_TIME_by_shift,
        min(case when shift='日A' then SUBSTR(min_from,1, 8)||'0800' else  min_from end)   as SECTION_FROM_By_shift,
        max(case when shift='日A' then to_char(to_date(SUBSTR(min_from,1, 8),'yyyyMMDDHH')+1,'yyyyMMDD')||'0759' else  max_to end)  as SECTION_TO_By_shift, 
        min(To_char(to_date(substr(min_from,1,8),'YYYYMMDD')-case when substr(min_from,1,8)=substr(max_to,1,8) then 1 else 0 end,'YYYYMMDD')||substr(max_to,9)) SECTION_FROM_By_PRE_shift
        from DimOriCanlendar t
        group by line_name,ECHELON_NAME,SHIFT
) 
,
DimMix as (
select a.Line_name,a.ECHELON_NAME,c.PROD_AREA_ID,a.SHIFT,b.station_name,b.group_name, EQUIPMENT_ID,SECTION_FROM_By_shift , TO_DATE(SECTION_FROM_By_shift, 'YYYYMMDDHH24MISS')SECTION_FROM_By_shift_time,ACTIVATION_MAX,RUNR_LOWLIMIT,RUNR_LOWWARNING
from DimTime a left join ( select * from C_STATION_CONFIG_T  where line_name in (select line_name from  C_PROD_AREA_LINE_T where prod_area_id=<<prod_area_id>> and delete_flag='0') and EQUIPMENT_ID is not null) b 
on a.line_name=b.line_name
inner join (select line_name,prod_area_id from  C_PROD_AREA_LINE_T where prod_area_id=<<prod_area_id>> and delete_flag='0') c
on a.line_name=c.line_name
 LEFT JOIN SFCS.C_PROD_AREA_CONFIG_T PA
 ON c.PROD_AREA_ID = PA.PROD_AREA_ID
  left join C_LINE_CT_RUNR_PASSR_ALERT_T l
   on a.line_name=l.line_name
)


,EqpUti as (
select  line_name,group_name,station_name,EQUIPMENT_ID,to_char( SECTION_FROM_By_shift_time,'YYYYMMDDHH24MISS') as SECTION_FROM_By_shift_time,case when TRUNC(round(sum(UP_TIME)/((SYSDATE-SECTION_FROM_By_shift_time)*1440),4))=100 then 100 else round(sum(UP_TIME)/((SYSDATE-SECTION_FROM_By_shift_time)*1440),4) end as uti
from (
 select a.line_name,a.group_name,a.station_name,a.EQUIPMENT_ID,SECTION_FROM_By_shift_time,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
                round(( case when  nvl(end_point,SYSDATE) >=  SYSDATE  then SYSDATE   else end_point end  - 
                           CASE WHEN PUB.BEGIN_POINT < SECTION_FROM_By_shift_time
                                THEN   SECTION_FROM_By_shift_time else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by a.line_name,a.group_name,a.station_name,a.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by a.line_name,a.group_name,a.station_name,a.EQUIPMENT_ID ) as cnt_by_eqp 
          FROM DimMix a ,(select EQUIPMENT_ID,BEGIN_POINT,END_POINT from r_equip_status_t 
                           where 1=1
                           and EQUIPMENT_ID in (select EQUIPMENT_ID from  DimMix )
                           and END_POINT > SYSDATE-1 AND BEGIN_POINT <= SYSDATE  
                           and STATUS = 0
                          union all
                          select EQUIPMENT_ID,BEGIN_POINT,END_POINT from r_equip_status_t 
                           where 1=1
                           and EQUIPMENT_ID in (select EQUIPMENT_ID from  DimMix )
                           and END_POINT is null
                           and STATUS = 0
                          ) PUB
          where a.EQUIPMENT_ID = PUB.EQUIPMENT_ID
         and nvl(pub.END_POINT,SYSDATE) > SECTION_FROM_By_shift_time AND PUB.BEGIN_POINT <= SYSDATE 
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by line_name,group_name,station_name,EQUIPMENT_ID,SECTION_FROM_By_shift_time
) 
,
AvgLineEqpUti as (
 select b.PROD_AREA_ID,b.LINE_NAME,TO_CHAR(avg(a.uti), 'fm990.09') || '%' as RATE,
  ROUND(avg(a.uti),4) as RATEVALUE,
  case when  ROUND(avg(a.uti),4)  >=  max(NVL(RUNR_LOWWARNING, ACTIVATION_MAX - 5)) THEN
          0
      when  ROUND(avg(a.uti),4)>=max( NVL(RUNR_LOWLIMIT, ACTIVATION_MAX - 10)) THEN
          1
      ELSE
          2
       END MAX_STATE
 from EqpUti a, DimMix b
 where a.LINE_NAME = b.LINE_NAME
 and a.EQUIPMENT_ID=b.EQUIPMENT_ID
 group by  b.PROD_AREA_ID,b.LINE_NAME
),
factOldKpi as (
select distinct t10.prod_area_id,
      t10.man_sequence,                                                
      t10.line_name,
       -- t11.max_state(這個參數需要生成)
       t11.capacity,
       t11.yield,
       t12.archi_safe_rate,
       t12.archi_alert_rate,
       t13.archiver_lowwarning,
       t13.archiver_lowlimit,
       t13.Yieldr_Lowwarning,
       t13.yieldr_lowlimit,
       t14.open_line,
       t15.import_line,
	   t16.production
  from ((select 
          prod_area_id,
          man_sequence,
           line_name
           from C_PROD_AREA_LINE_T
          where prod_area_id = <<prod_area_id>>
         	and delete_flag = '0' 
            --and line_name in ('FS03','FS11','FS12','FS13','FS04','FS05','F202','F204','F206','F208','F228')
            ) t10
       
        left join
       
        (
            SELECT LINE_NAME,PROCESS_NAME,CAPACITY,YIELD from (
            SELECT LINE_NAME,PROCESS_NAME,CAPACITY,YIELD,
            ROW_NUMBER() OVER (PARTITION BY line_name ORDER BY case when instr(PROCESS_NAME,'後段產出')>0  then -1  WHEN PROCESS_NAME='ALL' THEN 1 else 2 end,PROCESS_NAME) as SN
            from 
            (
            SELECT SUMM.LINE_NAME,PROCESS_NAME, CAPACITY, min(YIELD) over (partition by line_name) YIELD
            FROM R_PQM_SUMMARY_T SUMM
            WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.line_name||SUMM.shift in (select line_name||shift  from DimTime)
            union all
            SELECT SUMM.LINE_NAME,'ALL' PROCESS_NAME, ROUND(AVG(CAPACITY), 3) CAPACITY, MIN(YIELD) YIELD
            FROM R_PQM_SUMMARY_T SUMM
            WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND  SUMM.line_name||SUMM.shift in (select line_name||shift  from DimTime)
            group by  SUMM.LINE_NAME
            )
            ) where sn=1      
         UNION ALL
            SELECT LINE_NAME,PROCESS_NAME,CAPACITY,YIELD from (
            SELECT LINE_NAME,PROCESS_NAME,CAPACITY,YIELD,
            ROW_NUMBER() OVER (PARTITION BY line_name ORDER BY case when instr(PROCESS_NAME,'後段產出')>0  then -1  WHEN PROCESS_NAME='ALL' THEN 1 else 2 end,PROCESS_NAME) as SN
            from 
            (
            SELECT SUMM.LINE_NAME,PROCESS_NAME, CAPACITY, min(YIELD) over (partition by line_name) YIELD
            FROM R_PQM_SUMMARY_SMT_T SUMM
            WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND SUMM.line_name||SUMM.shift in (select line_name||shift  from DimTime)
            union all
            SELECT SUMM.LINE_NAME,'ALL' PROCESS_NAME, ROUND(AVG(CAPACITY), 3) CAPACITY, MIN(YIELD) YIELD
            FROM R_PQM_SUMMARY_SMT_T SUMM
            WHERE SUMM.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
            AND  SUMM.line_name||SUMM.shift in (select line_name||shift  from DimTime)
            group by  SUMM.LINE_NAME
            )
            ) where sn=1                 
        ) t11 on t10.line_name = t11.line_name
        left join
       --獲取上限和下限的平均值
        (select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_t
          where work_date = to_char(sysdate, 'yyyymmdd')
           AND  line_name||shift in (select line_name||shift  from DimTime)
          group by line_name  
         union all
         select avg(safe_rate) * 100 archi_safe_rate,
                avg(alert_rate) * 100 archi_alert_rate,
                line_name
           from r_pqm_daily_sum_smt_t
          where work_date = to_char(sysdate, 'yyyymmdd')
           AND line_name||shift in (select line_name||shift  from DimTime)
          group by line_name) t12   
        on t10.LINE_NAME = t12.line_name
       
        left join
       
       --獲取上下限(直通率和達成率)
        (select line_name,
                archiver_lowwarning,
                archiver_lowlimit,
                Yieldr_Lowwarning,
                yieldr_lowlimit
           from c_line_ct_runr_passr_alert_t
          where prod_area_id = <<prod_area_id>> --參數傳入       
            ) t13
        on t10.line_name = t13.line_name  
        left join
       --辨別是否已經開線
        (select distinct line_name open_line
           from R_PQM_SUMMARY_T
          where work_date = to_char(sysdate, 'yyyymmdd') --參數傳入
            and  line_name in (select line_name  from DimTime)
         union all   
         select distinct line_name open_line
           from R_PQM_SUMMARY_SMT_T
          where work_date = to_char(sysdate, 'yyyymmdd')
            and line_name in (select line_name  from DimTime)   
            ) t14 --參數傳入 
        on t10.line_name = t14.open_line
        left join
       --辨別是否已經導入
        (select distinct line_name import_line
           from R_PQM_SUMMARY_T
          where  line_name in (select line_name  from DimTime) --參數傳入 
         union all
         select distinct line_name import_line
           from R_PQM_SUMMARY_SMT_T
          where line_name in (select line_name  from DimTime) ) t15 --參數傳入    
        on t10.line_name = t15.import_line
         left join
        --新增生產力數據
        --AVG By Process(2019/03/11 _Sean request)
         (
         Select line_name,Avg(production_by_process) production
         from
           (
	         SELECT line_name,PROCESS_Name,round(nvl(SUM(output_time), 0) / (24 * 3600),4) as production_by_process
	  			FROM (SELECT process.line_rate * (rec.pass_qty) AS output_time,rec.line_name,rec.GROUP_NAME,PROCESS.PROCESS_Name
	                  FROM R_STATION_REC_T REC
	                  LEFT JOIN C_MODEL_PROCESS_GROUP_T PROCESS
	                    ON REC.MODEL_NAME = PROCESS.MODEL_NAME
	                   AND REC.GROUP_NAME = PROCESS.OUT_GROUP
	                 INNER JOIN c_line_desc_t l
	                    ON l.line_name = rec.line_name
	                   AND l.line_style = process.line_style
	                 WHERE rec.line_name in (select line_name  from DimTime)
	                   AND rec.work_date in (to_char(sysdate-1,'yyyymmdd'),to_char(sysdate,'yyyymmdd')) and rec.inputdate > (sysdate-1)   
	                )
	           group by line_name,PROCESS_Name
            ) temp
            group by line_name
       	) t16
          on t10.line_name = t16.line_name
       )
    )
    select PROD_AREA_ID,LINE_NAME,CAPACITY,CAPACITY_TIP,YIELD,YIELD_TIP,ARCHI_SAFE_RATE,ARCHIVER_LOWWARNING,ARCHI_ALERT_RATE,ARCHIVER_LOWLIMIT,STATEA,STATEB,
    case when STATEA>STATEB then  STATEA else STATEB end state,
    LINE_TIP,Production,UTI,OEE
    from (
    select a.prod_area_id,a.man_sequence,a.line_name,
    NVL2(a.CAPACITY,to_char(round(a.CAPACITY*100,2))||'%','N/A') as CAPACITY,
    to_char(coalesce(ARCHI_SAFE_RATE,ARCHIVER_LOWWARNING,95))||'%,'||to_char(coalesce(ARCHI_ALERT_RATE,ARCHIVER_LOWLIMIT,90))||'%' as CAPACITY_tip,
    NVL2(a.YIELD,to_char(round(a.YIELD*100,2))||'%','N/A') as YIELD,
    to_char(nvl(YIELDR_LOWWARNING,95))||'%,'||to_char(nvl(YIELDR_LOWLIMIT,90))||'%' as YIELD_tip,
    ARCHI_SAFE_RATE,ARCHIVER_LOWWARNING,ARCHI_ALERT_RATE,ARCHIVER_LOWLIMIT,
    case when a.CAPACITY>=(NVL2(ARCHI_SAFE_RATE,ARCHIVER_LOWWARNING,0.95)) then 0 
         when  a.CAPACITY>=(NVL2(ARCHI_ALERT_RATE,ARCHIVER_LOWLIMIT,0.90)) and  a.CAPACITY<=(NVL2(ARCHI_SAFE_RATE,ARCHIVER_LOWWARNING,0.95)) then 1
         else 2 end stateA,
    case when a.YIELD>=(nvl(YIELDR_LOWWARNING,0.95)) then 0 
         when  a.YIELD>=(nvl(YIELDR_LOWLIMIT,0.90)) and  a.YIELD<=(nvl(YIELDR_LOWWARNING,0.95)) then 1
         else 2 end stateB,
         case when OPEN_LINE=a.line_name then '已開線'
              when  OPEN_LINE is null  and IMPORT_LINE=a.line_name then '未開線'
              else '未導入' end LINE_TIP, 
    NVL2(b.RATEVALUE,to_char(round(b.RATEVALUE*100,2))||'%','N/A')   as UTI,
      NVL2( a.Production,to_char(round( a.Production*100,2))||'%','N/A') as Production,
     case when a.Production is not null and b.RATEVALUE  is not null then  to_char(round(a.Production*b.RATEVALUE,4)*100)||'%' else 'N/A' end   as OEE
    from factOldKpi a left join AvgLineEqpUti b
    on a.PROD_AREA_ID=b.PROD_AREA_ID
    and a.line_name=b.line_name
    ) order by man_sequence,line_name
 --------------------------------------------
#getPandQOverview

#getPoorChartDesc
--------------------------------------------
--Young Add Cumulate Count[cum_ratio]
SELECT xAxis,sum(cnt) cnt,error_desc,
round(sum(sum(cnt)) over ( order by sum(cnt) desc ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW )/
sum(sum(cnt)) over ( order by sum(cnt) desc ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ),4)
as cum_ratio FROM (
select nvl(re.test_code,'N/A') as xAxis,count(0) cnt,ec.error_desc from r_repair_t re inner join
(SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name = [[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
on tdate.line_name=re.test_line and re.test_time between tdate.begin_time and tdate.end_time and re.test_station=[[stationName]]
left join c_error_code_t ec on ec.error_code=re.test_code
group by re.test_code,ec.error_desc
union all
select nvl(nlf.error_code,'N/A') as xAxis,fail_qty cnt,ec.error_desc from R_NO_LABEL_FAIL_T nlf inner join
(SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name = [[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
 on tdate.line_name=nlf.line_name and nlf.set_time between tdate.begin_time and tdate.end_time inner
 join c_station_config_t s on s.line_name=nlf.line_name and s.section_name=nlf.section_name and s.group_name=nlf.group_name
 and s.station_name =[[stationName]]
 left join c_error_code_t ec on ec.error_code=nlf.error_code
  )
 group by xAxis ,error_desc order by cnt desc
--------------------------------------------
#getPoorChartDesc


#getStationFallTendencyChart
 --------------------------------------------
  SELECT to_char(tdate.serialtime, 'YYYYMMDD hh24:mi') hour,
       nvl(fail_per, '0.00%') fail_per
  FROM (SELECT TRUNC(to_date([[beginTime]],
                             'YYYYMMDDhh24miss') + (LEVEL - 1) / 24,
                     'hh24') serialtime
          FROM DUAL
        CONNECT BY LEVEL <=
                   (to_date([[endTime]],
                            'YYYYMMDDhh24miss') -
                   to_date([[beginTime]] ,
                            'YYYYMMDDhh24miss')) * 24 + 1) tdate
  left join (SELECT to_date(scnt.hour || '00', 'YYYYMMDDhh24mi') hour,
                    to_char(round(nvl(fcnt.fail_cnt, 0) * 100 /
                                  decode(nvl(scnt.cnt, 1),
                                         0,
                                         1,
                                         nvl(scnt.cnt, 1)),
                                  2),
                            'fm99999999990.00') fail_per
               FROM (SELECT to_char(sd.in_station_time, 'YYYYMMDDhh24') hour,
                            count(1) cnt
                       FROM r_sn_detail_t sd
                      where sd.line_name = [[lineName]]
                        and sd.station_name = [[stationName]]
                        and sd.in_station_time >=
                            to_date([[beginTime]],
                                    'YYYYMMDDhh24miss')
                        and sd.in_station_time <
                            to_date([[endTime]] ,
                                    'YYYYMMDDhh24miss')
                      group by to_char(sd.in_station_time, 'YYYYMMDDhh24')
                      order by to_char(sd.in_station_time, 'YYYYMMDDhh24')) scnt
               left join (SELECT to_char(test_time, 'YYYYMMDDhh24') hour,
                                count(0) fail_cnt
                           FROM r_repair_t re
                          where test_line = [[lineName]]
                            and test_station = [[stationName]] 
                            and test_time >=
                                to_date([[beginTime]],
                                        'YYYYMMDDhh24miss')
                            and test_time <
                                to_date([[endTime]],
                                        'YYYYMMDDhh24miss')
                          and
                          exists ( --抓取首次pass的序號信息
                select 0
                  from (select serial_number,
                                test_group,
                                min(test_time) test_time
                           from r_repair_t r1
                          where r1.serial_number = re.serial_number
                            and r1.test_group = re.test_group
                          group by serial_number, test_group) rr
                 where rr.serial_number = re.serial_number
                   and rr.test_group = re.test_group
                   and re.test_time = rr.test_time)
           and not exists --排除本次時間範圍內二次不良的序號
         (SELECT 0
                  FROM r_repair_t r2
                 where r2.serial_number = re.serial_number
                   and r2.test_group = re.test_group
                   and r2.test_time < to_date([[beginTime]],'YYYYMMDDhh24miss'))
           and not exists --排除首次pass回流fail的序號
         (SELECT 0
                  FROM R_SN_DETAIL_T r3
                 where r3.serial_number = re.serial_number
                   and r3.group_name = re.test_group
                   and r3.error_flag = 0
                   and r3.in_station_time < re.test_time)
                          group by to_char(test_time, 'YYYYMMDDhh24')
                          order by to_char(test_time, 'YYYYMMDDhh24')) fcnt
                 on fcnt.hour = scnt.hour) fdata
    on fdata.hour = tdate.serialtime
 where tdate.serialtime <
       to_date([[endTime]], 'YYYYMMDDhh24miss')
 order by tdate.serialtime
--------------------------------------------
#getStationFallTendencyChart

#getLineDelayCurriculumVitae
  --------------------------------------------
 SELECT 
       pll.loss_code loss_code,
       pll.loss_desc  loss_dess,
       pll.process_name process_name, 
       pll.begin_time ||'--'||pll.end_time time_range,
       NVL2(pll.end_time, to_char(ROUND((to_date(pll.end_time,'YYYY/MM/DD hh24:mi') - to_date(pll.begin_time,'YYYY/MM/DD hh24:mi')) * 1440), 'FM999,999,999'), '') loss_time,
       pll.deal_way countermeasure_code,
       NVL(lc.countermeasure_desc,pll.deal_way) countermeasure_desc
  FROM ( Select * from P_PQM_LINE_LOSS_T 
         where work_date in (to_char(sysdate-1,'yyyymmdd') , to_char(sysdate,'yyyymmdd'))
         and line_name=[[lineName]]
         and stay_flag=0 
         AND to_date(begin_time,'YYYY/MM/DD hh24:mi') between to_date([[beginTime]],'YYYYMMDDhh24mi') and  to_date([[endTime]],'YYYYMMDDhh24mi')
      ) pll
  left join C_MES_LOSS_CODE_T mlc
    on mlc.loss_code = pll.loss_code
  left join C_LOSS_COUNTERMEASURE_T lc
    on lc.loss_code = pll.loss_code
   and lc.countermeasure_code = pll.deal_way
  order by to_date(begin_time,'YYYY/MM/DD hh24:mi'),to_date(end_time,'YYYY/MM/DD hh24:mi')
 --------------------------------------------
#getLineDelayCurriculumVitae

#getLineFaultCurriculumVitae
 --------------------------------------------

SELECT rownum,aa.*
from (select serial_number,mo_number,model_name,test_time,test_code,test_desc,reason_code,reason_desc,repair_code,repair_desc,repairer,correctiveactionCode,correctiveactionDesc FROM (
SELECT 'No Label-Count:'||(nvl(nlf.fail_qty,0)-nvl(sum(rnl.repair_qty),0)) serial_number,
nvl(nlf.mo_number,'-') mo_number,
nvl(nlf.model_name,'-') model_name,
nlf.set_time test_time,
nvl(nlf.error_code,'-') test_code,
nvl(nvl(ec1.error_desc,nlf.error_code),'-') test_desc,
'-' reason_code,
'-' reason_desc,
'-'repair_code,
'-' repair_desc,
'-' repairer,
'-' correctiveactionCode,
'-' correctiveactionDesc
FROM R_NO_LABEL_FAIL_T nlf left join R_REPAIR_NO_LABEL_T rnl on nlf.item_id=rnl.item_id  left join c_error_code_t ec1 on nlf.error_code=ec1.error_code
inner join c_station_config_t s on s.line_name=nlf.line_name and nlf.section_name=s.section_name and s.group_name = nlf.group_name 
inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name = [[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
on nlf.line_name = tdate.line_name and s.station_name=[[stationName]] and 
nlf.set_time between tdate.begin_time and tdate.end_time
group by  nlf.item_id,nlf.fail_qty,nlf.model_name,nlf.mo_number,nlf.set_time,nlf.error_code,ec1.error_desc having (nvl(nlf.fail_qty,0)-nvl(sum(rnl.repair_qty),0))<>0
union all
SELECT 'No Label-Count:'||rnl.repair_qty serial_number,
rnl.mo_number mo_number,
rnl.model_name model_name,
nlf.set_time test_time,
nvl(nlf.error_code,'N/A') test_code,
nvl(ec1.error_desc,'N/A') test_desc,
rnl.reason_code reason_code,
 nvl(rc.reason_desc, '-') reason_desc,
rnl.error_code repair_code,
ec2.error_desc repair_desc,
 nvl(nvl(emp.emp_name,rnl.repair_emp),'-') repairer,
 '-' correctiveactionCode,
 '-' correctiveactionDesc
from R_NO_LABEL_FAIL_T nlf inner join R_REPAIR_NO_LABEL_T rnl on nlf.item_id=rnl.item_id 
left join c_emp_desc_T emp  on emp.emp_no=rnl.repair_emp left join c_error_code_t ec1 on nlf.error_code=ec1.error_code left join
c_error_code_t ec2 on rnl.error_code=ec2.error_code
left join c_reason_code_t rc on rc.reason_code=rnl.reason_code and rc.prod_plant in (SELECT mo.prod_plant FROM r_mo_overall_v mo where mo.mo_number=nlf.mo_number and mo.model_name=nlf.model_name and rownum=1)
inner join c_station_config_t s on s.line_name=nlf.line_name and nlf.section_name=s.section_name and s.group_name = nlf.group_name 
inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name =[[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
on nlf.line_name = tdate.line_name and nlf.group_name=[[groupName]]  and
nlf.set_time between tdate.begin_time and tdate.end_time
union all
SELECT distinct re.serial_number serial_number,
       re.mo_number mo_number,
       re.model_name model_name,
       re.test_time test_time,
       re.test_code test_code,
       ec1.error_desc test_desc,
       re.reason_code reason_code,
       nvl(rc.reason_desc, re.reason_detail) reason_desc,
       re.errorcode repair_code,
       ec2.error_desc repair_desc,
       nvl(nvl(emp.emp_name,re.repairer),'-') repairer,
       nvl(re.correctiveaction,'-') correctiveactionCode,
       nvl(nvl(ca.correct_action_desc,re.correctiveaction),'-') correctiveactionDesc
  FROM r_repair_t re
  left join c_emp_desc_T emp
    on emp.emp_no=re.repairer
  left join c_error_code_t ec1
    on re.test_code = ec1.error_code
  left join c_error_code_t ec2
    on re.errorcode = ec2.error_code
  left join c_reason_code_t rc
    on rc.reason_code = re.reason_code
	and rc.prod_plant in (SELECT mo.prod_plant FROM r_mo_overall_v mo where mo.mo_number=re.mo_number and mo.model_name=re.model_name and rownum=1)
  left join  C_CORRECTIVE_ACTION_T ca on re.correctiveaction=ca.correct_action_name
  inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name =[[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
  on re.test_line = tdate.line_name and re.test_station=[[stationName]]  and
re.test_time between tdate.begin_time and tdate.end_time
where  exists ( --抓取首次pass的序號信息
                select 0
                  from (select serial_number,
                                test_group,
                                min(test_time) test_time
                           from r_repair_t r1
                          where r1.serial_number = re.serial_number
                            and r1.test_group = re.test_group
                          group by serial_number, test_group) rr
                 where rr.serial_number = re.serial_number
                   and rr.test_group = re.test_group
                   and re.test_time = rr.test_time)
           and not exists --排除本次時間範圍內二次不良的序號
         (SELECT 0
                  FROM r_repair_t r2
                 where r2.serial_number = re.serial_number
                   and r2.test_group = re.test_group
                   and r2.test_time < to_date([[beginDate]],'YYYYMMDD'))
           and not exists --排除首次pass回流fail的序號
         (SELECT 0
                  FROM R_SN_DETAIL_T r3
                 where r3.serial_number = re.serial_number
                   and r3.group_name = re.test_group
                   and r3.error_flag = 0
                   and r3.in_station_time < re.test_time))
   order by test_time DESC  ) aa
 where test_time between to_date([[startInterval]],'yyyy/MM/dd HH24:MI:ss') and to_date([[endInterval]],'yyyy/MM/dd HH24:MI:ss')
order by rownum
 --------------------------------------------
#getLineFaultCurriculumVitae



#getStationFallItem
 --------------------------------------------
SELECT to_char(round(fcnt.cnt * 100 / scnt.cnt, 2), 'fm99999999990.00') || '%' fail_per,
       fcnt.test_code,
       nvl(fcnt.error_desc, fcnt.test_code) error_desc
  FROM (select nvl(re.test_code, 'N/A') as test_code,
               count(0) cnt,
               ec.error_desc
          from r_repair_t re
          left join c_error_code_t ec
            on ec.error_code = re.test_code
         where re.test_station = [[stationName]] 
           and re.test_line = [[lineName]] 
           and re.test_time >=
               to_date([[beginTime]],'YYYYMMDDhh24miss')
           and re.test_time <
               to_date([[endTime]],'YYYYMMDDhh24miss')
         group by re.test_code, ec.error_desc
         order by cnt desc) fcnt,
       (SELECT count(0) cnt
          FROM r_sn_detail_t sd
         where sd.line_name = [[lineName]] 
           and sd.station_name = [[stationName]] 
           and sd.in_station_time >=
               to_date([[beginTime]], 'YYYYMMDDhh24miss')
           and sd.in_station_time <
               to_date([[endTime]], 'YYYYMMDDhh24miss') 
        ) scnt  
--------------------------------------------
#getStationFallItem


#getLinePassRateTwoShift
 --------------------------------------------
SELECT YIELDTABLE.YIELD,
       YIELDTABLE.YIELD_S,
       CASE
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWWARNING, 95) THEN 0
         WHEN YIELDTABLE.YIELD >= NVL(LINE.YIELDR_LOWLIMIT, 90) THEN
          1 ELSE  2
       END MAX_STATE
  FROM (SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_T SUMM         
          WHERE (
		        [[shiftType]]='CUR' AND WORK_DATE = (CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
		        or
				[[shiftType]]='PRE' AND WORK_DATE = (CASE WHEN  [[shiftType]]='PRE' AND [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
				)
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
        UNION
        SELECT MIN(YIELD) * 100 YIELD,
               MIN(YIELD) * 100 || '%' YIELD_S
          FROM R_PQM_SUMMARY_SMT_T SUMM        
          WHERE (
		        [[shiftType]]='CUR' AND WORK_DATE = (CASE WHEN  [[nightFlag]]='B' THEN TO_CHAR(SYSDATE-1, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE, 'YYYYMMDD') END) 
		        or
				[[shiftType]]='PRE' AND WORK_DATE = (CASE WHEN  [[shiftType]]='PRE' AND [[nightFlag]]='F' THEN TO_CHAR(SYSDATE, 'YYYYMMDD') ELSE TO_CHAR(SYSDATE-1, 'YYYYMMDD') END) 
				)
            AND SUMM.LINE_NAME =[[lineName]]
            AND SUMM.SHIFT = [[shift]]
           ) YIELDTABLE
  LEFT JOIN C_LINE_CT_RUNR_PASSR_ALERT_T LINE
    ON LINE.LINE_NAME=[[lineName]] 
    WHERE YIELDTABLE.YIELD IS NOT NULL
 --------------------------------------------
#getLinePassRateTwoShift

#getlinePoorChartDesc
 --------------------------------------------
SELECT xAxis,
       sum(cnt) cnt,
       error_desc,
       round(sum(sum(cnt))
             over(order by sum(cnt) desc ROWS BETWEEN UNBOUNDED
                  PRECEDING AND CURRENT ROW) / sum(sum(cnt))
             over(order by sum(cnt) desc ROWS BETWEEN UNBOUNDED
                  PRECEDING AND UNBOUNDED FOLLOWING),
             4) as cum_ratio
  FROM (select nvl(re.test_code, 'N/A') as xAxis,
               count(0) cnt,
               ec.error_desc
          from r_repair_t re
         inner join (SELECT line_name,
                           max(to_date(decode(substr(section_range, 6, 4),
                                              '2400',
                                              to_char(to_date(t.work_date,
                                                              'YYYYMMDD') + 1,
                                                      'YYYYMMDD') || '000000',
                                              t.work_date ||
                                              substr(section_range, 6, 4) || '00'),
                                       'YYYYMMDDhh24miss')) end_time, --時間需精確到秒,REPAIR表的時間是精確到秒
                           min(to_date(t.work_date ||
                                       decode(substr(section_range, 0, 4),
                                              '2400',
                                              '0000',
                                              substr(section_range, 0, 4)) || '00',
                                       'YYYYMMDDhh24miss')) begin_time --時間需精確到秒,REPAIR表的時間是精確到秒
                      FROM (select to_char(to_date([[beginDate]],
                                                   'YYYYMMDD') - 1 + LEVEL,
                                           'YYYYMMDD') AS FDATE
                              from dual
                            CONNECT BY LEVEL <=
                                       (to_date([[endDate]], 'YYYYMMDD') -
                                       to_date([[beginDate]], 'YYYYMMDD') + 1)) tt --tdate別名使用重複，建議修改，以便他人閱讀
                     inner join (SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_t
                                union
                                SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_smt_t) t
                        on t.line_name = [[lineName]]
                       and ((work_date = FDATE and
                           (t.shift = 'DAY' or
                           (t.shift = 'NIGHT' and
                           decode(substr(section_range, 0, 4),
                                      '2400',
                                      '0000',
                                      substr(section_range, 0, 4)) >
                           '1200'))) or
                           (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1,
                                                 'YYYYMMDD') and
                           t.shift = 'NIGHT' and
                           substr(section_range, 0, 4) < '1200'))
                     group by FDATE, line_name) tdate
            on tdate.line_name = re.test_line
           and re.test_time between tdate.begin_time and tdate.end_time
           and re.test_group = [[stationName]]
          left join c_error_code_t ec
            on ec.error_code = re.test_code
         where exists ( --抓取首次pass的序號信息
                select 0
                  from (select serial_number,
                                test_group,
                                min(test_time) test_time
                           from r_repair_t r1
                          where r1.serial_number = re.serial_number
                            and r1.test_group = re.test_group
                          group by serial_number, test_group) rr
                 where rr.serial_number = re.serial_number
                   and rr.test_group = re.test_group
                   and re.test_time = rr.test_time)
           and not exists --排除本次時間範圍內二次不良的序號
         (SELECT 0
                  FROM r_repair_t r2
                 where r2.serial_number = re.serial_number
                   and r2.test_group = re.test_group
                   and r2.test_time < tdate.begin_time)
           and not exists --排除首次pass回流fail的序號
         (SELECT 0
                  FROM R_SN_DETAIL_T r3
                 where r3.serial_number = re.serial_number
                   and r3.group_name = re.test_group
                   and r3.error_flag = 0
                   and r3.in_station_time < re.test_time)
         group by re.test_code, ec.error_desc
        union all
        select nvl(nlf.error_code, 'N/A') as xAxis,
               fail_qty cnt,
               ec.error_desc
          from R_NO_LABEL_FAIL_T nlf
         inner join (SELECT line_name,
                           max(to_date(decode(substr(section_range, 6, 4),
                                              '2400',
                                              to_char(to_date(t.work_date,
                                                              'YYYYMMDD') + 1,
                                                      'YYYYMMDD') || '000000',
                                              t.work_date ||
                                              substr(section_range, 6, 4) || '00'),
                                       'YYYYMMDDhh24miss')) end_time, --時間需精確到秒,REPAIR表的時間是精確到秒
                           min(to_date(t.work_date ||
                                       decode(substr(section_range, 0, 4),
                                              '2400',
                                              '0000',
                                              substr(section_range, 0, 4)) || '00',
                                       'YYYYMMDDhh24miss')) begin_time --時間需精確到秒,REPAIR表的時間是精確到秒
                      FROM (select to_char(to_date([[beginDate]],
                                                   'YYYYMMDD') - 1 + LEVEL,
                                           'YYYYMMDD') AS FDATE
                              from dual
                            CONNECT BY LEVEL <=
                                       (to_date([[endDate]], 'YYYYMMDD') -
                                       to_date([[beginDate]], 'YYYYMMDD') + 1)) tt --tdate別名使用重複，建議修改，以便他人閱讀
                     inner join (SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_t
                                union
                                SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_smt_t) t
                        on t.line_name = [[lineName]]
                       and ((work_date = FDATE and
                           (t.shift = 'DAY' or
                           (t.shift = 'NIGHT' and
                           decode(substr(section_range, 0, 4),
                                      '2400',
                                      '0000',
                                      substr(section_range, 0, 4)) >
                           '1200'))) or
                           (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1,
                                                 'YYYYMMDD') and
                           t.shift = 'NIGHT' and
                           substr(section_range, 0, 4) < '1200'))
                     group by FDATE, line_name) tdate
            on tdate.line_name = nlf.line_name
           and nlf.set_time between tdate.begin_time and tdate.end_time
           and nlf.group_name = [[stationName]]
          left join c_error_code_t ec
            on ec.error_code = nlf.error_code)
group by xAxis, error_desc
order by cnt desc
 --------------------------------------------
#getlinePoorChartDesc
 
 
 
#getlinePoorDetailDesc
 --------------------------------------------
SELECT xAxis,
       sum(cnt) cnt,
       error_desc,
       round(sum(sum(cnt))
             over(order by sum(cnt) desc ROWS BETWEEN UNBOUNDED
                  PRECEDING AND CURRENT ROW) / sum(sum(cnt))
             over(order by sum(cnt) desc ROWS BETWEEN UNBOUNDED
                  PRECEDING AND UNBOUNDED FOLLOWING),
             4) as cum_ratio
  FROM (select nvl(re.test_code, 'N/A') as xAxis,
               count(0) cnt,
               ec.error_desc
          from r_repair_t re
         inner join (SELECT line_name,
                           max(to_date(decode(substr(section_range, 6, 4),
                                              '2400',
                                              to_char(to_date(t.work_date,
                                                              'YYYYMMDD') + 1,
                                                      'YYYYMMDD') || '000000',
                                              t.work_date ||
                                              substr(section_range, 6, 4) || '00'),
                                       'YYYYMMDDhh24miss')) end_time, --時間需精確到秒,REPAIR表的時間是精確到秒
                           min(to_date(t.work_date ||
                                       decode(substr(section_range, 0, 4),
                                              '2400',
                                              '0000',
                                              substr(section_range, 0, 4)) || '00',
                                       'YYYYMMDDhh24miss')) begin_time --時間需精確到秒,REPAIR表的時間是精確到秒
                      FROM (select to_char(to_date([[beginDate]],
                                                   'YYYYMMDD') - 1 + LEVEL,
                                           'YYYYMMDD') AS FDATE
                              from dual
                            CONNECT BY LEVEL <=
                                       (to_date([[endDate]], 'YYYYMMDD') -
                                       to_date([[beginDate]], 'YYYYMMDD') + 1)) tt --tdate別名使用重複，建議修改，以便他人閱讀
                     inner join (SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_t
                                union
                                SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_smt_t) t
                        on t.line_name = [[lineName]]
                       and ((work_date = FDATE and
                           (t.shift = 'DAY' or
                           (t.shift = 'NIGHT' and
                           decode(substr(section_range, 0, 4),
                                      '2400',
                                      '0000',
                                      substr(section_range, 0, 4)) >
                           '1200'))) or
                           (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1,
                                                 'YYYYMMDD') and
                           t.shift = 'NIGHT' and
                           substr(section_range, 0, 4) < '1200'))
                     group by FDATE, line_name) tdate
            on tdate.line_name = re.test_line
           and re.test_time between tdate.begin_time and tdate.end_time
           and re.test_group = [[stationName]]
          left join c_error_code_t ec
            on ec.error_code = re.test_code
         where exists ( --抓取首次pass的序號信息
                select 0
                  from (select serial_number,
                                test_group,
                                min(test_time) test_time
                           from r_repair_t r1
                          where r1.serial_number = re.serial_number
                            and r1.test_group = re.test_group
                          group by serial_number, test_group) rr
                 where rr.serial_number = re.serial_number
                   and rr.test_group = re.test_group
                   and re.test_time = rr.test_time)
           and not exists --排除本次時間範圍內二次不良的序號
         (SELECT 0
                  FROM r_repair_t r2
                 where r2.serial_number = re.serial_number
                   and r2.test_group = re.test_group
                   and r2.test_time < tdate.begin_time)
           and not exists --排除首次pass回流fail的序號
         (SELECT 0
                  FROM R_SN_DETAIL_T r3
                 where r3.serial_number = re.serial_number
                   and r3.group_name = re.test_group
                   and r3.error_flag = 0
                   and r3.in_station_time < re.test_time)
        and test_time between to_date([[startInterval]],'yyyy/MM/dd HH24:MI:ss') and to_date([[endInterval]],'yyyy/MM/dd HH24:MI:ss')
         group by re.test_code, ec.error_desc
        union all
        select nvl(nlf.error_code, 'N/A') as xAxis,
               fail_qty cnt,
               ec.error_desc
          from R_NO_LABEL_FAIL_T nlf
         inner join (SELECT line_name,
                           max(to_date(decode(substr(section_range, 6, 4),
                                              '2400',
                                              to_char(to_date(t.work_date,
                                                              'YYYYMMDD') + 1,
                                                      'YYYYMMDD') || '000000',
                                              t.work_date ||
                                              substr(section_range, 6, 4) || '00'),
                                       'YYYYMMDDhh24miss')) end_time, --時間需精確到秒,REPAIR表的時間是精確到秒
                           min(to_date(t.work_date ||
                                       decode(substr(section_range, 0, 4),
                                              '2400',
                                              '0000',
                                              substr(section_range, 0, 4)) || '00',
                                       'YYYYMMDDhh24miss')) begin_time --時間需精確到秒,REPAIR表的時間是精確到秒
                      FROM (select to_char(to_date([[beginDate]],
                                                   'YYYYMMDD') - 1 + LEVEL,
                                           'YYYYMMDD') AS FDATE
                              from dual
                            CONNECT BY LEVEL <=
                                       (to_date([[endDate]], 'YYYYMMDD') -
                                       to_date([[beginDate]], 'YYYYMMDD') + 1)) tt --tdate別名使用重複，建議修改，以便他人閱讀
                     inner join (SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_t
                                union
                                SELECT work_date,
                                       line_name,
                                       shift,
                                       section_range
                                  FROM r_pqm_daily_sum_smt_t) t
                        on t.line_name = [[lineName]]
                       and ((work_date = FDATE and
                           (t.shift = 'DAY' or
                           (t.shift = 'NIGHT' and
                           decode(substr(section_range, 0, 4),
                                      '2400',
                                      '0000',
                                      substr(section_range, 0, 4)) >
                           '1200'))) or
                           (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1,
                                                 'YYYYMMDD') and
                           t.shift = 'NIGHT' and
                           substr(section_range, 0, 4) < '1200'))
                     group by FDATE, line_name) tdate
            on tdate.line_name = nlf.line_name
           and nlf.set_time between tdate.begin_time and tdate.end_time
           and nlf.group_name = [[stationName]]
          left join c_error_code_t ec
            on ec.error_code = nlf.error_code)
group by xAxis, error_desc
order by cnt desc

--------------------------------------------
#getlinePoorDetailDesc

#getSMTSchedule1
 --------------------------------------------
SELECT B.line 線別,
       A.JIT_MO SAP工單,
       A.smt_mo 單一SMT工單,
       A.MO_VIRTUAL SMT生產工單,
       A.side 面別,
       A.model_name SMT機種,
       A.sb_model 組合料號,
       A.target_qty 目標數,
       TO_CHAR(A.plan_start_date, 'YYYY/MM/DD HH24:MI:SS') 計劃開始時間,
       TO_CHAR(A.plan_end_date, 'YYYY/MM/DD HH24:MI:SS') 計劃結束時間,
       TO_CHAR(A.target_date, 'YYYY/MM/DD HH24:MI:SS') 主線需求時間,
       DECODE(A.flag,
              '1',
              TO_CHAR(A.start_date, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(A.start_date, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(A.start_date, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(A.flag,
              '2',
              TO_CHAR(A.close_date, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
       A.LINE_RATE 線速,
       A.NORM_CAPACITY 標準產能,
       A.PRE_STATION 採集站,
       SAP1.WONO SAP母工單,
       SAP1.MATNR SAP母機種,
       DECODE(A.flag,
              '0',
              '未生產',
              '1',
              '生產中',
              '3',
              '暫停中',
              '4',
              '已關閉',
              '已生產') 狀態
  FROM R_SMT_SCHEDULEMO_DETAIL_T A
 INNER JOIN R_MO_SMT_INFO_T B
    ON A.id = B.id
  LEFT JOIN R_SAP_MO_MSG_LOG_T SAP
    ON A.jit_mo = SAP.wono
  LEFT JOIN r_sap_mo_msg_log_t SAP1
    ON SAP.M_WONO = SAP1.WONO
 WHERE A.flag =[[flag]]
   AND B.line IN (<<lineName>>)
   AND  A.PLAN_START_DATE BETWEEN sysdate-30 AND sysdate+7

 ORDER BY 實際結束時間 DESC

 --------------------------------------------
#getSMTSchedule1



#getSMTSchedule
--------------------------------------------
SELECT on_line.line, 
       on_line.side, 
       on_line.mo_number,  
       on_line.TARGET_QTY, 
       on_line.percent, 
       on_line.planpercent, 
       pre_line.start_date,
       pre_line.detail, 
                t13.archiver_lowwarning,
        t13.archiver_lowlimit,
        t13.Yieldr_Lowwarning,
        t13.yieldr_lowlimit
  FROM (SELECT A.LINE,
               A.SIDE,
               A.MO_NUMBER,
               A.TARGET_QTY,
               
               a.mo_flag,
               a.output_qty,
               a.start_date,
               
               decode(A.Target_qty,0,0,ROUND((NVL(A.OUTPUT_QTY, 0) / A.TARGET_QTY), 4)) * 100  PERCENT,
               (case a.norm_capacity
                 when 0 then
                  0
                 when null then
                  0
                 else
                  LEAST(round((case
                                when sysdate < a.start_date then
                                 0
                                else
                                 sysdate - a.start_date
                              end) * 24 * a.norm_capacity / a.target_qty,
                              4) * 100,
                        100)
               end)  planpercent
          FROM R_MO_SMT_INFO_T A
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on A.line = c.line_name
         WHERE A.MO_FLAG = '1'
           AND c.prod_area_id = [[prod_area_id]]) on_line
  left join ( --換線準備
             SELECT en.line,
                     en.start_date,
                     listagg(case en.alart_flag
                               when 0 then
                                en.part_type || '--未啟動報警'
                               when 1 then
                                en.part_type || '--已備，不報警'
                               when 2 then
                                en.part_type || '--未到預警時間'
                               when 3 then
                                en.part_type || '--預警'
                               when 4 then
                                en.part_type || '--警告'
                               else
                                en.part_type || '--' || en.alart_flag
                             end,
                             ',') within group(order by en.line) detail
               FROM (select *
                        from (select m.id,
                                     m.line,
                                     m.start_date,
                                     m.alart_flag,
                                     m.part_type,
                                     rank() over(partition by m.line order by m.line_order) rk
                                from (SELECT DISTINCT A.ID,
                                                      A.LINE,
                                                      A.MO_NUMBER,
                                                      to_char(A.START_DATE,
                                                              'yy-mm-dd hh24:mi') start_date,
                                                      a.LINE_ORDER,
                                                      b0.alart_flag,
                                                      b0.part_type
                                        from r_mo_smt_info_t a
                                       inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
                                          on a.line = c.line_name
                                        LEFT join r_pqm_line_prepare_smt_t b0
                                          on a.id = b0.id
                                        left join c_model_desc_t d
                                          on a.model_name = d.model_name
                                       where a.mo_flag = '0'
                                         and c.prod_area_id = [[prod_area_id]]) m)
                       where rk = 1) en
              group by en.line, en.start_date) pre_line
    on on_line.line = pre_line.line
left join  (select line_name,
                archiver_lowwarning,
                archiver_lowlimit,
                Yieldr_Lowwarning,
                yieldr_lowlimit
           from c_line_ct_runr_passr_alert_t
          where prod_area_id = [[prod_area_id]] --參數傳入       
            ) t13
        on on_line.line = t13.line_name  
order by on_line.line
--------------------------------------------
#getSMTSchedule






--SMT Phase1
#getOriginalSMTDVRdataByDayShift
 --------------------------------------------
Select line_name,section_range,plan_qty,real_qty,capacity,safe_rate,alert_rate
from (
select line_name, '1' odr,section_range,trunc(sum(plan_qty)) plan_qty,
                 sum(real_qty) real_qty,
                 decode (sum(work_time),0,'PLAN',round(sum(real_qty)/decode(sum(plan_qty),0,1,sum(plan_qty)),4)*100||'%') capacity,
                 round(avg(safe_rate),2) safe_rate,
                 round(avg(alert_rate),2) alert_rate 
                 from r_pqm_daily_sum_smt_t 
                 where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and line_name in (<<lineStr>>) 
                 and shift=[[shift]] and echelon_name =[[echelon_name]] and state>=0 
                 group by line_name,section_range
                 union 
select line_name,'2' odr,'ALL' section_range,sum(sum_plan) plan_qty,
                 sum(sum_real) real_qty,capacity*100||'%' capacity,0 safe_rate,0 alert_rate 
                 from R_PQM_SUMMARY_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and line_name in (<<lineStr>>) and shift=[[shift]] 
                 group by line_name,capacity
 ) t
                 order by line_name,odr,section_range                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
 --------------------------------------------
#getOriginalSMTDVRdataByDayShift

--SMT Phase1
#getOriginalSMTDVRdataByNightShift1
 --------------------------------------------
select line_name,'1' odr,section_range,trunc(sum(plan_qty)) plan_qty,
                   sum(real_qty) real_qty,decode (sum(work_time),0,'PLAN',round(sum(real_qty)/decode(sum(plan_qty),0,1,sum(plan_qty)),4)*100||'%') capacity,
                   round(avg(safe_rate),2) safe_rate,
                   round(avg(alert_rate),2) alert_rate 
                   from r_pqm_daily_sum_smt_t 
                   where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                   and line_name in (<<lineStr>>) 
                   and shift=[[shift]] 
                   and section_range>'1200' 
                   and echelon_name=[[echelon_name]] and state>=0 
                   group by line_name,section_range 
                   union 
                   select line_name,'2' odr,'ALL' section_range,
                   sum(sum_plan) plan_qty,
                   sum(sum_real) real_qty,
                   capacity*100||'%' capacity,
                   0 safe_rate,
                   0 alert_rate 
                   from R_PQM_SUMMARY_SMT_T 
                   where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                   and line_name in (<<lineStr>>) and shift=[[shift]] 
                   group by line_name,capacity
                   order by line_name,odr,section_range                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
 --------------------------------------------
#getOriginalSMTDVRdataByNightShift1

--SMT Phase1
#getOriginalSMTDVRdataByNightShift2
 --------------------------------------------
select line_name, '1' odr,section_range,
            trunc(sum(plan_qty)) plan_qty,
            sum(real_qty) real_qty,
            decode (sum(work_time),0,'PLAN',round(sum(real_qty)/decode(sum(plan_qty),0,1,sum(plan_qty)),4)*100||'%') capacity,
            round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate 
            from r_pqm_daily_sum_smt_t 
            where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') 
            and line_name in (<<lineStr>>) and shift=[[shift]] and section_range>'1200' and echelon_name=[[echelon_name]] and state>=0 
            group by line_name,section_range 
            union 
            select line_name, '2' odr,section_range,trunc(sum(plan_qty)) plan_qty,
            sum(real_qty) real_qty,decode (sum(work_time),0,'PLAN',round(sum(real_qty)/decode(sum(plan_qty),0,1,sum(plan_qty)),4)*100||'%') capacity,
            round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate 
            from r_pqm_daily_sum_smt_t 
            where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
            and line_name in (<<lineStr>>) 
            and shift=[[shift]] and section_range<'1200' 
            and echelon_name=[[echelon_name]] and state>=0 
            group by line_name,section_range 
            union 
            select line_name,'3' odr,'ALL' section_range,sum(sum_plan) plan_qty,
            sum(sum_real) real_qty,capacity*100||'%' capacity,0 safe_rate,0 alert_rate 
            from R_PQM_SUMMARY_SMT_T 
            where work_date=TO_CHAR(SYSDATE-1,'YYYYMMDD') 
            and line_name in (<<lineStr>>) 
            and shift=[[shift]] 
            group by line_name,capacity
            order by line_name,odr,section_range                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
 --------------------------------------------
#getOriginalSMTDVRdataByNightShift2

--SMT Phase1
#getOriginalSMTChangeLineInfo
--------------------------------------------
SELECT DISTINCT 
                A.LINE,
                A.MO_NUMBER, 
                a.target_qty,
                substr(A.JIT_MO_NUMBER, 1, 60) JIT_MO_NUMBER,--‘群組工單’ ?
                A.SIDE,
                A.MODEL_NAME,
                substr(A.SB_MODEL, 1, 60) SB_MODEL,--組合料號 
                to_char(A.START_DATE, 'mm-dd hh24:mi') start_date,--換線時間
                --A.CLOSE_DATE,
                (CASE
                  WHEN A.START_DATE <= SYSDATE THEN
                   0
                  ELSE
                   ROUND((A.START_DATE - SYSDATE) * 24, 2)
                END) REMAIN_TIME,--剩餘時間
                --D.MODEL_SERIAL,
                D.BOM_NO,
                D.MFG_PART,
                D.PWB_NO,
                D.PCB_CODE,
                D.PCB_QTY,
                D.POINT_A,
                D.POINT_B,
                ce.PART             
from r_mo_smt_info_t a 
INNER JOIN ( select * from c_prod_area_line_t where delete_flag='0' ) T
                 ON T.LINE_NAME = a.LINE
  INNER JOIN (select * from sfcs.c_prod_area_t where  delete_flag='0') pt
                 ON T.PROD_AREA_ID = pt.PROD_AREA_ID
  left join c_model_desc_t d
    on a.model_name = d.model_name 
  left join (
              select 
                 tt.id,
                 tt.line_name,
                 tt.mo_number,
                (listagg(tt.part_type || ']' ||tt.alart_flag||to_char(
                                                                      decode(tt.alart_flag,1,tt.confirm_time,
                                                                             2,aa.start_date-tt.pre_time,
                                                                             3,aa.start_date-tt.pre_time,
                                                                             4,aa.start_date-tt.pre_time,
                                                                             5,aa.start_date-tt.pre_time,aa.start_date),'mm-dd hh24:mi'),'}') 
                 within group(order by tt.id))PART
              from r_mo_smt_info_t aa 
              left join (select distinct* from r_pqm_line_prepare_smt_t) tt on aa.id=tt.id
              group by tt.ID,tt.line_name,tt.mo_number,aa.start_date
              ) ce
  on ce.id=a.id           
where a.mo_flag = '0'
   and a.start_date < sysdate + (4 / 24)
   and a.line in (<<lineStr>>)
   and pt.prod_area_id=[[prod_area_id]]
--------------------------------------------
#getOriginalSMTChangeLineInfo

#getProdAreaType
 --------------------------------------------
select 
pa.area_flag AREAFLAG --區域類型（0:主線,1:SMT）
from sfcs.c_prod_area_t  pa  
where  pa.prod_area_id = [[prod_area_id]]
and pa.delete_flag='0'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
 --------------------------------------------
#getProdAreaType

#getSMTChangeLineItem
 --------------------------------------------
 select distinct p.PART_TYPE
  from C_PQM_PART_ALART_T p
 left join c_user_prod_plant_t u
    on p.prod_plant = u.prod_plant
 where p.line_type = 1
   and u.emp_no = [[empNo]] or u.emp_no is null
 --------------------------------------------
#getSMTChangeLineItem

#getQualityPassFailQtyByLine_Day
--------------------------------------------
--Sean, NEW 
select X_AXLE,Y_AXLE from (
SELECT GROUP_NAME X_AXLE,
  (CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
        WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
        ELSE ROUND(SUM(PASS_QTY) /
               DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                      SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
      FROM (SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
              LEFT JOIN C_STATION_CONFIG_T SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND T.SHIFT = 'DAY'
               AND T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
          )YIELD         
     GROUP BY GROUP_NAME,GROUP_INDEX
    )AA
LEFT JOIN (select GROUP_NAME,MIN(STATION_IDX) STATION_IDX,MIN(STATION_NUMBER) STATION_NUMBER 
           from  C_STATION_CONFIG_T T WHERE T.LINE_NAME=[[lineName]] GROUP BY GROUP_NAME) BB ON AA.X_AXLE=BB.GROUP_NAME
ORDER BY BB.STATION_IDX,BB.STATION_NUMBER
--------------------------------------------
#getQualityPassFailQtyByLine_Day

#getQualityPassFailQtyByLine_Night
--------------------------------------------
--Sean, NEW 
select X_AXLE,Y_AXLE from (
SELECT GROUP_NAME X_AXLE,
  (CASE WHEN SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0) = 0 THEN 1
        WHEN SUM(PASS_QTY) = 0 AND NVL(SUM(FAIL_QTY), 0) > 0 THEN 0.0001
        ELSE ROUND(SUM(PASS_QTY) /
               DECODE(SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0), 0, 1,
                      SUM(PASS_QTY) + NVL(SUM(FAIL_QTY), 0)), 4) END)*100 Y_AXLE
      FROM ( --前一个夜班，前半夜，日期為上一天
            SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
               LEFT JOIN C_STATION_CONFIG_T SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND T.WORK_DATE = TO_CHAR(SYSDATE-1, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)>'1200'
            UNION ALL --前一个夜班，后半夜
            SELECT T.GROUP_NAME,
                   PASS_QTY,
                   FAIL_QTY,
                   MAX(NVL(sc.station_idx,0)) OVER (PARTITION BY sc.line_name,sc.section_name,sc.group_name) GROUP_INDEX
              FROM R_PQM_LINE_GROUP_YIELD_T T
               LEFT JOIN C_STATION_CONFIG_T SC ON T.LINE_NAME=SC.LINE_NAME AND T.GROUP_NAME=SC.GROUP_NAME
             WHERE T.LINE_NAME = [[lineName]]
               AND T.SHIFT = 'NIGHT'
               AND T.WORK_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
               AND SUBSTR(SECTION_RANGE,1,4)<'1200')YIELD         
     GROUP BY GROUP_NAME,GROUP_INDEX
    )AA
LEFT JOIN (select GROUP_NAME,MIN(STATION_IDX) STATION_IDX,MIN(STATION_NUMBER) STATION_NUMBER 
           from  C_STATION_CONFIG_T T WHERE T.LINE_NAME=[[lineName]] GROUP BY GROUP_NAME) BB ON AA.X_AXLE=BB.GROUP_NAME
ORDER BY BB.STATION_IDX,BB.STATION_NUMBER
--------------------------------------------
#getQualityPassFailQtyByLine_Night

#getUtilizationRateByShift
 --------------------------------------------
with EqpUti as (
select EQUIPMENT_ID,
case when TRUNC(round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2))=100 then 100 else round(sum(UP_TIME)/((SYSDATE-to_date([[sectionFrom]],'YYYYMMDDHH24MISS'))*1440)*100,2) end as uti 
from (
 select BASIC.EQUIPMENT_ID,to_char( PUB.BEGIN_POINT,'YYYY-MM-DD hh24:mi:ss') as BEGIN_POINT,to_char( PUB.END_POINT,'YYYY-MM-DD hh24:mi:ss') as END_POINT,
                round(( case when  nvl(end_point,SYSDATE) >=  SYSDATE  then SYSDATE   else end_point end  - 
                           CASE WHEN PUB.BEGIN_POINT < TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') 
                                THEN   TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') else PUB.BEGIN_POINT
                                END) *(1440.0),4) as UP_TIME,
                                row_number() over(partition by BASIC.EQUIPMENT_ID order by PUB.BEGIN_POINT ) as sn_by_eqp,
                                count(*) over(partition by BASIC.EQUIPMENT_ID ) as cnt_by_eqp 
          FROM r_equip_status_t  PUB
         RIGHT JOIN  (Select * from C_EQUIPMENT_BASIC_T 
                              where  EQUIPMENT_ID = cast( [[EQUIPMENT_ID]] as raw(16)) 
                      ) BASIC
            ON BASIC.EQUIPMENT_ID = PUB.EQUIPMENT_ID
           AND PUB.STATUS = 0 
			AND (
				( PUB.END_POINT >  TO_DATE([[sectionFrom]], 'YYYYMMDDHH24MISS') AND PUB.BEGIN_POINT <= SYSDATE) 
				OR
				PUB.END_POINT IS NULL
                )     
) tmp
where tmp.END_POINT is not null or sn_by_eqp=cnt_by_eqp
group by EQUIPMENT_ID
)
SELECT  TO_CHAR(nvl(uti,0)) || '%' as  RATE
from EqpUti                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
 --------------------------------------------
#getUtilizationRateByShift

#moPassFailByGroupNew
 --------------------------------------------
with repaire as 
( 
select MODEL_NAME,MO_NUMBER,TEST_GROUP,count(distinct SERIAL_NUMBER ) as repass
from (
      SELECT a.MODEL_NAME,a.MO_NUMBER,a.group_name as TEST_GROUP ,a.SERIAL_NUMBER  
      FROM R_SN_DETAIL_T a,(
      SELECT MODEL_NAME,MO_NUMBER,TEST_GROUP,SERIAL_NUMBER  
      FROM R_REPAIR_T  
      WHERE MO_NUMBER =[[moNumber]]
      Group by MODEL_NAME,MO_NUMBER,TEST_GROUP,SERIAL_NUMBER
      having min(case when FINISH_FLAG='Y' then 'Y' ELSE ' ' END)='Y' 
      )b
      WHERE  1=1
      and a.MO_NUMBER =[[moNumber]]
      AND a.ERROR_FLAG = '0'
      and a.SERIAL_NUMBER=b.SERIAL_NUMBER
      and a.MODEL_NAME=b.MODEL_NAME
      and a.MO_NUMBER=b.MO_NUMBER
      and a.group_name=b.TEST_GROUP
    ) t
group by  MODEL_NAME,MO_NUMBER,TEST_GROUP
),
refail as (
 SELECT MODEL_NAME,
                    MO_NUMBER,
                    TEST_GROUP,
                    COUNT(DISTINCT SERIAL_NUMBER) FAIL_QTY
               FROM R_REPAIR_T T1
              WHERE MO_NUMBER =[[moNumber]]
                AND FINISH_FLAG <> 'Y'
              GROUP BY MODEL_NAME, MO_NUMBER, TEST_GROUP
),
rec_t as (
select a.mo_number,a.model_name,a.group_name,a.pass_qty,a.f_fail_qty,b.ROUTE_CODE 
from (
SELECT MO_NUMBER,
               MODEL_NAME,
               GROUP_NAME,
               SUM(PASS_QTY) PASS_QTY,
               SUM(FAIL_QTY) F_FAIL_QTY
          FROM R_STATION_REC_T 
         WHERE MO_NUMBER =[[moNumber]]
         GROUP BY MO_NUMBER, MODEL_NAME, GROUP_NAME
) a , R_MO_BASE_T b
   where a.MO_NUMBER = b.MO_NUMBER
   AND a.MODEL_NAME = b.MODEL_NAME  
)
,
factRecRoute as (
select a.mo_number,a.model_name,b.GROUP_NEXT as group_name,a.pass_qty,a.f_fail_qty,b.STEP_SEQUENCE
from rec_t a, C_ROUTE_CONTROL_T  b
where a.ROUTE_CODE=b.ROUTE_CODE
   AND  a.GROUP_NAME=b.GROUP_NEXT 
   AND b.STATE_FLAG = 0
   AND b.ROUTE_DESC = '0'
   AND b.GROUP_NEXT NOT IN
        (
         SELECT GROUP_NAME
           FROM C_ROUTE_CONTROL_T
           WHERE ROUTE_CODE in (select route_code from rec_t )
           AND ROUTE_DESC = '1'
        )
    AND b.GROUP_NAME NOT IN
        (
          SELECT GROUP_NEXT a
          FROM C_ROUTE_CONTROL_T
          WHERE ROUTE_CODE in (select route_code from rec_t )
          AND STATE_FLAG = 1
        )
) 

select  a.GROUP_NAME ,
       NVL(a.PASS_QTY, 0) FIRST_PASS_QTY,
       NVL(a.F_FAIL_QTY, 0) FIRST_FAIL_QTY,
       TRUNC(NVL(a.PASS_QTY, 0) / (NVL(a.PASS_QTY, 0) + NVL(a.F_FAIL_QTY, 0)), 4) * 100 || '%' FIRST_PASS_RATE,
       NVL(a.PASS_QTY, 0) + NVL(b.REPASS, 0) TOTAL_PASS_QTY,
       NVL(c.FAIL_QTY, 0) TOTAL_FAIL_QTY,       
       TRUNC((NVL(a.PASS_QTY, 0) + NVL(b.REPASS, 0)) /
             (NVL(a.PASS_QTY, 0) + NVL(b.REPASS, 0) + NVL(c.FAIL_QTY, 0)),
             4) * 100 || '%' TOTAL_PASS_RATE
from factRecRoute a left join repaire b 
    ON a.MO_NUMBER = b.MO_NUMBER
    AND a.MODEL_NAME = b.MODEL_NAME
    AND a.GROUP_NAME = b.TEST_GROUP
    left join refail c
        ON a.MO_NUMBER = c.MO_NUMBER
       AND a.MODEL_NAME = c.MODEL_NAME
       AND a.GROUP_NAME = c.TEST_GROUP
         order by STEP_SEQUENCE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
 --------------------------------------------
#moPassFailByGroupNew

#getAreaMachineList
 --------------------------------------------
SELECT cast( EQUIPMENT_ID as varchar2(16)) as EQUIPMENT_ID,
       EQUIPMENT_CODE,
       STATUS,
       STATION_NAME,
       ROWNUM,
        [[area]] AREA,
       LINE_NAME      LINE,
       [[ModelName]] MODELNAME,
       [[SchemaName]] SCHEMANAME,
       IMAGE_NAME,
		case when STATUS  >= 8 then 'equipmentNoDataPage' ELSE 'DashBoardDetail-PQM2.0' END IDD,
		([[ImgURL]]||IMAGE_NAME)	IMAGEURL,
		DifferNum IDD2
  FROM (SELECT DISTINCT DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_ID) EQUIPMENT_ID,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      BASIC.EQUIPMENT_CODE) EQUIPMENT_CODE,
               CASE
                 WHEN (BASIC.EQUIPMENT_ID IS NULL) OR (ET.CONNECT_TYPE =0) THEN
                   99
                 ELSE
                   DECODE(NVL(PUB.STATUS, -1),-1,
                          DECODE(BASIC.STATUS_CODE, 0, 10, -1),
                          NVL(PUB.STATUS, -1))
                 END STATUS,
               DECODE(BASIC.EQUIPMENT_ID,
                      NULL,
                      SC.STATION_NAME,
                      NVL(BASIC.DESCRIPTION, SC.STATION_NAME)) STATION_NAME,
               NVL(SC.STATION_IDX,0) STATION_IDX,
               SC.LINE_NAME,
               CASE 
                 WHEN BASIC.EQUIPMENT_ID IS NULL THEN
                   'PEOPLE.jpg'
                 WHEN ET.CONNECT_TYPE = 0 THEN 
                  -- NVL(ET.IMAGE_NAME,'PEOPLE.jpg')  
                    'PEOPLE.jpg'
                 ELSE 
                  -- ET.IMAGE_NAME
                    ET.TYPE_CODE || '.jpg'
                 END IMAGE_NAME,
        round(to_number(NVL((sysdate-collect_date),0))* 24 )  DifferNum
          FROM (Select * from C_STATION_CONFIG_T where line_name in (
                                                                    select line_name 
                                                                    from C_PROD_AREA_LINE_T 
                                                                    where prod_area_id=[[area]]
                                                                    AND delete_flag='0'
                                                                    ) 
																	AND NVL(task_code,0) <>1 
																	
                                                                    ) SC
          LEFT JOIN C_EQUIPMENT_BASIC_T BASIC
            ON SC.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
            LEFT JOIN C_EQUIP_TYPE_T ET ON BASIC.TYPE_ID=ET.TYPE_ID
          LEFT JOIN R_EQUIPMENT_BASIC_DATA_T PUB
            ON PUB.EQUIPMENT_ID = BASIC.EQUIPMENT_ID
         WHERE 1=1
         ORDER BY STATION_IDX,EQUIPMENT_ID)
order by LINE_NAME,STATION_IDX
--------------------------------------------
#getAreaMachineList

#getProdAreaListByFactory
--------------------------------------------
select distinct 
       to_char(pa.prod_area_id) PROD_AREA_ID, 
	   pa.prod_area_code PROD_AREA_CODE,
       pa.prod_area_desc PROD_AREA 
from sfcs.C_PROD_AREA_T pa 
where pa.factory = [[factory]]
and  pa.delete_flag='0'
order by PROD_AREA
--------------------------------------------
#getProdAreaListByFactory


--------------2018/11/06 Young Add for New API 

#getAllByBadReasonEchelonSumRepairNum
--------------------------------------------
SELECT et.ERROR_DESC,rt.test_code, count(1) repair_count
          FROM r_repair_t rt
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on rt.test_line = c.line_name
           and c.prod_area_id = [[prod_area_id]]
         inner join (SELECT t.line_name,
                           et.shift,
                           to_date(to_char(sysdate  , 'yyyymmdd') ||
                                   min(et.section_from),
                                   'yyyymmdd HH24miss') section_from,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   max(et.section_to),
                                   'yyyymmdd HH24miss') section_to
                      FROM c_line_echelon_t t
                     inner join c_echelon_section_t et
                        on t.echelon_name = et.echelon_name
                       and et.shift = 'DAY'
                     group by t.line_name, et.shift) m
            on rt.test_line = m.line_name
			AND rt.test_line in (<<lineName>>)
		inner join c_error_code_t et on et.error_code = rt.test_code
         where rt.test_time between (case
                 when sysdate between m.section_from and m.section_to then
                  m.section_from
                 else
                  case
                    when to_char(sysdate , 'hh24') >=
                         to_char(m.section_to, 'hh24') then
                     m.section_to
                    else
                     m.section_to - 1
                  end
               end)
           and sysdate
         group by rt.test_code,et.ERROR_DESC
order by repair_count DESC
--------------------------------------------
#getAllByBadReasonEchelonSumRepairNum


#getOriginalDVRdataByDayShift
--------------------------------------------
select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 '1' odr
                 from R_PQM_DAILY_SUM_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
				 
				line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] and echelon_name=[[echelon_name]]
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'2' odr 
                 from R_PQM_SUMMARY_T 
				where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and line_name in (
                     	select distinct line_name  from R_PQM_DAILY_SUM_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
                            line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                            and shift=[[shift]] and echelon_name=[[echelon_name]] 
                            and process_name in (<<processNameStr>>)
                 )/*('APPLE-N5','APPLE-N6')*/ 
				and shift=[[shift]] 
				and process_name in (<<processNameStr>>) 

union all 

select line_name,process_name,section_range,to_char(DECODE(AVG(capacity),0,AVG(plan_qty),trunc(sum(real_qty)/AVG(capacity))),'FM999,999,999') plan_qty,
                 to_char(sum(real_qty),'FM999,999,999') real_qty,AVG(capacity) capacity,
                 round(avg(safe_rate),2) safe_rate,round(avg(alert_rate),2) alert_rate,
				 '3' odr
                 from R_PQM_DAILY_SUM_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
				
				line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                 and shift=[[shift]] and echelon_name=[[echelon_name]]
				and process_name in (<<processNameStr>>) 
                 group by line_name,process_name,section_range 
union all 
select line_name,process_name, 'ALL' section_range,to_char(sum_plan,'FM999,999,999') plan_qty,
                 to_char(sum_real,'FM999,999,999') real_qty,capacity capacity,0 safe_rate,0 alert_rate,
				'4' odr 
                 from R_PQM_SUMMARY_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') 
                 and 
				
				line_name in (
                    	select distinct line_name  from R_PQM_DAILY_SUM_SMT_T where work_date=TO_CHAR(SYSDATE,'YYYYMMDD') and 
                            line_name in (<<lineStr>>)/*('APPLE-N5','APPLE-N6')*/
                            and shift=[[shift]] and echelon_name=[[echelon_name]] 
                            and process_name in (<<processNameStr>>)
                )/*('APPLE-N5','APPLE-N6')*/ and shift=[[shift]] 
				and process_name in (<<processNameStr>>) 

                order by line_name,process_name,odr,section_range 
--------------------------------------------
#getOriginalDVRdataByDayShift


#test1
--------------------------------------------
SELECT  rt.model_name, count(1) repair_count
          FROM r_repair_t rt
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on rt.test_line = c.line_name
           and c.prod_area_id = [[prod_area_id]]
         inner join (SELECT t.line_name,
                           et.shift,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   min(et.section_from),
                                   'yyyymmdd HH24miss') section_from,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   max(et.section_to),
                                   'yyyymmdd HH24miss') section_to
                      FROM c_line_echelon_t t
                     inner join c_echelon_section_t et
                        on t.echelon_name = et.echelon_name
                       and et.shift = 'DAY'
                     group by t.line_name, et.shift) m
            on rt.test_line = m.line_name
            AND rt.test_line in (<<lineName>>)
         where rt.test_time between (case
                 when sysdate between m.section_from and m.section_to then
                  m.section_from
                 else
                  case
                    when to_char(sysdate , 'hh24') >=
                         to_char(m.section_to, 'hh24') then
                     m.section_to
                    else
                     m.section_to - 1
                  end
               end)
           and sysdate
         group by rt.test_line, rt.model_name
order by repair_count DESC
--------------------------------------------
#test1

#getLineListByEchelon
--------------------------------------------
select linet.LINE_NAME
from c_line_echelon_t let inner join C_PROD_AREA_LINE_T linet
on let.LINE_NAME = linet.LINE_NAME
where  let.ECHELON_NAME =  [[echelon_name]] 
and linet.delete_flag = 0 
and linet.prod_area_id = [[prod_area_id]]
order by LINE_NAME
--------------------------------------------
#getLineListByEchelon


#getMoStatus
--------------------------------------------
SELECT FLAG,STATE FROM C_MO_STATUS_TYPE_T
--------------------------------------------
#getMoStatus

#getSchedule1
--------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT'  
AND 
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS') BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
ORDER BY 實際結束時間 DESC
--------------------------------------------
#getSchedule1


#getLevel3ParameterItemArea
 --------------------------------------------
SELECT PARAMETER_ITEM_ID, PARAMETER_ITEM_NAME, CHART_TYPE
  FROM (SELECT CP.PARAMETER_CODE PARAMETER_ITEM_ID,
               EP.PARAM_DESC ||
               DECODE(CP.CALC_TYPEID,7,' XBar R-Chart',NULL)||
        	   DECODE(EP.PARAM_UNIT,
                      NULL,
                      NULL,
                      '（單位:' || EP.PARAM_UNIT || '）') PARAMETER_ITEM_NAME,
               CP.CHART_TYPE
          FROM C_LEVEL_EQUIP_CASE_T EC
         INNER JOIN C_EQUIPMENT_BASIC_T BASIC
            ON EC.EQUIP_TYPE_ID = BASIC.TYPE_ID
         INNER JOIN C_LEVEL_CASE_PARAM_T CP
            ON EC.LEVEL3_ID = CP.LEVEL3_ID
         INNER JOIN C_EQUIP_PARAM_T EP
            ON BASIC.TYPE_ID = EP.EQUIP_TYPE_ID
           AND CP.PARAMETER_CODE = EP.PARAM_CODE
         WHERE BASIC.EQUIPMENT_ID = [[equipmentID]]
          AND EC.LEVEL3_ID = [[level3ID]]
          AND CP.PARAMETER_CODE = [[ParameterID]]
        UNION
        SELECT CP.PARAMETER_CODE PARAMETER_ITEM_ID,
               EP.PARAM_DESC ||
               DECODE(EP.PARAM_UNIT,
                      NULL,
                      NULL,
                      '（單位:' || EP.PARAM_UNIT || '）') PARAMETER_ITEM_NAME,
               CP.CHART_TYPE
          FROM C_LEVEL_CASE_PARAM_T CP
         INNER JOIN C_LEVEL3_VIRTUAL_PARAM_T EP
            ON CP.PARAMETER_CODE = EP.PARAM_CODE
         WHERE CP.LEVEL3_ID = [[level3ID]]
           AND CP.PARAMETER_CODE = [[ParameterID]]
           )
 WHERE ROWNUM = 1
 -------------------------------------------- 
#getLevel3ParameterItemArea

#getSMTMissingPartDatas
--------------------------------------------
SELECT B.LINE_NAME 線別, 
B.SFCS_MO 工單, 
B.SFCS_MODEL 機種,
A.VORNR opco, 
to_char(B.SCHL_QTY,'FM999,999,999')  目標數, 
B.COLL_STATION 投入站, 
to_char(B.COLL_QTY,'FM999,999,999')  投入數, 
ROUND(B.COLL_QTY/B.SCHL_QTY,4)*100||'%' 進度, 
B.OUTPUT_STATION 產出站, 
to_char(B.OUTPUT_QTY,'FM999,999,999')  產出數,
TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME 計劃開始時間,
       TO_CHAR(A.PLN_FINS_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_FINS_TIME 計劃結束時間,
     TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計開始時間,
       TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS') 預計結束時間,
       DECODE(B.Flag,
              '1',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '2',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '3',
              TO_CHAR(B.START_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際開始時間,
       DECODE(B.Flag,
              '2',
              TO_CHAR(B.CLOSE_DATE, 'YYYY/MM/DD HH24:MI:SS'),
              '') 實際結束時間,
round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/60,0)||'m/'||TO_CHAR(round((B.SCHL_QTY-B.COLL_QTY)*A.OI_RATE/3600,1),'FM999990.0')||'h' "剩餘時間",
A.EXCH_TIME 換線時間,
DECODE(B.FLAG,'0','未生產','1','生產中','3','暫停中','4','已關閉','已生產') 狀態 
FROM R_SCHEDULE_SAP_T A 
INNER JOIN R_SCHEDULE_SFCS_T B 
ON A.SCHL_NO = B.SCHL_NO 
WHERE NVL(B.START_DATE,TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' || A.PLN_STAT_TIME,'YYYY/MM/DD HH24:MI:SS')) BETWEEN sysdate-30 AND sysdate+7 
AND B.FLAG = [[flag]] 
AND B.LINE_NAME IN (<<lineName>>) 
AND A.VORNR IN (<<opcode>>) 
AND NVL(A.SCHL_STAS,'N/A') <> 'PT'  
AND 
                   TO_DATE(TO_CHAR(A.PLN_STAT_DATE, 'YYYY/MM/DD') || ' ' ||
                           A.PLN_STAT_TIME,
                           'YYYY/MM/DD HH24:MI:SS') BETWEEN SYSDATE - 30 AND
               SYSDATE + 7
ORDER BY 實際結束時間 DESC
--------------------------------------------
#getSMTMissingPartDatas

#getLineListByEchelon
--------------------------------------------
select LINE_NAME from c_line_echelon_t where ECHELON_NAME = [[echelon_name]]
order by LINE_NAME
--------------------------------------------
#getLineListByEchelon

#getHistoryMES
--------------------------------------------
with factMES as (
  select LINE_NAME,WORK_DATE, to_char(INPUTDATE,'YYYY-MM-DD HH24:MI:SS') as input_Time,
    WORK_SECTION,to_char(to_date(WORK_DATE,'YYYYMMDD'),'YYYY-MM-DD')||' '|| to_char(TRUNC((WORK_SECTION-1)/2),'FM00')||to_char(mod((WORK_SECTION-1),2)*30,'FM00') ||'-'||to_char(TRUNC(WORK_SECTION/2),'FM00')||to_char(mod(WORK_SECTION,2)*30,'FM00') as WORK_TIME, GROUP_NAME,MO_NUMBER,MODEL_NAME,SECTION_NAME,PASS_QTY,FAIL_QTY,REPASS_QTY,REFAIL_QTY,0 as LAB_REPAIR_QTY,0 as NOLAB_REPAIR_QTY
   from R_STATION_REC_T 
    where 1=1
              and WORK_DATE  in ( to_char(sysdate,'YYYYMMDD'),to_char(sysdate-1,'YYYYMMDD'),to_char(sysdate-2,'YYYYMMDD'),to_char(sysdate+2,'YYYYMMDD') )
   -- and INPUTDATE > to_date('2018-12-05','YYYY-MM-DD')  -1 and  INPUTDATE < to_date('2018-12-05','YYYY-MM-DD') + 1
    and line_name in (<<linename>>)
    and (PASS_QTY + FAIL_QTY) > 0 
   ),
    lineFlag as (
    select a.line_name,case when b.area_flag=1 then 'SMT' ELSE 'NotSMT' END as AREA_FLAG
    from (select * from c_prod_area_line_t where line_name in (<<linename>>) and delete_flag='0' ) a left join (select * from sfcs.c_prod_area_t where  delete_flag='0') b
    ON a.PROD_AREA_ID = b.PROD_AREA_ID
    )
   select 
    a.LINE_NAME,c.AREA_FLAG,a.WORK_TIME,a.WORK_DATE,a.INPUT_TIME,a.WORK_SECTION,a.GROUP_NAME,a.MO_NUMBER,a.MODEL_NAME,a.SECTION_NAME,
    a.PASS_QTY,
    a.FAIL_QTY,
    a.REPASS_QTY,
    a.REFAIL_QTY,
    a.LAB_REPAIR_QTY,
    a.NOLAB_REPAIR_QTY,
    b.PCB_QTY_FLAG,
    b.PCB_QTY as PCB_COUNT_BASE,
    a.PASS_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0 then  b.PCB_QTY  else 1  end as SMT_PASS_QTY,
     a.FAIL_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0 then  b.PCB_QTY  else 1  end as SMT_FAIL_QTY,
         a.REPASS_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0  then  b.PCB_QTY  else 1  end as SMT_REPASS_QTY,
             a.REFAIL_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0  then  b.PCB_QTY  else 1  end as SMT_REFAIL_QTY,
                a.LAB_REPAIR_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0  then  b.PCB_QTY  else 1  end as SMT_LAB_REPAIR_QTY,
                   a.NOLAB_REPAIR_QTY * case when c.AREA_FLAG='SMT' and nvl(b.PCB_QTY_FLAG,1) =0  then  b.PCB_QTY  else 1  end as SMT_NOLAB_REPAIR_QTY
    from factMES a left join  C_MODEL_DESC_T b
    on a.model_name=b.model_name
    left join lineFlag c
    on a.line_name=c.line_name
              order by a.WORK_DATE, a.INPUT_TIME,a.WORK_SECTION,a.WORK_TIME   
--------------------------------------------
#getHistoryMES

#taktTime
--------------------------------------------
with mes as (
select b.seq seq,a.in_station_time in_station_time,round((b.in_station_time-a.in_station_time)*24*60*60) ATT,
b.model_name model_name1,b.mo_number mo_number,b.line_name line_name,b.group_name group_name,b.serial_number serial_number,
a.serial_number last_serial_number ,b.in_station_time last_in_station_time,A.model_name model_name,C.OI_RATE OI_RATE,'dataFromSerialNumber' dataFrom
  from (select aa.* ,rownum seq from (select c1.* from  r_sn_ATT_t c1 
                                   join c_sn_ATT_t D on c1.group_name = D.GROUP_NAME and D.LINE_NAME = c1.line_name and D.VALID_FLAG = 0
                                    where c1.line_name = [[LineName]]
                                   and c1.in_station_time  between sysdate - [[rangeDay]] and sysdate
                                   and D.SECTION_NAME = [[sectionName]]
                                   order by c1.in_station_time ) aa) a
left join (select bb.* ,rownum seq from (select c1.* from  r_sn_ATT_t c1 
                                   join c_sn_ATT_t D on c1.group_name = D.GROUP_NAME and D.LINE_NAME = c1.line_name and D.VALID_FLAG = 0
                                   where c1.line_name = [[LineName]]
                                   and c1.in_station_time  between sysdate - [[rangeDay]] and sysdate
                                   and D.SECTION_NAME = [[sectionName]]
                                   order by c1.in_station_time ) bb) b
on a.seq=b.seq-1 and a.line_name=b.line_name AND a.group_name=b.group_name 
left join (select * from r_schedule_sap_t where OUTPUT_STATION is not null) C
ON B.line_name=c.line and B.mo_number=c.sfcs_mo and B.model_name=c.sfcs_model and C.OUTPUT_STATION is not null
)
select mes.seq,mes.in_station_time,mes.ATT,
mes.model_name1,mes.mo_number,mes.line_name,mes.group_name,mes.serial_number,
mes.last_serial_number ,mes.last_in_station_time,mes.model_name,mes.OI_RATE,mes.dataFrom from mes 
union all
select equData.seq,equData.in_station_time,equData.ATT,
equData.model_name1,equData.mo_number,equData.line_name,equData.group_name,equData.serial_number,
equData.last_serial_number ,equData.last_in_station_time,equData.model_name,equData.OI_RATE,equData.dataFrom from(
    select rownum seq,c11.end_point in_station_time ,c11.cycle_time ATT,
    c11.model_name model_name1,c11.mo_number mo_number,a11.line_name line_name,a11.group_name group_name,
    '' serial_number, '' last_serial_number,c11.end_point last_in_station_time,c11.model_name model_name,d11.oi_rate OI_RATE,'dataFromEquipment' dataFrom
    from  c_sn_att_t a11
    inner join c_station_config_t b11
    on a11.line_name=b11.line_name and a11.group_name=b11.group_name and a11.valid_flag='0'
    inner join r_equipment_pub_param_record_t  c11
    on b11.equipment_id=c11.equipment_id
    left join (select * from r_schedule_sap_t where OUTPUT_STATION is not null) d11
    on a11.line_name=d11.line and c11.mo_number=d11.sfcs_mo and c11.model_name=d11.sfcs_model
    where  a11.line_name=[[LineName]] and a11.section_name = [[sectionName]]
    and c11.end_point  between sysdate - [[rangeDay]] and sysdate) equData
where equData.line_name||equData.group_name not in (select mes.line_name||mes.group_name from mes )
order by IN_STATION_TIME DESC
--------------------------------------------
#taktTime

#getTakeTimeBySectionMenu
--------------------------------------------
select distinct LINE_NAME,SECTION_NAME,GROUP_NAME from c_sn_ATT_t
where VALID_FLAG = 0 and LINE_NAME = [[LineName]]/*FLAG 0 代表有效, 1代表無效*/
--------------------------------------------
#getTakeTimeBySectionMenu

#getQualityPassFailQtyByGroup
--------------------------------------------
with factYield as (
  select WORK_DATE, WORK_DATE||to_char(TRUNC(WORK_SECTION/2),'FM00')||to_char(mod(WORK_SECTION,2)*30,'FM00') as WORK_TIME,
         MO_NUMBER,MODEL_NAME,LINE_NAME,SECTION_NAME,GROUP_NAME,PASS_QTY,FAIL_QTY,REPASS_QTY,0 as LAB_REPAIR_QTY,0 as NOLAB_REPAIR_QTY
    from R_STATION_REC_T 
    where 1=1
    and WORK_DATE in( to_char(sysdate -1,'YYYYMMDD') ,to_char(sysdate + 1,'YYYYMMDD'),to_char(sysdate ,'YYYYMMDD'))
    and line_name =[[LineName]]
    and (PASS_QTY + FAIL_QTY) > 0
    and GROUP_NAME=[[GroupName]]
    AND WORK_DATE||to_char(TRUNC(WORK_SECTION/2),'FM00')||to_char(mod(WORK_SECTION,2)*30,'FM00') >=[[SectionByShiftFrom]]  
    AND  WORK_DATE||to_char(TRUNC(WORK_SECTION/2),'FM00')||to_char(mod(WORK_SECTION,2)*30,'FM00') <=[[SectionByShiftTo]]
)
select TRIM(TO_CHAR(sum(nvl(FAIL_QTY,0)), '999G999G999G999')) || '/' ||  TRIM(TO_CHAR(sum(nvl(PASS_QTY,0)), '999G999G999G999')) QTY,
        trim(to_char((sum(nvl(PASS_QTY,0)) / DECODE(sum(nvl(FAIL_QTY,0) + nvl(PASS_QTY,0)),0,1,sum(nvl(FAIL_QTY,0) + nvl(PASS_QTY,0)))) * 100,999.99))||'%'   RATE
 from factYield
--------------------------------------------
#getQualityPassFailQtyByGroup



#getFaultCurriculumVitae
  --------------------------------------------
SELECT serial_number,mo_number,model_name,test_time,test_code,test_desc,reason_code,reason_desc,repair_code,repair_desc,repairer,correctiveactionCode,correctiveactionDesc FROM (
SELECT 'No Label-Count:'||(nvl(nlf.fail_qty,0)-nvl(sum(rnl.repair_qty),0)) serial_number,
nvl(nlf.mo_number,'-') mo_number,
nvl(nlf.model_name,'-') model_name,
nlf.set_time test_time,
nvl(nlf.error_code,'-') test_code,
nvl(nvl(ec1.error_desc,nlf.error_code),'-') test_desc,
'-' reason_code,
'-' reason_desc,
'-'repair_code,
'-' repair_desc,
'-' repairer,
'-' correctiveactionCode,
'-' correctiveactionDesc
FROM R_NO_LABEL_FAIL_T nlf left join R_REPAIR_NO_LABEL_T rnl on nlf.item_id=rnl.item_id  left join c_error_code_t ec1 on nlf.error_code=ec1.error_code
inner join c_station_config_t s on s.line_name=nlf.line_name and nlf.section_name=s.section_name and s.group_name = nlf.group_name 
inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name = [[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
on nlf.line_name = tdate.line_name and s.station_name=[[stationName]] and 
nlf.set_time between tdate.begin_time and tdate.end_time
group by  nlf.item_id,nlf.fail_qty,nlf.model_name,nlf.mo_number,nlf.set_time,nlf.error_code,ec1.error_desc having (nvl(nlf.fail_qty,0)-nvl(sum(rnl.repair_qty),0))<>0
union all
SELECT 'No Label-Count:'||rnl.repair_qty serial_number,
rnl.mo_number mo_number,
rnl.model_name model_name,
nlf.set_time test_time,
nvl(nlf.error_code,'N/A') test_code,
nvl(ec1.error_desc,'N/A') test_desc,
rnl.reason_code reason_code,
 nvl(rc.reason_desc, '-') reason_desc,
rnl.error_code repair_code,
ec2.error_desc repair_desc,
 nvl(nvl(emp.emp_name,rnl.repair_emp),'-') repairer,
 '-' correctiveactionCode,
 '-' correctiveactionDesc
from R_NO_LABEL_FAIL_T nlf inner join R_REPAIR_NO_LABEL_T rnl on nlf.item_id=rnl.item_id 
left join c_emp_desc_T emp  on emp.emp_no=rnl.repair_emp left join c_error_code_t ec1 on nlf.error_code=ec1.error_code left join
c_error_code_t ec2 on rnl.error_code=ec2.error_code
left join c_reason_code_t rc on rc.reason_code=rnl.reason_code and rc.prod_plant in (SELECT mo.prod_plant FROM r_mo_overall_v mo where mo.mo_number=nlf.mo_number and mo.model_name=nlf.model_name and rownum=1)
inner join c_station_config_t s on s.line_name=nlf.line_name and nlf.section_name=s.section_name and s.group_name = nlf.group_name 
inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name =[[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
on nlf.line_name = tdate.line_name and nlf.group_name=[[groupName]]  and
nlf.set_time between tdate.begin_time and tdate.end_time
union all
SELECT distinct re.serial_number serial_number,
       re.mo_number mo_number,
       re.model_name model_name,
       re.test_time test_time,
       re.test_code test_code,
       ec1.error_desc test_desc,
       re.reason_code reason_code,
       nvl(rc.reason_desc, re.reason_detail) reason_desc,
       re.errorcode repair_code,
       ec2.error_desc repair_desc,
       nvl(nvl(emp.emp_name,re.repairer),'-') repairer,
       nvl(re.correctiveaction,'-') correctiveactionCode,
       nvl(nvl(ca.correct_action_desc,re.correctiveaction),'-') correctiveactionDesc
  FROM r_repair_t re
  left join c_emp_desc_T emp
    on emp.emp_no=re.repairer
  left join c_error_code_t ec1
    on re.test_code = ec1.error_code
  left join c_error_code_t ec2
    on re.errorcode = ec2.error_code
  left join c_reason_code_t rc
    on rc.reason_code = re.reason_code
	and rc.prod_plant in (SELECT mo.prod_plant FROM r_mo_overall_v mo where mo.mo_number=re.mo_number and mo.model_name=re.model_name and rownum=1)
  left join  C_CORRECTIVE_ACTION_T ca on re.correctiveaction=ca.correct_action_name
  inner join(
SELECT line_name,max(to_date(decode(substr(section_range, 6, 4),
                          '2400',
                          to_char(to_date(t.work_date, 'YYYYMMDD') + 1,
                                  'YYYYMMDD'),
                          t.work_date || substr(section_range, 6, 4)),
                   'YYYYMMDDhh24mi')) end_time,
       min(to_date(t.work_date ||
                   decode(substr(section_range, 0, 4),
                          '2400',
                          '0000',
                          substr(section_range, 0, 4)),
                   'YYYYMMDDhh24mi')) begin_time
  FROM (select to_char(to_date([[beginDate]], 'YYYYMMDD') - 1 + LEVEL,
                       'YYYYMMDD') AS FDATE
          from dual
        CONNECT BY LEVEL <= (to_date([[endDate]], 'YYYYMMDD') -
                   to_date([[beginDate]], 'YYYYMMDD') + 1)) tdate
 inner join (SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_t
             union
             SELECT work_date, line_name, shift, section_range
               FROM r_pqm_daily_sum_smt_t) t
    on t.line_name =[[lineName]]
   and ((work_date = FDATE and
       (t.shift = 'DAY' or
       (t.shift = 'NIGHT' and
       decode(substr(section_range, 0, 4),
                  '2400',
                  '0000',
                  substr(section_range, 0, 4)) > '1200'))) or
       (work_date = to_char(to_date(FDATE, 'YYYYMMDD') + 1, 'YYYYMMDD') and
       t.shift = 'NIGHT' and substr(section_range, 0, 4) < '1200'))
 group by FDATE,line_name) tdate
  on re.test_line = tdate.line_name and re.test_station=[[stationName]]  and
re.test_time between tdate.begin_time and tdate.end_time)
order by test_time
#getFaultCurriculumVitae
 --------------------------------------------

#========================SMT Dashboard API============================Start
#getSMTThrowMaterialBoardInfo
 --------------------------------------------
 SELECT T1.*, DECODE(T2.LINE_NAME, NULL, 'N', '0') ERR_FLAG
  FROM (SELECT A.LINE_NAME,
               B.MO_NUMBER,
               B.SIDE,
               DECODE(SUM(C.USED_QTY),
                      0,
                      '0',
                      TO_CHAR(NVL(TRUNC(SUM(C.FDR_ERR_QTY) / SUM(C.USED_QTY),
                                        4) * 100,
                                  0),
                              'fm9999999990.00')) || '%' MO_ERR_YIELD 
          FROM ( select * from c_prod_area_line_t where delete_flag='0' ) A
         INNER JOIN R_MACHINE_STATION_INLINE_T B
            ON A.LINE_NAME = B.LINE_NAME
          LEFT JOIN R_SMT_ALERT_PN_MONITORING_T C
            ON B.MO_NUMBER = C.WO
           AND B.SIDE = C.SIDE
           AND B.MACHINE_ID = C.MACHINE_ID
         WHERE A.PROD_AREA_ID = [[prod_area_id]]
         GROUP BY A.LINE_NAME, B.MO_NUMBER, B.SIDE) T1
  LEFT JOIN (SELECT A.LINE_NAME, B.MO_NUMBER, B.SIDE
               FROM ( select * from c_prod_area_line_t where delete_flag='0' ) A
              INNER JOIN R_MACHINE_STATION_INLINE_T B
                 ON A.LINE_NAME = B.LINE_NAME
              INNER JOIN R_SMT_ALERT_PN_MONITORING_T C
                 ON B.MO_NUMBER = C.WO
                AND B.SIDE = C.SIDE
                AND B.MACHINE_ID = C.MACHINE_ID
              INNER JOIN R_SMT_PN_T BOM
                 ON B.ACTUAL_MO = BOM.MO_NUMBER
                AND B.ACTUAL_SIDE = BOM.SIDE
                AND B.MACHINE_TYPE = BOM.MACHINE_TYPE
                AND BOM.SLOT_ID = C.SLOT_ID
                AND BOM.SLOT_FLAG = '1'
              INNER JOIN R_SMT_OPENIF_SETTING_T D
                 ON C.MACHINE_ID = D.MACHINE_ID
              WHERE A.PROD_AREA_ID = [[prod_area_id]]
                AND NVL(C.STAGE_USED_QTY, 0) > 0
                AND (NVL(C.STAGE_ERR_QTY, 0) + NVL(C.STAGE_REJ_QTY, 0) +
                    NVL(C.STAGE_DIS_QTY, 0) + NVL(C.STAGE_NPC_QTY, 0)) >
                    D.REJECTED_QTY
                AND ((NVL(C.STAGE_ERR_QTY, 0) + NVL(C.STAGE_REJ_QTY, 0) +
                    NVL(C.STAGE_DIS_QTY, 0) + NVL(C.STAGE_NPC_QTY, 0)) /
                    C.STAGE_USED_QTY) * 100 > D.REJECTED_RATE
              GROUP BY A.LINE_NAME, B.MO_NUMBER, B.SIDE) T2
    ON T1.LINE_NAME = T2.LINE_NAME
   AND T1.MO_NUMBER = T2.MO_NUMBER
   AND T1.SIDE = T2.SIDE
 ORDER BY T1.LINE_NAME
 --------------------------------------------
#getSMTThrowMaterialBoardInfo

#getSMTThrowMaterialBoardLineInfo
--------------------------------------------
SELECT DISTINCT B.LINE_NAME,
                B.WO,
                B.SIDE,
                B.MACHINE_TYPE,
                B.MACHINE_ID,
                B.SLOT_ID,
                B.ITEM_CODE,
                B.COLL_REJECTED_TIME,
                NVL(B.STAGE_ERR_QTY, 0) STAGE_ERR_QTY,
                NVL(B.STAGE_REJ_QTY, 0) STAGE_REJ_QTY,
                NVL(B.STAGE_DIS_QTY, 0) STAGE_DIS_QTY,
                NVL(B.STAGE_NPC_QTY, 0) STAGE_NPC_QTY,
                NVL(B.STAGE_USED_QTY, 0) STAGE_USED_QTY,
                TO_CHAR(TRUNC((NVL(B.STAGE_ERR_QTY, 0) +
                              NVL(B.STAGE_REJ_QTY, 0) +
                              NVL(B.STAGE_DIS_QTY, 0) +
                              NVL(B.STAGE_NPC_QTY, 0)) / B.STAGE_USED_QTY,
                              4) * 100,
                        'fm9999999990.00') || '%' STAGE_YIELD,
                C.REJECTED_QTY,
                C.REJECTED_RATE
  FROM R_MACHINE_STATION_INLINE_T A
 INNER JOIN R_SMT_ALERT_PN_MONITORING_T B
    ON A.MO_NUMBER = B.WO
   AND A.SIDE = B.SIDE
   AND A.MACHINE_ID = B.MACHINE_ID
 INNER JOIN R_SMT_OPENIF_SETTING_T C
    ON B.MACHINE_ID = C.MACHINE_ID
 INNER JOIN R_SMT_PN_T D
    ON A.ACTUAL_MO = D.MO_NUMBER
   AND A.ACTUAL_SIDE = D.SIDE
   AND A.MACHINE_TYPE = D.MACHINE_TYPE
   AND B.SLOT_ID = D.SLOT_ID
   AND D.SLOT_FLAG = '1'
 WHERE A.LINE_NAME = [[lineName]]
   AND B.STAGE_USED_QTY > 0
   AND (NVL(B.STAGE_ERR_QTY, 0) + NVL(B.STAGE_REJ_QTY, 0) +
       NVL(B.STAGE_DIS_QTY, 0) + NVL(B.STAGE_NPC_QTY, 0)) > C.REJECTED_QTY
   AND ((NVL(B.STAGE_ERR_QTY, 0) + NVL(B.STAGE_REJ_QTY, 0) +
       NVL(B.STAGE_DIS_QTY, 0) + NVL(B.STAGE_NPC_QTY, 0)) /
       B.STAGE_USED_QTY) * 100 > C.REJECTED_RATE
 ORDER BY STAGE_YIELD
 --------------------------------------------
#getSMTThrowMaterialBoardLineInfo

#getSMTReceiveMaterialBoardInfo
 --------------------------------------------
SELECT LINE_NAME,
       MO_NUMBER,
       SIDE,
       DECODE(SUBSTR(SLOT_STATUS, 1, 1), '0', '0', '1', '1', 'N') SLOT_STATUS
  FROM (SELECT ROW_NUMBER() OVER(PARTITION BY LINE_NAME, MO_NUMBER, SIDE ORDER BY SLOT_STATUS) rn,
               T.*
          FROM (SELECT A.LINE_NAME, B.MO_NUMBER, B.SIDE, SLOT_STATUS 
                  FROM ( select * from c_prod_area_line_t where delete_flag='0' ) A
                 INNER JOIN R_MACHINE_STATION_INLINE_T B
                    ON A.LINE_NAME = B.LINE_NAME
                  LEFT JOIN R_SMT_ALERT_PN_MONITORING_T C
                    ON B.MO_NUMBER = C.WO
                   AND B.SIDE = C.SIDE
                   AND B.MACHINE_ID = C.MACHINE_ID
                  LEFT JOIN R_SMT_SLOT_GROUP_T D
                    ON C.WO = D.MO_NUMBER
                   AND C.SIDE = D.SIDE
                   AND C.MACHINE_TYPE = D.MACHINE_TYPE
                   AND C.SLOT_ID = D.MAIN_SLOT_ID
                 WHERE A.PROD_AREA_ID = [[prod_area_id]]--5,154,152,256
                   AND D.MAIN_SLOT_ID IS NULL
                   AND EXISTS (SELECT *
                          FROM R_SMT_PN_T
                         WHERE MO_NUMBER = B.ACTUAL_MO
                           AND SIDE = B.ACTUAL_SIDE
                           AND MACHINE_TYPE = B.MACHINE_TYPE
                           AND SLOT_ID = C.SLOT_ID
                           AND SLOT_FLAG = 1)) T)
 WHERE rn = 1
 ORDER BY LINE_NAME
 -------------------------------------------- 
#getSMTReceiveMaterialBoardInfo

#getSMTReceiveMaterialBoardLineInfo
 --------------------------------------------
SELECT A.LINE_NAME LINE,
       F.GROUPWONO SAP_GROUP_ID,
       A.MO_NUMBER SMT_GROUP_ID,
       A.SIDE,
       B.ITEM_CODE PART_NUM,
       B.SLOT_ID SLOT_NUM,
       B.QPA,
       NVL(C.PCB_QTY, 0) PCB_UNIT,
       B.ACTUAL_REMAIN_QTY SLOT_REMAIN_QTY,
       (CASE
         WHEN B.ACTUAL_REMAIN_QTY > 0 THEN
          TRUNC(B.ACTUAL_REMAIN_QTY / B.QPA)
         ELSE
          0
       END) LINK_PCB_UNIT
  FROM R_MACHINE_STATION_INLINE_T A
 INNER JOIN R_SMT_ALERT_PN_MONITORING_T B
    ON A.MO_NUMBER = B.WO
   AND A.SIDE = B.SIDE
   AND A.MACHINE_ID = B.MACHINE_ID
 INNER JOIN R_SMT_PN_T BOM
    ON A.ACTUAL_MO = BOM.MO_NUMBER
   AND A.ACTUAL_SIDE = BOM.SIDE
   AND A.MACHINE_TYPE = BOM.MACHINE_TYPE
   AND B.SLOT_ID = BOM.SLOT_ID
   AND BOM.SLOT_FLAG = '1'
  LEFT JOIN R_SMT_SLOT_GROUP_T G
    ON B.WO = G.MO_NUMBER
   AND B.SIDE = G.SIDE
   AND B.MACHINE_TYPE = G.MACHINE_TYPE
   AND B.SLOT_ID = G.MAIN_SLOT_ID
  LEFT JOIN C_MODEL_DESC_T C
    ON B.MODEL = C.MODEL_NAME
  LEFT JOIN R_SMTMO_JITMO_T E
    ON A.ACTUAL_MO = E.SMT_MO
  LEFT JOIN R_JIT_WOLINK_T F
    ON E.JIT_MO = F.WONO
   AND A.ACTUAL_SIDE = F.SIDE
 WHERE A.LINE_NAME = [[lineName]]
   AND B.SLOT_STATUS NOT IN ('N', '2')
   AND G.MAIN_SLOT_ID IS NULL
 ORDER BY A.LINE_NAME, B.ACTUAL_REMAIN_QTY
 -------------------------------------------- 
#getSMTReceiveMaterialBoardLineInfo

#getAOIMonitorInfo
 --------------------------------------------
SELECT al.factory,
       al.line_name,
       al.equip_code,
       pre.program_name,
       al.good          al_good, --梯次内累计良品数量
       al.total         al_total, --梯次内累计数量
       al.goodrate      al_goodrate, --梯次内累计良率
       al.fail          al_fail, --梯次内累计不良品数量
       al.failrate      al_failrate, --梯次内累计不良率
       pre.good         pre_good, --梯次内当前程式良品数量
       pre.total        pre_total, --梯次内当前程式测试数量
       pre.goodrate     pre_goodrate, --梯次内当前程式良率
       pre.fail         pre_fail, --梯次内当前程式不良品数量
       pre.failrate     pre_failrate --梯次内当前程式不良率
  FROM (SELECT d.factory,
               d.line_name,
               d.equip_code,
               sum(d.goodqty) good,
               sum(d.cont_qty) total,
               to_char(round(sum(d.goodqty) / sum(d.cont_qty), 4) * 100,
                       'fm9999999990.00') || '%' goodrate,
               sum(d.passqty) pass,
               sum(d.failqty) fail,
               to_char(round(sum(d.failqty) / sum(d.cont_qty), 4) * 100,
                       'fm9999999990.00') || '%' failrate
          FROM r_smt_detail_t d
         inner join (SELECT t.line_name,
                           et.shift,
                           to_date(to_char(sysdate, 'yyyymmdd') ||
                                   min(et.section_from),
                                   'yyyymmdd HH24miss') section_from,
                           to_date(to_char(sysdate, 'yyyymmdd') ||
                                   max(et.section_to),
                                   'yyyymmdd HH24miss') section_to
                      FROM c_line_echelon_t t
                     inner join c_echelon_section_t et
                        on t.echelon_name = et.echelon_name
                       and et.shift = 'DAY'
                     group by t.line_name, et.shift) m
            on d.line_name = m.line_name
         where d.factory = [[factory]]
           and d.group_name = 'AOI'
           and d.insert_date between (case
                 when sysdate between m.section_from and m.section_to then
                  m.section_from
                 else
                  case
                    when to_char(sysdate, 'hh24') >=
                         to_char(m.section_to, 'hh24') then
                     m.section_to
                    else
                     m.section_to - 1
                  end
               end)
           and sysdate
         group by d.factory, d.line_name, d.equip_code) al
 inner join (SELECT d.factory,
                    d.line_name,
                    d.equip_code,
                    d.program_name,
                    sum(d.goodqty) good,
                    sum(d.cont_qty) total,
                    to_char(round(sum(d.goodqty) / sum(d.cont_qty), 4) * 100,
                            'fm9999999990.00') || '%' goodrate,
                    sum(d.passqty) pass,
                    sum(d.failqty) fail,
                    to_char(round(sum(d.failqty) / sum(d.cont_qty), 4) * 100,
                            'fm9999999990.00') || '%' failrate
               FROM r_smt_detail_t d
              inner join (SELECT *
                           FROM (select t.factory,
                                        t.line_name,
                                        t.group_name,
                                        t.equip_code,
                                        t.program_name,
                                        t.insert_date,
                                        rank() over(partition by t.factory, t.line_name, t.group_name, t.equip_code order by t.insert_date desc) rank1
                                   from r_smt_detail_t t)
                          WHERE rank1 = 1) n1
                 on d.factory = n1.factory
                and d.line_name = n1.line_name
                and d.group_name = n1.group_name
                and d.equip_code = n1.equip_code
                and d.program_name = n1.program_name
              inner join (SELECT t.line_name,
                                et.shift,
                                to_date(to_char(sysdate, 'yyyymmdd') ||
                                        min(et.section_from),
                                        'yyyymmdd HH24miss') section_from,
                                to_date(to_char(sysdate, 'yyyymmdd') ||
                                        max(et.section_to),
                                        'yyyymmdd HH24miss') section_to
                           FROM c_line_echelon_t t
                          inner join c_echelon_section_t et
                             on t.echelon_name = et.echelon_name
                            and et.shift = 'DAY'
                          group by t.line_name, et.shift) m
                 on d.line_name = m.line_name
               left join (SELECT *
                           FROM (select t.factory,
                                        t.line_name,
                                        t.group_name,
                                        t.equip_code,
                                        t.program_name,
                                        t.insert_date from_date,
                                        rank() over(partition by t.factory, t.line_name, t.equip_code order by t.insert_date desc) rank1,
                                        t.flag
                                   from r_smt_detail_t t
                                  where t.flag = 1)
                          WHERE rank1 = 1) n
                 on d.factory = n.factory
                and d.line_name = n.line_name
                and d.group_name = n.group_name
                and d.equip_code = n.equip_code
                and d.program_name = n.program_name
              where d.factory = [[factory]]
                and d.group_name = 'AOI'
                and d.insert_date between (case
                      when sysdate between m.section_from and m.section_to then
                       (case
                         when n.from_date is null then
                          m.section_from
                         else
                          case
                            when n.from_date between m.section_from and
                                 m.section_to then
                             n.from_date
                            else
                             m.section_from
                          end
                       end)
                      else
                       (case
                         when n.from_date is null then
                          case
                            when to_char(sysdate, 'hh24') >=
                                 to_char(m.section_to, 'hh24') then
                             m.section_to
                            else
                             m.section_to - 1
                          end
                         else
                          case
                            when to_char(sysdate, 'hh24') >=
                                 to_char(m.section_to, 'hh24') then
                             case
                               when m.section_to <= n.from_date then
                                n.from_date
                               else
                                m.section_to
                             end
                            else
                             case
                               when m.section_to - 1 <= n.from_date then
                                n.from_date
                               else
                                m.section_to - 1
                             end
                          end
                       end)
                    end)
                and sysdate
              group by d.factory, d.line_name, d.equip_code, d.program_name) pre
    on al.factory = pre.factory
   and al.line_name = pre.line_name
   and al.equip_code = pre.equip_code
 order by al.factory, al.line_name, al.equip_code
 -------------------------------------------- 
#getAOIMonitorInfo

#getFurnaceTemperatureInfo
 --------------------------------------------
select t.line_name, t.product_name, t.pwi || '%' pwi, t.cpk || '%' cpk
  from c_reflow_equip_data_t t
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) prod
    on t.line_name = prod.line_name
   and prod.prod_area_id = [[prod_area_id]]
 --------------------------------------------   
#getFurnaceTemperatureInfo

#getNXTLineInfo
 --------------------------------------------
 select t.line_name SMT_LINE_NAME, 
        sum(decode(('M' || t.module_no),'M1',t.status,null)) M1,
	   sum(decode(('M' || t.module_no),'M2',t.status,null)) M2,
	   sum(decode(('M' || t.module_no),'M3',t.status,null)) M3,
	   sum(decode(('M' || t.module_no),'M4',t.status,null)) M4,
	   NVL(sum(decode(('M' || t.module_no),'M5',t.status,null)),0) M5,
	   NVL(sum(decode(('M' || t.module_no),'M6',t.status,null)),0) M6,
       NVL(sum(decode(('M' || t.module_no),'M7',t.status,null)),0) M7,
	   NVL(sum(decode(('M' || t.module_no),'M8',t.status,null)),0) M8,
       NVL(sum(decode(('M' || t.module_no),'M9',t.status,null)),0) M9,
       NVL(sum(decode(('M' || t.module_no),'M10',t.status,null)),0) M10,
       NVL(sum(decode(('M' || t.module_no),'M11',t.status,null)),0) M11,
       NVL(sum(decode(('M' || t.module_no),'M12',t.status,null)),0) M12
from
(select module_no,status,line_name from c_nxt_equip_statu_t a where update_time = (select max(update_time) from c_nxt_equip_statu_t b 
 where a.line_name = b.line_name 
 and a.module_no = b. module_no ) 
 order by a.line_name,a.module_no
)t 
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) p 
    on t.line_name = p.line_name 
 where p.prod_area_id = [[prod_area_id]] 
group by t.line_name
order by t.line_name
 -------------------------------------------- 
#getNXTLineInfo

#getNXTAllInfo
 --------------------------------------------
 SELECT distinct t1.line_name, 'M'|| t1.module_no module_no, t1.status
  FROM c_nxt_equip_statu_t t1
  inner join ( select * from c_prod_area_line_t where delete_flag='0' ) prod
    on t1.line_name = prod.line_name
   and prod.prod_area_id = [[prod_area_id]]
inner join (SELECT t.line_name, t.module_no, max(t.update_time) update_time
               FROM c_nxt_equip_statu_t t
              WHERE t.update_time > sysdate - 1
              group by t.line_name, t.module_no) t2
    on t1.line_name = t2.line_name
   and t1.module_no = t2.module_no
   and t1.update_time = t2.update_time
order by t1.line_name,module_no
 -------------------------------------------- 
#getNXTAllInfo

#getAllByEchelonSumRepairNum
 --------------------------------------------
select repair.test_line, repair.repair_count, nvl(repaired.repaired_count,0) repaired_count , decode(repair.repair_count,0,0, round(nvl(repaired.repaired_count,0) / repair.repair_count,4)*100) ach
  from (SELECT rt.test_line, count(1) repair_count
          FROM r_repair_t rt
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on rt.test_line = c.line_name
           and c.prod_area_id = [[prod_area_id]]
         inner join (SELECT t.line_name,
                           et.shift,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   min(et.section_from),
                                   'yyyymmdd HH24miss') section_from,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   max(et.section_to),
                                   'yyyymmdd HH24miss') section_to
                      FROM c_line_echelon_t t
                     inner join c_echelon_section_t et
                        on t.echelon_name = et.echelon_name
                       and et.shift = 'DAY'
                     group by t.line_name, et.shift) m
            on rt.test_line = m.line_name
         where rt.test_time between (case
                 when sysdate between m.section_from and m.section_to then
                  m.section_from
                 else
                  case
                    when to_char(sysdate , 'hh24') >=
                         to_char(m.section_to, 'hh24') then
                     m.section_to
                    else
                     m.section_to - 1
                  end
               end)
           and sysdate
         group by rt.test_line) repair
left join (SELECT rt.test_line, count(1) repaired_count
               FROM r_repair_t rt
              inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
                 on rt.test_line = c.line_name
                and c.prod_area_id = [[prod_area_id]]
              inner join (SELECT t.line_name,
                                et.shift,
                                to_date(to_char(sysdate , 'yyyymmdd') ||
                                        min(et.section_from),
                                        'yyyymmdd HH24miss') section_from,
                                to_date(to_char(sysdate , 'yyyymmdd') ||
                                        max(et.section_to),
                                        'yyyymmdd HH24miss') section_to
                           FROM c_line_echelon_t t
                          inner join c_echelon_section_t et
                             on t.echelon_name = et.echelon_name
                            and et.shift = 'DAY'
                          group by t.line_name, et.shift) m
                 on rt.test_line = m.line_name
              where rt.repair_time is not null
                and rt.test_time between (case
                      when sysdate between m.section_from and m.section_to then
                       m.section_from
                      else
                       case
                         when to_char(sysdate , 'hh24') >=
                              to_char(m.section_to, 'hh24') then
                          m.section_to
                         else
                          m.section_to - 1
                       end
                    end)
                and sysdate
              group by rt.test_line) repaired
    on repair.test_line = repaired.test_line order by repair.test_line
 -------------------------------------------- 
#getAllByEchelonSumRepairNum

#getAllByBadReasonEchelonSumRepairNum
 --------------------------------------------
SELECT rt.test_code, count(1) repair_count
  FROM r_repair_t rt
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
    on rt.test_line = c.line_name
   and c.prod_area_id = [[prod_area_id]]
 inner join (SELECT t.line_name,
                    et.shift,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            min(et.section_from),
                            'yyyymmdd HH24miss') section_from,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            max(et.section_to),
                            'yyyymmdd HH24miss') section_to
               FROM c_line_echelon_t t
              inner join c_echelon_section_t et
                 on t.echelon_name = et.echelon_name
                and et.shift = 'DAY'
              group by t.line_name, et.shift) m
    on rt.test_line = m.line_name
 where rt.test_time between (case
         when sysdate between m.section_from and m.section_to then
          m.section_from
         else
          case
            when to_char(sysdate, 'hh24') >= to_char(m.section_to, 'hh24') then
             m.section_to
            else
             m.section_to - 1
          end
       end)
   and sysdate
 group by rt.test_code
 -------------------------------------------- 
#getAllByBadReasonEchelonSumRepairNum

#getAllByBadModelEchelonSumRepairNum
 --------------------------------------------
SELECT  rt.model_name, count(1) repair_count
          FROM r_repair_t rt
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on rt.test_line = c.line_name
           and c.prod_area_id = [[prod_area_id]]
         inner join (SELECT t.line_name,
                           et.shift,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   min(et.section_from),
                                   'yyyymmdd HH24miss') section_from,
                           to_date(to_char(sysdate , 'yyyymmdd') ||
                                   max(et.section_to),
                                   'yyyymmdd HH24miss') section_to
                      FROM c_line_echelon_t t
                     inner join c_echelon_section_t et
                        on t.echelon_name = et.echelon_name
                       and et.shift = 'DAY'
                     group by t.line_name, et.shift) m
            on rt.test_line = m.line_name
            AND rt.test_line in (<<lineName>>)
         where rt.test_time between (case
                 when sysdate between m.section_from and m.section_to then
                  m.section_from
                 else
                  case
                    when to_char(sysdate , 'hh24') >=
                         to_char(m.section_to, 'hh24') then
                     m.section_to
                    else
                     m.section_to - 1
                  end
               end)
           and sysdate
         group by rt.test_line, rt.model_name
order by repair_count DESC
 -------------------------------------------- 
#getAllByBadModelEchelonSumRepairNum

#getLineByBadReasonEchelonInfo
 --------------------------------------------
SELECT rt.test_line, rt.test_code, count(1) repair_count
  FROM r_repair_t rt
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
    on rt.test_line = c.line_name
   and c.prod_area_id = [[prod_area_id]]
 inner join (SELECT t.line_name,
                    et.shift,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            min(et.section_from),
                            'yyyymmdd HH24miss') section_from,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            max(et.section_to),
                            'yyyymmdd HH24miss') section_to
               FROM c_line_echelon_t t
              inner join c_echelon_section_t et
                 on t.echelon_name = et.echelon_name
                and et.shift = 'DAY'
              group by t.line_name, et.shift) m
    on rt.test_line = m.line_name
   and rt.test_line = [[line_name]]
 where rt.test_time between (case
         when sysdate between m.section_from and m.section_to then
          m.section_from
         else
          case
            when to_char(sysdate, 'hh24') >= to_char(m.section_to, 'hh24') then
             m.section_to
            else
             m.section_to - 1
          end
       end)
   and sysdate
 group by rt.test_line, rt.test_code
 -------------------------------------------- 
#getLineByBadReasonEchelonInfo

#getLineByBadModelEchelonInfo
 -------------------------------------------- 
 SELECT rt.test_line, rt.model_name, count(1) repair_count
  FROM r_repair_t rt
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
    on rt.test_line = c.line_name
   and c.prod_area_id = [[prod_area_id]]
 inner join (SELECT t.line_name,
                    et.shift,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            min(et.section_from),
                            'yyyymmdd HH24miss') section_from,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            max(et.section_to),
                            'yyyymmdd HH24miss') section_to
               FROM c_line_echelon_t t
              inner join c_echelon_section_t et
                 on t.echelon_name = et.echelon_name
                and et.shift = 'DAY'
              group by t.line_name, et.shift) m
    on rt.test_line = m.line_name
   AND rt.test_line = [[line_name]]
 where rt.test_time between (case
         when sysdate between m.section_from and m.section_to then
          m.section_from
         else
          case
            when to_char(sysdate, 'hh24') >= to_char(m.section_to, 'hh24') then
             m.section_to
            else
             m.section_to - 1
          end
       end)
   and sysdate
 group by rt.test_line, rt.model_name
 --------------------------------------------  
#getLineByBadModelEchelonInfo

#getProductPlanInfo
 -------------------------------------------- 
 SELECT on_line.line, --线别
       on_line.side, --面别
       on_line.mo_number, --在线工单  
       on_line.TARGET_QTY, --目标数
       on_line.percent, --工单进度
       on_line.planpercent, --计划进度
       pre_line.start_date, --换线开始时间
       pre_line.detail --前置状态
  FROM (SELECT A.LINE,
               A.SIDE,
               A.MO_NUMBER,
               A.TARGET_QTY,
               
               a.mo_flag,
               a.output_qty,
               a.start_date,
               
               ROUND((NVL(A.OUTPUT_QTY, 0) / A.TARGET_QTY), 4) * 100 || '%' PERCENT,
               (case a.norm_capacity
                 when 0 then
                  '线速为0'
                 when null then
                  '未维护线速'
                 else
                  LEAST(round((case
                                when sysdate < a.start_date then
                                 0
                                else
                                 sysdate - a.start_date
                              end) * 24 * a.norm_capacity / a.target_qty,
                              4) * 100,
                        100) || '%'
               end) planpercent
          FROM R_MO_SMT_INFO_T A
         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
            on A.line = c.line_name
         WHERE A.MO_FLAG = '1'
           AND c.prod_area_id = [[prod_area_id]] ) on_line 
  left join ( --換線準備
             SELECT en.line,
                     en.start_date,
                     listagg(case en.alart_flag
                               when 0 then
                                en.part_type || '--未啟動報警'
                               when 1 then
                                en.part_type || '--已備，不報警'
                               when 2 then
                                en.part_type || '--未到預警時間'
                               when 3 then
                                en.part_type || '--預警'
                               when 4 then
                                en.part_type || '--警告'
                               else
                                en.part_type || '--' || en.alart_flag
                             end,
                             ',') within group(order by en.line) detail
               FROM (select *
                        from (select m.id,
                                     m.line,
                                     m.start_date,
                                     m.alart_flag,
                                     m.part_type,
                                     rank() over(partition by m.line order by m.line_order) rk
                                from (SELECT DISTINCT A.ID,
                                                      A.LINE,
                                                      A.MO_NUMBER,
                                                      to_char(A.START_DATE,
                                                              'yy-mm-dd hh24:mi') start_date,
                                                      a.LINE_ORDER,
                                                      b0.alart_flag,
                                                      b0.part_type
                                        from r_mo_smt_info_t a
                                       inner join ( select * from c_prod_area_line_t where delete_flag='0' ) c
                                          on a.line = c.line_name
                                        LEFT join r_pqm_line_prepare_smt_t b0
                                          on a.id = b0.id
                                        left join c_model_desc_t d
                                          on a.model_name = d.model_name
                                       where a.mo_flag = '0'
                                         and c.prod_area_id = [[prod_area_id]]) m) 
                       where rk = 1) en
              group by en.line, en.start_date) pre_line
    on on_line.line = pre_line.line
 order by on_line.line
 --------------------------------------------  
#getProductPlanInfo

#getPatchModuleMobility
 -------------------------------------------- 
 SELECT distinct t.line_name,
                case
                  when t.begin_point between (case
                         when sysdate between m.section_from and m.section_to then
                          m.section_from
                         else
                          case
                            when to_char(sysdate, 'hh24') >=
                                 to_char(m.section_to, 'hh24') then
                             m.section_to
                            else
                             m.section_to - 1
                          end
                       end) and sysdate then
                   to_char(t.begin_point, 'YYYY-MM-DD HH24:MI')
                  else
                   to_char(case
                             when sysdate between m.section_from and m.section_to then
                              m.section_from
                             else
                              case
                                when to_char(sysdate, 'hh24') >=
                                     to_char(m.section_to, 'hh24') then
                                 m.section_to
                                else
                                 m.section_to - 1
                              end
                           end,
                           'YYYY-MM-DD HH24:MI')
                end begin_point,
                case
                  when t.end_point is null then
                   to_char(ma.end_point, 'YYYY-MM-DD HH24:MI')
                  else
                   to_char(t.end_point, 'YYYY-MM-DD HH24:MI')
                end end_point
  FROM c_nxt_equip_statu_change_t t
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) prod
    on t.line_name = prod.line_name
      /*and t.line_name = 'SMT_H01'*/
   and prod.prod_area_id = [[prod_area_id]]
 inner join (select distinct line_name, max(end_point) end_point
               from c_nxt_equip_statu_change_t
              WHERE end_point is not null
              group by line_name) ma
    on t.line_name = ma.line_name
 inner join (SELECT t.line_name,
                    et.shift,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            min(et.section_from),
                            'yyyymmdd HH24miss') section_from,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            max(et.section_to),
                            'yyyymmdd HH24miss') section_to
               FROM c_line_echelon_t t
              inner join c_echelon_section_t et
                 on t.echelon_name = et.echelon_name
                and et.shift = 'DAY'
              group by t.line_name, et.shift) m
    on t.line_name = m.line_name
 WHERE t.end_point between (case
         when sysdate between m.section_from and m.section_to then
          m.section_from
         else
          case
            when to_char(sysdate, 'hh24') >= to_char(m.section_to, 'hh24') then
             m.section_to
            else
             m.section_to - 1
          end
       end)
   and sysdate
    or t.end_point is null
union
select distinct t.line_name,
                to_char(case
                          when sysdate between m.section_from and m.section_to then
                           m.section_from
                          else
                           case
                             when to_char(sysdate, 'hh24') >=
                                  to_char(m.section_to, 'hh24') then
                              m.section_to
                             else
                              m.section_to - 1
                           end
                        end,
                        'YYYY-MM-DD HH24:MI') begin_point,
                to_char(case
                          when sysdate between m.section_from and m.section_to then
                           m.section_from
                          else
                           case
                             when to_char(sysdate, 'hh24') >=
                                  to_char(m.section_to, 'hh24') then
                              m.section_to
                             else
                              m.section_to - 1
                           end
                        end,
                        'YYYY-MM-DD HH24:MI') end_point

  from c_nxt_equip_statu_change_t t
 inner join ( select * from c_prod_area_line_t where delete_flag='0' ) prod
    on t.line_name = prod.line_name
      /*and t.line_name = 'SMT_H01'*/
   and prod.prod_area_id = [[prod_area_id]]
 inner join (SELECT t.line_name,
                    et.shift,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            min(et.section_from),
                            'yyyymmdd HH24miss') section_from,
                    to_date(to_char(sysdate, 'yyyymmdd') ||
                            max(et.section_to),
                            'yyyymmdd HH24miss') section_to
               FROM c_line_echelon_t t
              inner join c_echelon_section_t et
                 on t.echelon_name = et.echelon_name
                and et.shift = 'DAY'
              group by t.line_name, et.shift) m
    on t.line_name = m.line_name
 order by line_name, begin_point
 --------------------------------------------  
#getPatchModuleMobility

#getLineBalanceCycleTimeInfo
 -------------------------------------------- 
 select line_name,
       module_no,
       round(sum(cycle_time) / COUNT(1) ，2) cycle_time
  from (SELECT line_name, module_no, cycle_time
          FROM (select distinct t2.line_name,
                                t2.module_no,
                                t2.cycle_time,
                                rank() over(partition by t2.line_name, t2.module_no order by t2.update_time desc) rank1
                  from (select t1.line_name,
                               t1.module_no,
                               t1.cycle_time,
                               t1.update_time
                          from c_nxt_equip_prodfinish_t t1
                         inner join ( select * from c_prod_area_line_t where delete_flag='0' ) prod
                            on t1.line_name = prod.line_name
                           and prod.prod_area_id = [[prod_area_id]]
                         inner join (SELECT t.line_name,
                                           et.shift,
                                           to_date(to_char(sysdate, 'yyyymmdd') ||
                                                   min(et.section_from),
                                                   'yyyymmdd HH24miss') section_from,
                                           to_date(to_char(sysdate, 'yyyymmdd') ||
                                                   max(et.section_to),
                                                   'yyyymmdd HH24miss') section_to
                                      FROM c_line_echelon_t t
                                     inner join c_echelon_section_t et
                                        on t.echelon_name = et.echelon_name
                                       and et.shift = 'DAY'
                                     group by t.line_name, et.shift) m
                            on t1.line_name = m.line_name
                              /* and t1.line_name='SMT_H03'*/
                           and t1.update_time between (case
                                 when sysdate between m.section_from and
                                      m.section_to then
                                  m.section_from
                                 else
                                  case
                                    when to_char(sysdate, 'hh24') >=
                                         to_char(m.section_to, 'hh24') then
                                     m.section_to
                                    else
                                     m.section_to - 1
                                  end
                               end)
                           and sysdate) t2)
         where rank1 <= 50) fina
 WHERE fina.cycle_time <> 0
 group by line_name, module_no
 order by line_name, module_no
 --------------------------------------------  
#getLineBalanceCycleTimeInfo

#========================SMT Dashboard API============================End
